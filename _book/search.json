[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R f√ºr Psychos",
    "section": "",
    "text": "time is a flat circle‚Ü©Ô∏é\nzumindest dieses eine Mal in 2018‚Ü©Ô∏é\nAllen voran ggplot2, das package f√ºr plots in R.‚Ü©Ô∏é"
  },
  {
    "objectID": "chapters/01-Was-ist-R.html",
    "href": "chapters/01-Was-ist-R.html",
    "title": "2¬† Was ist R",
    "section": "",
    "text": "R ist eine Programmiersprache, und ja, das klingt abschreckend.\nF√ºr uns hei√üt das in erster Linie Folgendes:"
  },
  {
    "objectID": "chapters/01-Was-ist-R.html#was-ist-an-r-so-toll",
    "href": "chapters/01-Was-ist-R.html#was-ist-an-r-so-toll",
    "title": "2¬† Was ist R",
    "section": "2.1 Was ist an R so toll?",
    "text": "2.1 Was ist an R so toll?\nNicht alles an R ist toll ‚Äî und sobald ihr das erste Mal mehrere Stunden damit verbracht habt, ein vergleichsweise einfaches Problem l√∂sen zu wollen, werdet ihr wissen was ich meine.\nDie am h√§ufigsten zitierten Vorteile sind in etwa die Folgenden:\n\nKostenlos\n\nKeine Lizenzgeb√ºhren\nKeine Update-Geb√ºhren\n\nOpen Source\n\nSoftware-Sprech f√ºr ‚Äújeder kann sich die Innereien angucken‚Äù\nJeder kann R beliebig erweitern und modifizieren\n‚ÄúWas genau macht R an Stelle XYZ‚Äù ist immer beantwortbar, weil der Quelltext offen verf√ºgbar ist\n\nErweiterbarkeit\n\nEs gibt unz√§hlige Erweiterungen (‚Äúpackages‚Äù) f√ºr R, die neue Funktionen bereitstellen\n√úbersicht auf z.B. r-pkg.org\nSogar eure TutorInnen k√∂nnen packages schreiben. Tun sie sogar manchmal.\n\nGute Dokumentation (meistens)\n\nR bringt seine Hilfe selber mit, das ist der ‚ÄúHelp‚Äù-Tab in RStudio. Jede Funktion ist dokumentiert!\nSeiten wie rdocumentation.org oder rdrr.io erlauben es so gut wie alle verf√ºgbaren R packages nach bestimmten Funktionen zu durchsuchen, egal wie obskur der Anwendungsfall auch sein mag\nCommunities wie stackoverflow sind beliebte ‚ÄúIch brauche Hilfe bei XY‚Äù-Anlaufstellen, und eine Horde von Menschen, die meistens das gleiche Problem auch schonmal hatten, k√∂nnen euch helfen\n\nInteraktivit√§t: Wo SPSS auf Buttons und Befehle reagiert und dann einen Stapel PDFs produziert, kann R mit der Konsole auch einfach schnell und interaktiv benutzt werden: ‚ÄúSchnell mal eben was nachgucken‚Äù ist in R deutlich angenehmer als in SPSS, zumindest f√ºr einfache Sachen.\nReproduzierbarkeit: Wenn ihr ein sauberes R-Script geschrieben habt, k√∂nnt ihr das frei verf√ºgbar machen und alle Interessierten k√∂nnen es bei sich selbst ausf√ºhren und B√ÑM!, Ergebnisse reproduziert. In case you didn‚Äôt realize, but that‚Äôs kind of a big thing in science.\nVisualisierung: R hat fantastische Werkzeuge zur Datenvisualisierung, prim√§r sei hier ggplot2 erw√§hnt, was euch erlaubt wundersch√∂ne Grafiken aus euren Daten zu zaubern, und auch das vollkommen reproduzierbar (versucht das mal mit SPSS oder Excel. Worlds of pain.)\nFlexibilit√§t: R ist eine Programmiersprache, das hei√üt per default kann R erstmal alles. Vielleicht nicht alles gut, aber prinzipiell l√§sst sich zumindest theoretisch alles damit anstellen. Dieses Dokument hier? In R (RMarkdown, bookdown) geschrieben. Dynamische Webseiten? Auch m√∂glich, googlet ‚ÄúR shiny‚Äù. Interaktive Elemente? Auch kein Ding, googlet ‚ÄúR htmlwidgets‚Äù. Daten aus Software wie SPSS, Excel oder sogar Google Sheets importieren? Auch kein Problem. You get the idea.\nAktive Entwicklung & Community: R wird immer besser. Immer mehr Leute benutzen R, von diesen Leuten haben einige gute Ideen, und davon wiederum gibt es einige, die diese sogar umsetzen. Das Resultat ist ein stetig wachsendes und gedeihendes √ñkosystem um R und eine aktive Community auf diversen Netzwerken, die sowohl Hilfestellung liefern k√∂nnen als auch aktiv an besseren Tools rund um R arbeiten, von besserer Dokumentation bis zu besserer Integration mit anderer Software."
  },
  {
    "objectID": "chapters/01-Was-ist-R.html#was-ist-r-nicht",
    "href": "chapters/01-Was-ist-R.html#was-ist-r-nicht",
    "title": "2¬† Was ist R",
    "section": "2.2 Was ist R nicht?",
    "text": "2.2 Was ist R nicht?\nR ist nicht wie SPSS. R ‚Äúnackt‚Äù ist ein Kommandozeilenprogramm. Terminal/Konsole, wie man es auch nennen mag, aber es ist nicht wie die Programme, die ihr im Alltag benutzt. Es gibt keine Kn√∂pfe zum dr√ºcken und alles ist Text, ohne Formatierungskram wie fett oder kursiv, weil die Grundlagen bzw. Vorstufen von R aus einer Zeit kommen, in der Computer noch anders waren und die Mauer noch frisch war.\nWeil das wenig benutzerfreundlich bzw. einsteigerfreundlich ist, gibt es Programme wie RStudio, was sozusagen auf R sitzt und es benutzbar macht. Wenn R ein Pferd ist, ist RStudio ein Sattel.\nDas hei√üt f√ºr euch aber auch, dass ihr eine Datenanalyse nicht durch blo√ües Kn√∂pfchendr√ºcken zusammenstecken k√∂nnt wie das bei SPSS m√∂glich ist ‚Äî ihr m√ºsst Befehle lernen, eure Daten(struktur) verstehen, und euch sicher sein, was ihr tun wollt.\nIch wei√ü, dass das alles wirklich eher krampfig klingt wenn ihr das so lest, weshalb es auch h√§ufig vorkommt, dass Studierende in den ersten Semestern R eher ignorieren und sich lieber mit SPSS besch√§ftigen, weil das weniger kognitiver Aufwand ist ‚Äî aber glaubt mir wenn ich euch sage, dass ‚ÄúR lernen‚Äù eine gute Investition ist. SPSS k√∂nnt ihr euch immer noch irgendwie beibringen oder Youtube-Tutorials gucken oder Befehlslisten ausdrucken und sowieso und √ºberhaupt, R hingegen ist entsprechend komplexer, also nutzt die Zeit in der euch TutorInnen noch helfen k√∂nnen, bevor ihr dann vor eurem Expra-Datensatz sitzt, mit SPSS nicht weiter kommt und wie der Ochs vor‚Äôm Berg an R sitzt.\nIch betone das √ºbrigens nicht, weil ich SPSS doof finde (was ich tue), oder R so toll finde (was ich tue), sondern tats√§chlich aus Erfahrung und √úberzeugung.\nWenn euch Statistik egal ist und ihr einfach nur bestehen wollt, dann reicht euch vielleicht SPSS. Wenn ihr langfristig gut mit Methodik und quantitativen Methoden arbeiten k√∂nnen wollt, dann ist R eine gute Investition."
  },
  {
    "objectID": "chapters/01-Was-ist-R.html#wieso-nicht-einfach-spss",
    "href": "chapters/01-Was-ist-R.html#wieso-nicht-einfach-spss",
    "title": "2¬† Was ist R",
    "section": "2.3 Wieso nicht einfach SPSS?",
    "text": "2.3 Wieso nicht einfach SPSS?\nSPSS ist viel.\nSPSS kann viel.\nSPSS kostet uns√§glich viel.\nSPSS nimmt euch das Denken ab ‚Äî im guten wie im schlechten Sinn.\nWenn ihr SPSS bedienen k√∂nnt, ihr wisst was ihr tut und entweder ihr oder eure ArbeitgeberIn tief in die Tasche gegriffen haben um eine Lizenz bereitzustellen, dann ist das sch√∂n und gut, und ihr k√∂nnt den Knopf mit ‚ÄúMach mal Statistik‚Äù dr√ºcken und dann kommen da PDFs raus wo Statistik drinsteht.\nSch√∂n.\nM√∂glicherweise habt ihr aber nicht die finanziellen Ressourcen f√ºr SPSS.\nM√∂glicherweise braucht ihr mehr Flexibilit√§t.\nVielleicht funktioniert SPSS f√ºr euch nur mittels einer Remotedesktop-Verbindung (*hust hust*), das hei√üt sobald ihr irgendwo ohne schnelle Verbindung seid, k√∂nnt ihr nicht mehr arbeiten.\nSo sicher wie der Tod und Steuern m√ºsst ihr auch irgendwann ein Expra durchf√ºhren, die erhobenen Daten auswerten und darstellen. Solltet ihr das mit SPSS machen, d√ºrft ihr keine der Grafiken oder Tabellen benutzen (au√üer ihr verzichtet freiwillig auf eine gute Note). Das gleiche gilt in schw√§cherer Gewichtung f√ºr euer Differentielle Projekt und nat√ºrlich ggf. in st√§rkerer Gewichtung f√ºr eure Bachelorarbeit.\nVielleicht gef√§llt euch aber auch nur, dass ihr mit R interaktiv und schnell1 einfache Dinge ausprobieren k√∂nnt."
  },
  {
    "objectID": "chapters/02-Installation.html",
    "href": "chapters/02-Installation.html",
    "title": "3¬† Installation",
    "section": "",
    "text": "Hier eine kurze Anleitung um R und RStudio zu installieren.\nKurz zum Kontext: R ist eine Programmiersprache, das hei√üt auch ‚ÄúR installieren‚Äù ist anders als ‚ÄúSpotify installieren‚Äù.\nIhr installiert zun√§chst R, und bekommt dann auf dem Desktop Verkn√ºpfungen angeboten f√ºr ‚ÄúR GUI‚Äù (o.√Ñ.) ‚Äî Dabei handelt es sich um ‚Äúnackte‚Äù Konsolenprogramme.\nDamit k√∂nntet ihr R benutzen, aber es macht beim besten Willen keinen Spa√ü.\nDeshalb installiert ihr RStudio ‚Äî Ein Programm (wie Spotify, nur ganz anders!), mit dem ihr R komfortabler benutzen k√∂nnt."
  },
  {
    "objectID": "chapters/02-Installation.html#r-installieren",
    "href": "chapters/02-Installation.html#r-installieren",
    "title": "3¬† Installation",
    "section": "3.1 R installieren",
    "text": "3.1 R installieren\nR bekommt ihr von der offiziellen seite, hier: https://cran.r-project.org/\n\n\n\n\n\nJa, die Seite sieht nach heutigen Standards furchtbar alt aus, aber die gibt‚Äôs nunmal auch schon ewig und sie hat den Anspruch m√∂glichst spartanisch zu sein um auch auf jedem noch so ranzigen Computer ordentlich dargstellt und ggf. von Scripten ausgelesen zu werden.\n\n3.1.1 Windows\nKlickt auf der oben genannte Seite auf Download R for Windows. Vollkommen unerwartet.\n\n\n\n\n\nHier ben√∂tigt ihr base (der R installer):\n\n\n\n\n\n‚Ä¶und sicherheitshalber auch Rtools (fragt nicht. Vorerst installiert ihr es einfach, nur f√ºr den Fall, das es euch sp√§ter Probleme erspart).\n\n\n\n\n\nDa ich akut keinen Windows-Computer zur Hand habe, gehe ich einfach davon aus, dass ihr das Prinzip ‚Äú.exe-Datei doppelklicken und alles brav mit ja oder OK best√§tigen‚Äù beherrscht. Schafft ihr bei Spotify ja auch.\nDas war die R-Installation!\nUnd jetzt installiert ihr RStudio\n\n\n3.1.2 Mac OS X (macOS)\nKlickt auf der oben genannte Seite auf Download R for (Mac) OS X. Auch das, vollkommen unerwartet.\n\n\n\n\n\n\nWenn euer Betriebssystem auf dem aktuellen Stand ist, benutzt die aktuelle Version des R-installers.\n\nWenn ihr aus unerfindlichen Gr√ºnden noch eine sehr alte OS X version laufen habt:\n\nM√∂ge die Deit√§t eurer Wahl euch beistehen\nAktualisiert euer Betriebssystem, oder wenn das nicht m√∂glich ist‚Ä¶\n‚Ä¶m√ºsst ihr vermutlich den Installer mit snowleopard im Namen benutzen\n\nWenn ihr nicht wisst, welche OS X Version ihr benutzt: Versucht‚Äôs erstmal mit dem aktuellen Installer, wenn das nicht funktioniert, versucht den √§lteren. Ansonsten: Googlet.\n\nAnsonsten braucht ihr nichts runterzuladen. Den Installer (die .pkg-Datei) einfach doppelklicken und alles brav bejahen.\nFertig.\n\n\n3.1.3 Linux\nWenn ihr Linux benutzt, solltet ihr unabh√§ngig von der Geschmacksrichtung auch wissen, wie man da Software installiert.\nEs gibt diese Info-Seite f√ºr Ubuntu: https://cloud.r-project.org/bin/linux/ubuntu/README.html.\nWenn ihr nicht wisst, was https://<my.favorite.cran.mirror>/bin/linux/ubuntu sein soll, dann setzt f√ºr <my.favorite.cran.mirror> am besten einfach cloud.r-project.org ein. Die Zeilen unter ‚ÄúInstallation‚Äù im verlinkten Dokument w√ºrden dann so aussehen (f√ºr Ubuntu 18.04 bionic):\n\ndeb https://cloud.r-project.org/bin/linux/ubuntu bionic/\n\nZus√§tzlich solltet ihr vermutlich einige Systempakete (also au√üerhalb R) installieren, f√ºr den Fall der F√§lle.\nF√ºr Ubuntu zum Beispiel (nur aus eigener Erfahrung, YMMV):\nsudo apt install libcurl4-openssl-dev curl git libxml2-dev libcairo2-dev\nDamit installiert ihr ein paar Pakete, die ihr f√ºr manche R-packages als dependencies ben√∂tigt.\nDie Liste ist nicht vollst√§ndig f√ºr alle m√∂glichen R packages, aber zumindest alle, die wir im Laufe dieser Intro benutzen oder benutzen k√∂nnten sollten damit abgedeckt sein."
  },
  {
    "objectID": "chapters/02-Installation.html#rstudio-install",
    "href": "chapters/02-Installation.html#rstudio-install",
    "title": "3¬† Installation",
    "section": "3.2 RStudio installieren",
    "text": "3.2 RStudio installieren\nRStudio bekommt ihr hier: https://www.rstudio.com/products/rstudio/download/#download\n\n\n\n\n\nHier dasselbe Spiel:\nInstallationsdatei f√ºr euer Betriebssystem runterladen und installieren traue ich euch zu.\nEntt√§uscht mich nicht.\nNach der Installation solltet ihr jedenfalls folgendes Symbol entweder auf eurem Desktop oder in eurem Programmordner finden:\n\n\n\n\n\nDas wollt ihr anklicken, dann sollte sich RStudio √∂ffnen und ihr habt erfolgreich R und RStudio installiert.\nGratuliere.\nFalls ihr Windows 10 benutzt und sich keine Desktopverkn√ºfung erstellt habt, wollt ihr eure Suchfunktion benutzen und ‚ÄúRStudio‚Äù suchen. Vollkommen unerwartet, ich wei√ü."
  },
  {
    "objectID": "chapters/02-Installation.html#rstudio-benutzen",
    "href": "chapters/02-Installation.html#rstudio-benutzen",
    "title": "3¬† Installation",
    "section": "3.3 RStudio benutzen",
    "text": "3.3 RStudio benutzen\nDas ist keine Anleitung, das ist eine Aufforderung.\nIhr benutzt ausschlie√ülich RStudio. Alle anderen Desktopverkn√ºpfungen die im Laufe der Installationen erschienen sein sollten k√∂nnt ihr getrost l√∂schen, die braucht ihr nicht.\nDazu geh√∂ren solche Dinge wie ‚ÄúR Console‚Äù oder auch ‚ÄúR GUI‚Äù oder √§hnliches. Das sind die Verkn√ºpfungen f√ºr das reine R, aber wir wollen R ja durch RStudio benutzen.\nTrust me, it‚Äôs better that way.\nIn RStudio k√∂nnt ihr jetzt vermutlich noch nicht viel machen, au√üer in der Konsole aus Spa√ü ‚Äúprint('Wurstwasser')‚Äù eingeben und Enter dr√ºcken."
  },
  {
    "objectID": "chapters/A01-Ressourcen.html",
    "href": "chapters/A01-Ressourcen.html",
    "title": "Appendix A ‚Äî Ressourcen",
    "section": "",
    "text": "Es gibt viele freie Quellen f√ºr sch√∂ne Datens√§tze zum √úben oder rumspielen, und einige packages bringen auch entsprechende Datens√§tze mit, die geeignet sind um bestimmte Funktionen auszuprobieren.\n\n\n\nG√§ngige Standarddatens√§tze:\n\nmtcars\nsleep\nattitude\n\npalmerpenguins::penguins: Pinguine!\ndplyr::starwars: Star Wars-stuff mit list-columns\nbabynames::babynames: Naja, baby names.\ntadaatoolbox::ngo: NGO-Datensatz aus QM (bzw. aus dem K√§hler)\n\n\n\n\n\ndata.world: Hier kommt z.B. der Game of Thrones deaths-Datensatz her\n\n\n\n\nHier liegen diverse Datens√§tze aus unseren Projekten, wie z.B. die QM-Surveys und die Tutorienteilnahme.\n\ndata.tadaa-data.de"
  },
  {
    "objectID": "chapters/A01-Ressourcen.html#b√ºcher",
    "href": "chapters/A01-Ressourcen.html#b√ºcher",
    "title": "Appendix A ‚Äî Ressourcen",
    "section": "A.2 B√ºcher",
    "text": "A.2 B√ºcher\n\n‚ÄúR for Data Science‚Äù ‚Äì Hadley Wickham\n‚ÄúAdvanced R‚Äù ‚Äì Hadley Wickham\nggplot2 ‚Äì Hadley Wickham\n‚ÄúTidyverse Cookbook‚Äù\n‚ÄúR Programming for Data Science‚Äù ‚Äì Roger Peng\n‚ÄúExploratory Data Analysis with R‚Äù ‚Äì Roger Peng\n‚ÄúTop 50 ggplot2 Visualizations‚Äù\n‚ÄúR Cookbook‚Äù\nMehr B√ºcher\n\n\nA.2.1 Kollaboration und Organisation\n\nA.2.1.1 Git & GitHub\n\nhappygitwithr.com ‚Äì Jenny Bryan\nohshitgit"
  },
  {
    "objectID": "chapters/A01-Ressourcen.html#kurse-workshops",
    "href": "chapters/A01-Ressourcen.html#kurse-workshops",
    "title": "Appendix A ‚Äî Ressourcen",
    "section": "A.3 Kurse & Workshops",
    "text": "A.3 Kurse & Workshops\n\nA.3.1 Kostenlose Tutorials/Videos\n\nRStudio Webinars\nStat545\nLOTR Data"
  },
  {
    "objectID": "chapters/A01-Ressourcen.html#blogs",
    "href": "chapters/A01-Ressourcen.html#blogs",
    "title": "Appendix A ‚Äî Ressourcen",
    "section": "A.4 Blogs",
    "text": "A.4 Blogs\n\nAggregator: R-Bloggers\n\nSiehe auch: Blogs in blogdown"
  },
  {
    "objectID": "chapters/A01-Ressourcen.html#community",
    "href": "chapters/A01-Ressourcen.html#community",
    "title": "Appendix A ‚Äî Ressourcen",
    "section": "A.5 Community",
    "text": "A.5 Community\n\nStackoverflow\nTwitter: #rstats"
  },
  {
    "objectID": "chapters/A01-Ressourcen.html#dokumentation",
    "href": "chapters/A01-Ressourcen.html#dokumentation",
    "title": "Appendix A ‚Äî Ressourcen",
    "section": "A.6 Dokumentation",
    "text": "A.6 Dokumentation\n\nR help (inoffizielle bookdown-Version)\nrdrr.io\nPackage-specific\n\ntidyverse.org"
  },
  {
    "objectID": "chapters/03-Orientierung.html",
    "href": "chapters/03-Orientierung.html",
    "title": "4¬† Orientierung",
    "section": "",
    "text": "Wenn ihr vorher noch nie eine Programmiersprache benutzt habt‚Ä¶ ist das auch eigentlich gar nicht so schlimm, denn R verh√§lt sich sowieso f√ºr den Einstieg etwas anders.\n‚ÄúProgrammiersprache‚Äù klingt so abschreckend, weil es nach kompliziertem Informatikkram klingt, aber wenn ihr es in eurer Schulzeit geschafft habt einen Taschenrechner zu bedienen, dann bekommt ihr auch den Einstieg in R hin.\nWas der Begriff ‚ÄúProgrammiersprache‚Äù f√ºr uns hei√üt ist recht simpel:\nR folgt Anweisungen. Anweisungen, die wir entweder in die Konsole (in RStudio das Fenster unten links) schreiben k√∂nnen, und dann mit der Entertaste best√§tigt werden. R guckt dann, ob es wei√ü wovon ihr redet, und r√∂delt dann los ‚Äî und wenn es wei√ü was es mit eurem Befehl anfangen soll, gibt es euch auch direkt eine Antwort.\nGute Praxis1 ist es √ºbrigens, ein Script zu erstellen, das Scriptfenster ist dann in RStudio oben links. Dort k√∂nnt ihr einen Befehl pro Zeile schreiben und als Datei abspeichern, so m√ºsst ihr euch bei eurer Arbeit nicht jeden Befehl einzeln merken, sondern k√∂nnt einfach das Script wieder neu ausf√ºhren und eure Ergebnisse tauchen alle wieder auf."
  },
  {
    "objectID": "chapters/03-Orientierung.html#rstudio",
    "href": "chapters/03-Orientierung.html#rstudio",
    "title": "4¬† Orientierung",
    "section": "4.1 RStudio",
    "text": "4.1 RStudio\nWenn ihr RStudio √∂ffnet, seht ihr vermutlich folgendes:\n\n\n\n\n\nEin frisches RStudio Fenster\n\n\n\n\nAuf der rechten Seite habr ihr unter dem Reiter ‚ÄúEnvironment‚Äù eine √úbersicht eurer Dateien und angelegten Variablen, sowie darunter mit der Hilfe und diversem anderem Krams, der uns zuerst noch nicht interessiert.\nDas gro√üe Fenster zur linken Seite ist die Konsole, mit der besch√§ftigen wir uns zuerst.\nBevor wir hier aber irgendwas machen, schaffen wir erstmal ein bisschen Struktur und erstellen ein neues Projekt.\nEin Projekt ist einfach nur ein bestimmter Ordner, in dem ihr arbeiten k√∂nnt. Idealerweise ist es auch ein Ordner, den ihr auf eurem Computer einfach wiederfindet.\n\n\n\n\n\nEin neues RStudio Projekt erstellen\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAm Ende solltet ihr euer erstes Projekt erstellt haben.\nHier k√∂nnt ihr jetzt den Rest der Einf√ºhrung √ºber bleiben und Scripte erstellen und sowieso und √ºberhaupt, und wenn ihr brav alles gespeichert habt, k√∂nnt ihr darauf auch in drei Wochen noch wieder zur√ºckgreifen, indem ihr einfach das Projekt aus der entsprechenden Leiste in RStudio ausw√§hlt.\n\n\n\n\n\nRStudio merkt sich eure letzten paar Projekte\n\n\n\n\nAlternativ k√∂nnt ihr auch auf eurem Computer den Ordner mit dem Projekt √∂ffnen2, dort dann einfach die Datei mit dem RStudio-Logo und der .Rproj-Endung √∂ffnen. Falls ihr Windows benutzt, werden die Dateiendungen per Standard nicht angezeigt - die Datei hat aber den gleichen Namen, den ihr auch dem Projekt gegeben habt und das Symbol sieht ungef√§hr so aus:\n\n\n\n\n\nEin RStudio Projektordner\n\n\n\n\nAls n√§chstes k√∂nnen wir uns Konsole und Text Editor widmen: Ihr k√∂nnt in der Regel immer nur in einem der beiden Bereiche schreiben, und erkennt den aktiven Bereich am blinkenden Cursor (ein bisschen wie in Textprogrammen √° la Word) ‚Äî Konsole und Editor sind die wichtigsten Bereiche in RStudio, und dort wird auch der Gro√üteil eurer Arbeit gemacht."
  },
  {
    "objectID": "chapters/03-Orientierung.html#konsole",
    "href": "chapters/03-Orientierung.html#konsole",
    "title": "4¬† Orientierung",
    "section": "4.2 Konsole",
    "text": "4.2 Konsole\nJetzt habt ihr ein frisches Projekt und k√∂nnt loslegen.\nAls erstes m√ºssen wir uns mit der Konsole (dem Teil unten links) vertraut machen.\nHier k√∂nnt ihr Frage-Antwort-m√§√üig Befehle eingeben, mit Enter best√§tigen, und erhaltet eine Antwort.\nHier kommt die Taschenrechner-Analogie wieder ‚Äî versucht mal folgendes:\n928 + 182\n\n\n\n\n\nOh Schreck, es funktioniert tats√§chlich!\n\n\n\n\nDie Mathe-Basics in R:\n\nAddition: +: 52 + 365 ‚Äì> 417\nSubtraktion: -: 2017 - 18 ‚Äì> 1999\nMultiplikation: *: 4*21 ‚Äì> 84\nDivision: /: 936/12 ‚Äì> 78\nExponentiation: ^: 2^10 ‚Äì> 1024\nKlammern: (, ): 3 * (12 - 8) + 2^(5/2)\n\nWie beim Taschenrechner: Lieber zwei mehr als n√∂tig als eine zu wenig\n‚Ä¶und ja, jede offene Klammer braucht eine geschlossen Klammer, sonst gibt‚Äôs Fehler\n\nDas Dezimaltrennzeichen ist der Punkt .: 12,1 wird eingegeben als 12.1\n\nAnsonsten gibt es etliche weitere mathematischen Funktionen, und wir k√∂nnen das ganze beliebig komplex aussehen lassen:\n2 + sin((2*pi)/3) * exp(5)\nHier sehen wir mehrere neue Dinge:\nErstens: pi ist wirklich, naja, \\(\\pi\\). Das mit dem Kreis. Als Konstante schon in R vorgespeichert, weil ja kein Mensch \\(\\pi\\) auf der Tastatur findet3.\nZweitens: sin() und exp() sind Funktionen. Die sind ziemlich wichtig, aber denen wenden wir uns erst im n√§chsten Abschnitt zu.\nWas wir da geschrieben haben sieht √ºbersetzt in Mathe √ºbrigens so aus‚Ä¶\n\\[2 + \\sin \\left( \\frac{2\\pi}{3} \\right) \\cdot e^{5}\\]\n‚Ä¶ und ergibt etwa 130,5. Aber darum geht‚Äôs eigentlich gar nicht.\n\n4.2.1 G√§ngige Probleme\nWas den meisten Leuten w√§hrend der R-Einf√ºhrung passiert ist, dass sie einen Befehl in die Konsole eingeben und Enter dr√ºcken, aber der Befehl nicht richtig abgeschlossen (korrekt terminiert) wurde. Das passiert zum Beispiel, wenn ihr eine schlie√üende Klammer vergesst, oder etwa ein + am Ende der Zeile habt. In diesen F√§llen dr√ºckt ihr Enter und R nimmt euren Befehl entgegen, aber es merkt, dass da irgendwas fehlt und wartet auf den Rest des Befehls.\nIhr erkennt das daran, dass das Symbol an der linken Seite eurer Konsole auf einmal ein +-Symbol statt eines > ist und auch wiederholtes Dr√ºcken der Entertaste nichts daran √§ndert.\n\n\n\n\n\nPlus was denn?!\n\n\n\n\nIhr habt an dieser Stelle zwei M√∂glichkeiten:\n\nDr√ºckt Escape (esc) um den Befehl abzubrechen und es nochmal zu versuchen\nF√ºhrt den Befehl korrekt zu Ende, sprich schlie√üt ggf. offene Klammern etc."
  },
  {
    "objectID": "chapters/03-Orientierung.html#text-editor",
    "href": "chapters/03-Orientierung.html#text-editor",
    "title": "4¬† Orientierung",
    "section": "4.3 Text Editor",
    "text": "4.3 Text Editor\nAlles was in der Konsole passiert ist sch√∂n und gut, aber es ist fl√ºchtig. Stellt es euch vor wie eine Timeline auf Twitter oder ein Snapchat‚Ä¶ Snapchat Dings oder was auch immer diese jungen Leute heutzutage benutzen.\nSobald ihr mehr als vier oder f√ºnf Befehle eingegeben habt, m√ºsst ihr hochscrollen, um eure alten Ergebnisse wieder zu finden. Das ist vollkommen okay um mal schnell etwas auszuprobieren, aber eher unpraktisch f√ºr eure Arbeit, die in der Regel sowas wie Reproduzierbarkeit erfordert.\nDazu gibt es Scripte. Scripte sind im Grunde nur Textdateien, in die ihr R-Befehle eingebt.\nSch√∂n brav einen Befehl pro Zeile, wie in der Konsole.\nScripte k√∂nnt ihr speichern und an andere Leute verschicken oder hochladen oder euch ausdrucken und an die Backe tackern ‚Äî der Kreativit√§t sind keine Grenzen gesetzt! Scripte schreibt und speichert ihr, um eure Befehle / Auswertung / Code sp√§ter wiederzufinden und nachvollziehen zu k√∂nnen. Ergebnisse reproduzieren k√∂nnt ihr indem ihr den Code aus dem Script nochmal ausf√ºhrt.\nUm euer erstes Script zu erstellen klickt ihr in RStudio oben links den Button, der nach ‚Äúneuer Datei‚Äù aussieht:\n\n\n\n\n\nLiebes Tagebuch: Heute habe ich einen Button geklickt. Es war sehr sch√∂n.\n\n\n\n\nDanach ploppt das Fenster oben links auf und begr√º√üt euch mit einem leeren Textfeld:\n\n\n\n\n\nNa, auch hier?\n\n\n\n\nIm Moment hei√üt euer Script noch Untitled1 ‚Äî das hei√üt, euer Script hat noch keinen Namen und ist noch nicht gespeichert. Letzteres wollt ihr umgehend √§ndern, weil all eure sch√∂nen Befehle f√ºr die Katz sind, wenn ihr euren Kram nicht speichert.\nIhr k√∂nnt zum speichern entweder den anachronistischen Diskettenbutton klicken und eurem Script einen sch√∂nen Namen geben, oder ihr dr√ºckt STRG + S oder auf dem Mac cmd + S ‚Äî der wohl wichtigste Keyboard-Shortcut der Welt. Wenn ihr Probleme habt eure Tasten zu finden oder zu benennen, dann guckt im Glossar oder googlet halt.\n\n\n\n\n\nDer ‚ÄúDatei speichern‚Ä¶‚Äù-Dialog\n\n\n\n\nGebt eurem Script einen aussagekr√§ftigen Namen. Ihr wollt ja auch in zwei Wochen noch wissen, was ihr da gemacht habt.\nAu√üerdem solltet ihr darauf achten, am besten ausschlie√ülich Zahlen und Buchstaben sowie - und _ zu verwenden. Leerzeichen und Umlaute (√§√∂√º) sind zwar in der Theorie kein Problem, aber glaubt mir, sobald ihr euer Script an KommilitonInnen mit anderen Betriebssystemen verschickt, kann auch jedes noch so harmlos aussehende √ú auf einmal zu einer Reihe von kleinen Problemen f√ºhren, deren Ursache ihr erst nach Stundenlanger Probiererei (oder niemals) finden w√ºrdet. Das ist im √ºbrigen kein R-Ding, sondern gilt auch f√ºr alles andere; Word- & Excel-Dateien, PDFs, Pornovideos‚Ä¶\nEtwas √§hnliches gilt auch f√ºr den Text in eurem Script:\nVermeidet nach M√∂glichkeit besondere Zeichen wie Emoji üòä (auch wenn die theoretisch korrekt angezeigt werden). Leerzeichen sind kein Problem, und sollten sogar der besseren Lesbarkeit halber gro√üz√ºgig eingesetzt werden.\nWas der Lesbarkeit auch sehr hilft: Kommentare.\nR ignoriert in Scripten sowie in der Konsole generell alles, was rechts neben einem # steht. Wir nennen dieses Zeichen √ºbrigens entweder Raute, Lattenzaun oder Octothorpe. Wer es hashtag nennt muss leider 5‚Ç¨ in die Millenial-Dose werfen.\nDamit k√∂nnen wir sowas machen:\n# Wie alt bin ich nochmal?\n2022 - 1991\n\n# Wie viele Stunden im Jahr?\n24 * 365\nDamit bekommen eure Befehle Kontext, und sowohl ihr als auch eure KommilitonInnen k√∂nnen leicht rausfinden, was zum Geier ihr euch da eigentlich gedacht habt.\nKommentare sind auch praktisch, wenn ihr ein l√§ngere Script ausf√ºhrt, aber ein Befehl Probleme bereitet. Wenn ihr einfach ein # davor setzt, ist die Zeile auskommentiert, und wird von R ignoriert.\nWenn ihr dann ein paar Zeilen Code angesammelt habt, k√∂nnt ihr euer Script ausf√ºhren.\nEin Script wird von oben nach unten (und von links nach rechts) ausgef√ºhrt, wenn ihr auf ‚ÄúSource‚Äù klickt oder Shift + STRG + Enter dr√ºckt (auf dem Mac Shift + cmd + Enter).\nWenn ihr nur die aktuelle Zeile (da wo euer Cursor gerade ist, ist ‚Äúaktuell‚Äù) ausf√ºhren wollt, reicht STRG + R (Mac: cmd + R). Auch hier kann das Glossar helfen."
  },
  {
    "objectID": "chapters/03-Orientierung.html#und-das-da-rechts",
    "href": "chapters/03-Orientierung.html#und-das-da-rechts",
    "title": "4¬† Orientierung",
    "section": "4.4 Und das da rechts?",
    "text": "4.4 Und das da rechts?\nAuf der rechten Seite in RStudio findet ihr unter Anderem die Hilfe (Help), die Dateien in eurem Projektordner (Files), eine √úbersicht der installierten packages (Packages), eine Variablen√ºbersicht (Environment) und von euch erstelle Graphiken (Plots). Wenn ihr das hier in der richtigen Reihenfolge lest, habt ihr vermutlich keine Ahnung was das alles hei√üen soll ‚Äî und genau deswegen wenden wir uns dem Ganzen auch Schritt wir Schritt in sp√§teren Abschnitten zu, wenn ihr ein bisschen mehr √úbersicht √ºber die Grundlagen habt."
  },
  {
    "objectID": "chapters/04-Erste-Schritte.html",
    "href": "chapters/04-Erste-Schritte.html",
    "title": "\n5¬† Erste Schritte\n",
    "section": "",
    "text": "Im letzten Abschnitt habt ihr R als glorifizierten Taschenrechner gesehen.\nAls n√§chstes schauen wir uns an, was wir sonst so damit anstellen k√∂nnen.\nZuerst ein bisschen Terminologie:\nOder in der Sprach-Analogie: Alles was in R existiert (Variablen, Tabellen, etc.) ist ein Nomen (Objekt) und alles, was etwas tut, ist ein Verb (Funktion)."
  },
  {
    "objectID": "chapters/04-Erste-Schritte.html#grundfunktionen",
    "href": "chapters/04-Erste-Schritte.html#grundfunktionen",
    "title": "\n5¬† Erste Schritte\n",
    "section": "\n5.1 Grundfunktionen",
    "text": "5.1 Grundfunktionen\nDie einfachsten Funktionen haben wir in Form der Rechenzeichen + - / * schon kennengelernt, aber es gibt nat√ºrlich noch mehr.\nEine Funktion in R hat sieht immer ungef√§hr so aus: sqrt(8). Der Name der Funktion, hier sqrt, (immer ohne Leerzeichen) gefolgt von Klammern, in denen ein oder mehrere Argumente stehen. Ein Argument ist das, womit die Funktion arbeiten soll. Eine g√§ngige Veranschaulichung f√ºr Funktionen sind Verben einer Sprache, denn sie tun etwas.\nEine der wichtigsten Grundfunktionen ist c(), f√ºr combine. Mit c verbindet ihr mehrere Zahlen zu einem Vektor (ja, wie in der linearen Algebra. Mathe und so. Wisstschon.). Wenn ihr mehrere Zahlen zu einem Vektor kombiniert habt, k√∂nnt ihr damit so spa√üige Dinge machen wie Mittelwerte ausrechen, sie aufsummieren oder zwei Vektoren gleicher L√§nge addieren.\nProbiert mal ein paar Beispiele aus:\n\nCode# Ein paar Zahlen\nc(1, 1, 2, 3, 5, 8, 13, 21)\n#> [1]  1  1  2  3  5  8 13 21\n\n# Was ist der Mittelwert der Zahlen?\nmean(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 6.75\n\n# Und die Summe?\nsum(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 54\n\n# Und wenn wir quadrieren?\nc(1, 1, 2, 3, 5, 8, 13, 21)^2\n#> [1]   1   1   4   9  25  64 169 441\n\n# Oder die Wurzel ziehen?\nsqrt(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 1.000000 1.000000 1.414214 1.732051 2.236068 2.828427 3.605551 4.582576\n\n\nWas wir hier sehen ist der Unterschied zwischen Funktionen, die aus mehreren Zahlen eine machen (mean, sum), und Funktionen, die auf jeder Zahl einzeln operieren (sqrt, ^).\nWas wir au√üerdem sehen: Jedes mal die Liste von Zahlen c(1, 1, 2, 3, 5, 8, 13, 21) kopieren und in eine Funktion einsetzen ist ziemlich unpraktisch. Stellt euch vor, ihr habt eine Reihe von Testergebnissen von hunderten ProbandInnen und m√ºsst da alles einzeln, also, nein, das w√§re ja albern.\nF√ºr sowas gibt es dann Abstraktionen wie Variablen und Datens√§tze, die entweder eine Liste von Werten oder auch eine Liste einer Liste von Werten handlich machen ‚Äî das sehen wir dann in den n√§chsten beiden Abschnitten.\nEine weitere praktische Funktion ist length(): Sie sagt uns, wie lang das Argument ist.\nWenn wir uns also angucken, wie der Mittelwert funktioniert‚Ä¶\n\\[\\bar{x} = \\frac{1}{n} \\sum^n_{i=1} x_i\\]\n‚Ä¶und wir das √ºbersetzen in ‚ÄúDie Summe aller Werte geteilt durch die Anzahl der Werte‚Äù, dann k√∂nnen wir statt mean also auch folgendes schreiben:\n\nCode# in lang\nsum(c(1, 1, 2, 3, 5, 8, 13, 21))/length(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 6.75\n\n# in kurz\nmean(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 6.75\n\n\nIhr seht vielleicht so langsam, wieso wir das mit den Klammern und den Leerzeichen f√ºr die Lesbarkeit erw√§hnt haben.\nAber gut, so langsam wird‚Äôs un√ºbersichtlich, es wird Zeit ein paar Variablen anzulegen.\n\n5.1.1 Funktionsbeispiele\nWenn ihr R lernt, werdet ihr erfahrungsgem√§√ü die meiste Zeit damit verbringen herauszufinden wie bestimmte Funktionen funktionieren und welche Funktion f√ºr euer Vorhaben die richtige ist.\nFunktionen sind zwar vom Schema immer gleich ‚Äî ihr steckt irgendwelche Argumente rein, und es kommt irgendein Ergebnis raus ‚Äî aber wie die Argumente aussehen unterscheidet sich von Funktion zu Funktion.sd() zum Beispiel hat zwei Argumente:\n\n\nx: Ein Vektor aus Zahlen, aus denen die Standardabweichung berechnet werden soll\n\nna.rm: F√ºr NA remove, entweder TRUE oder FALSE. Wenn x fehlende Werte (NA) enth√§lt, dann werden diese automatisch ignoriert, wenn na.rm = TRUE\n\n\n\nCodezahlen <- c(3, 6, 8, 3, 1, 2, 5, 6, 4, 3, NA, 4, 5, 7, NA, 1, 4)\n\n# Ergibt NA :(\nsd(zahlen)\n#> [1] NA\n\n# Ergibt ein Ergebnis :)\nsd(zahlen, na.rm = TRUE)\n#> [1] 2.065591\n\n\nDer default f√ºr na.rm ist bei den meisten Funktionen (z.B auch mean) FALSE, das hei√üt fehlende Werte werden nicht automatisch ignoriert. Wenn euer input aber NA enth√§lt, dann l√§sst sich daraus nicht sauber ein Mittelwert oder eine Standardabweichung berechnen, weil wir nichts √ºber NA wissen (wir widmen uns NA im Kapitel zu Datentypen).\nNicht jede Funktion hat ein Argument namens na.rm, aber ihr werdet im Laufe der Zeit lernen, bei welchen Funktionen ihr darauf achten m√ºsst, wie mit fehlenden Werten umgegangen wird.\nEinige andere Funktionen, die insbesondere zum Lernen und Ausprobieren praktisch sind, werden zur Erstellung von Sequenzen benutzt ‚Äî also Reihen von Zahlen in einem bestimmten Muster:\n\nCode# Die Zahlen von 1 bis 100\n1:100\n#>   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n#>  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n#>  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n#>  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n#>  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n#>  [91]  91  92  93  94  95  96  97  98  99 100\n\n# 10 bis 15 in 0.5er-Schritten\nseq(10, 15, 0.5)\n#>  [1] 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0\n\n# √Ñquivalent, mit explizit benannten Argumenten:\nseq(from = 10, to = 15, by = 0.5)\n#>  [1] 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0\n\n# Von 5 bis -5 in ganzen Schritten\nseq(5, -5)\n#>  [1]  5  4  3  2  1  0 -1 -2 -3 -4 -5\n\n# Sequenz von 1 mit L√§nge 5, dasselbe wie 1:5\nseq_len(5)\n#> [1] 1 2 3 4 5\nseq_len(length.out = 5)\n#> [1] 1 2 3 4 5\n\n\nDas : ist eine einfache Funktion und kann gelesen werden wie ‚ÄúVon ‚Ä¶ bis ‚Ä¶ in ganzen Schritten‚Äù. Zus√∂tzlich gibt es die Funktion seq(), die etwas flexibler ist. Au√üerdem gibt es diverse Funktionen f√ºr zufallsgenerierte Zahlen:\n\nCode# Normalverteilte Zufallszahlen (10 St√ºck, Mittelwert 5, Standardabweichung 2) \nrnorm(n = 10, mean = 5, sd = 2)\n#>  [1] 4.728914 5.596968 9.348978 2.405188 4.323383 7.174800 9.236142 3.084294\n#>  [9] 7.044620 4.997392\n\n# Gleichverteilte Zufallszahlen (sprich \"r unif\", nicht \"run if\")\nrunif(n = 10)\n#>  [1] 0.006253856 0.206609888 0.123650394 0.829648214 0.447253925 0.719047463\n#>  [7] 0.730167684 0.497380002 0.734657794 0.675635529\n\n# M√ºnzwurf (Binomialverteilte Ergebnisse), 10 St√ºck\nrbinom(n = 10, size = 1, prob = 0.5)\n#>  [1] 0 0 0 0 0 0 1 0 1 1\n\n# W√ºrfel (W6) (10 St√ºck)\nsample(x = 1:6, size = 10, replace = TRUE)\n#>  [1] 3 5 1 6 2 4 6 2 5 5"
  },
  {
    "objectID": "chapters/04-Erste-Schritte.html#variablen",
    "href": "chapters/04-Erste-Schritte.html#variablen",
    "title": "\n5¬† Erste Schritte\n",
    "section": "\n5.2 Variablen",
    "text": "5.2 Variablen\nWenn Funktionen wie Verben sind, dann sind Variablen wie Nomen. Sie haben einen Namen, und mit ihnen kann man Dinge tun. Oder sogar Sachen machen.\nVariablen werden durch eine Zuweisung (Assignment) erstellt, was in R traditionell via <- passiert.\nIn den meisten anderen Programmiersprachen benutzt man daf√ºr =, aber nun ja, R ist historisch gewachsen1, also nehmt f√ºr den Anfang einfach mal hin, dass das nunmal so ist.\nWir speichern also mal ein paar Dinge:\n\nCode# Speichern in \"fib\"\nfib <- c(1, 1, 2, 3, 5, 8, 13, 21) \n\n# Ausgeben lassen\nfib\n#> [1]  1  1  2  3  5  8 13 21\n\n# Mittelwert‚Ä¶\nmean(fib)\n#> [1] 6.75\n\n# ‚Ä¶funktioniert immer noch. Angenehm.\n# Und wenn wir‚Ä¶\nfib + fib\n#> [1]  2  2  4  6 10 16 26 42\n\n# Abgefahrener Kram.\n\n\nHier haben wir die Zahlen 1, 1, 2, 3, 5, 8, 13, 21 in die Variable fib gespeichert, weil es die ersten paar Fibonacci-Zahlen sind, und wir unsere Variablen immer so benennen sollten, dass wir sp√§ter noch wissen wof√ºr sie da sind. Viele Tutorials beginnen damit, Variablen wie x, y und z anzulegen, aber da blickt ja irgendwann kein Mensch mehr durch.\nWenn ihr jetzt mit euren Zahlen arbeiten wollt, k√∂nnt ihr einfach in jeder Funktion fib statt der Liste mit c(‚Ä¶) einsetzen, und alles funktioniert wie vorher. Das liegt daran, dass R bei jedem Befehl erstmal nachschaut, ob ihr eine Variable benutzt (alles was Text ohne Anf√ºhrungszeichen ist), und ob es die Variable findet. Wenn es die Variable gefunden hat, guckt es nach, was da drinsteht, in diesem Fall also c(1, 1, 2, 3, 5, 8, 13, 21), dann benutzt R den Inhalt der Variablen.\nAn dieser Stelle bietet es sich an, einen neuen Typ einzuf√ºhren: Den String (oder auch character). Als String bezeichnet man im Kontext von, naja, Computerkram generell eigentlich, alles was als Text durchgeht. Sobald wir etwas nicht mehr nur durch Zahlen darstellen k√∂nnen, ist es ein String.\nStrings stehen in R immer in Anf√ºhrungszeichen, entweder in \"doppelten\" oder in 'einfachen'.\nWichtig dabei ist, dass sich Anf√ºhrungszeichen √§hnlich verhalten wie Klammern. Wenn wir einen String mit ‚Äú beginnen, m√ºssen wir ihn auch wieder mit ‚Äù schlie√üen, ansonsten wartet R brav darauf, dass endlich das zweite ‚Äú kommt und verl√§uft sich.\nEin Beispiel:\n\nCode# Vollkommen okay\nnamen <- c(\"Tobi\", \"Lukas\", \"Nadja\", \"Christoph\")\n\n# Auch okay, aber inkonsistent und daher eher unsch√∂n\nnamen <- c('Tobi', \"Lukas\", 'Nadja', \"Christoph\")\n\n# Tod und Verderben (=> funktioniert nicht)\nnamen <- c(\"Tobi\", 'Lukas\", 'Nadja, Christop\")\n\n\nWir k√∂nnen auch Zahlen in \"\" setzen ‚Äî das ist kein Problem, aber dann sind es nunmal keine Zahlen in diesem Sinne mehr, es sind Strings, und mit Strings k√∂nnen wir nicht rechnen.\nProbiert folgendes aus:\n\nCode# Okay\n5 + 5\n\n# H√§?\n5 + \"5\"\n\n\nIhr sehr jetzt vermutlich die Meldung Error in 5 + \"5\" : non-numeric argument to binary operator.\nDas non-numeric argument hier ist die \"5\". Merken: 5 ist numerisch, aber \"5\" ist ein character (=> String).\nDer binary operator an dieser Stelle ist √ºbrigens das +. Ein Operator, weil es, √§h‚Ä¶ operiert? Naja, es tut Dinge, und wenn etwas in R Dinge tut, ist es meistens ein Operator in irgendeinem Sinne. Das binary hei√üt, dass es zwei (bi, bin√§r, binary, zwei halt) Argumente nimmt.\nWie schon gesagt, Argumente sind die Dinge, die wir an Funktionen √ºbergeben, und wenn wir an eine Funktion wie + oder auch mean() ein Argument √ºbergeben, mit denen sie nichts anfangen k√∂nnen, dann beschwert sich R weil es nicht wei√ü was zum Geier ihr da vorhabt.\n\nCodenamen <- c(\"Tobi\", \"Lukas\", \"Nadja\", \"Christoph\")\n\nfib <- c(1, 1, 2, 3, 5, 8, 13, 21) \n\n# Alles knorke\nmean(fib)\n#> [1] 6.75\n\n# Alles CHAOS UND UNHEIL\nmean(namen)\n#> Warning in mean.default(namen): argument is not numeric or logical:\n#> returning NA\n#> [1] NA\n\n\nWas es mit NA auf sich hat, und was es noch so f√ºr Datentypen gibt, sehen wir dann im Abschnitt zu [Datentypen].\nEine letzte Sache noch: Strings sind ‚Äúdominanter‚Äù als Zahlen, das hei√üt, wir k√∂nnen zwar Zahlen verbinden zu c(1, 2, 3), und Strings zu c(\"A\", \"B\", \"C\"), aber wenn wir c(\"A\", 2, \"C\", 4) schreiben, dann behandelt R einfach alle Elemente des Vektors (=> Das, was in c(‚Ä¶)) steht, als w√§ren es character-Werte.\n\n\n\nMerke: Ein Vektor in R muss immer Elemente des gleichen Typs haben, Zahlen und Buchstaben zusammen werden zu Strings konvertiert!"
  },
  {
    "objectID": "chapters/04-Erste-Schritte.html#tabellen",
    "href": "chapters/04-Erste-Schritte.html#tabellen",
    "title": "\n5¬† Erste Schritte\n",
    "section": "\n5.3 Tabellen",
    "text": "5.3 Tabellen\nJetzt haben wir schonmal das Vokuabular an der Hand um Zahlen und beliebige Strings in R zu verarbeiten, aber noch ist das alles etwas unahndlich um damit richtig zu arbeiten.\nStellt euch vor, wir wollen einen kleinen Datensatz erstellen √ºber die Statistiktutorien in QM mit Variablen wie Namen, Alter, und vielleicht sowas wie Beliebtheit auf einer Skala von 1-10.\nWir k√∂nnten sowas machen:\n\nCodenamen <- c(\"Tobi\", \"Christoph\", \"Nadja\", \"Lukas\")\nalter <- c(20, 35, 30, 12) # (Nicht alle diese Werte sind korrekt)\n\nmean(alter)\n#> [1] 24.25\n\n\nSch√∂n und gut, aber das ist ja unhandlich. Was, wenn wir die Namen aller TutorInnen haben wollen, die j√ºnger als 30 sind? Alles was wir mit alter machen, passiert unabh√§ngig von namen.\nUm mehrere Variablen in Kontext zu setzen, gibt es tabellarischen Datenstrukturen, namentlich nennt sich sowas in R dann data.frame. Letztendlich ist das nichts anderes als eine Tabelle, aber f√ºr R ist eine Tabelle praktische eine Liste von Vektoren mit gleicher l√§nge:\n\nCodeleute <- data.frame(name = c(\"Tobi\", \"Christoph\", \"Nadja\", \"Lukas\"),\n                    alter = c(20, 35, 30, 12),\n                    beliebtheit = c(9, 10, 8, 3))\n\n# Anzeigen lassen\nleute\n#>        name alter beliebtheit\n#> 1      Tobi    20           9\n#> 2 Christoph    35          10\n#> 3     Nadja    30           8\n#> 4     Lukas    12           3\n\n\nWas haben wir da gemacht?\n\nWir haben einen data.frame mit der gleichnamigen Funktion erstellt\nDie Argumente der Funktion haben die Form Spaltenname = Werte der Spalte\n\nMehrere Argumente werden mit , getrennt und optional mit einem Zeilenumbruch √ºbersichtlich gehalten\n\nDas Ergebnis ist eine Variable leute, die drei Spalten mit je vier Werten hat.\nJede Spalte ist eine Variable, und jede Zeile der Tabelle kann als eine Beobachtung betrachtet werden.\nEine Beobachtung (Observation) sind alle Werte, die wir zu einem Untersuchungsobjekt haben, also in diesem Beispiel eine Person. Wenn wir uns nur die erste Zeile anschauen, sehen wir nur die Werte, die zu Tobi geh√∂ren, in der zweiten Zeile sehen wir die Werte zu Christoph etc.\nTabellen, und damit data.frames, sind f√ºr uns die wichtigsten Objekte in R, weil wir fast ausschlie√ülich mit Datens√§tzen in dieser Form arbeiten werden um unsere Statistik da draufzuwerfen.\nWie k√∂nnen wir jetzt mit einzelnen Variablen arbeiten?\n\nCode# Die Variable \"name\" ausgeben lassen\nleute$name\n#> [1] \"Tobi\"      \"Christoph\" \"Nadja\"     \"Lukas\"\n\n# Den Mittelwert von \"alter\" bestimmen\nmean(leute$alter)\n#> [1] 24.25\n\n# Die Standardabweichung von \"beliebtheit\"\nsd(leute$beliebtheit)\n#> [1] 3.109126\n\n# Was auch funktioniert:\nleute[[\"name\"]]\n#> [1] \"Tobi\"      \"Christoph\" \"Nadja\"     \"Lukas\"\nleute[[\"alter\"]]\n#> [1] 20 35 30 12\n\n\nDas mit den ‚ÄúLevels‚Äù wird im Abschnitt zu [Datentypen] erkl√§rt\nWas wir hier benutzen nennt sich Subsetting, also im Grunde nur einen Teil von etwas rausholen. Hier also einen Teil der Tabelle on Form einer einzelnen Spalte.\nSpalten k√∂nnen wir mit $ oder [[ ]] direkt aus einem data.frame ansteuern, was unser Leben gleich viel einfacher macht. Strenggenommen sidn $ und [[ auch eigene Funktionen, aber dazu vielleicht sp√§ter mehr, im Moment ist f√ºr uns nur wichtig, dass wir einzelne Spalten (Variablen) einer Tabelle (data.frame) einfach adressieren und genauso behandeln k√∂nnen wie die einzelnen Variablen name und alter, die wir weiter oben erstellt haben."
  },
  {
    "objectID": "chapters/04-Erste-Schritte.html#umgang-mit-datens√§tzen",
    "href": "chapters/04-Erste-Schritte.html#umgang-mit-datens√§tzen",
    "title": "\n5¬† Erste Schritte\n",
    "section": "\n5.4 Umgang mit Datens√§tzen",
    "text": "5.4 Umgang mit Datens√§tzen\nDa wir noch nicht an dem Punkt sind, wo wir beliebige Daten einlesen k√∂nnen, und wir nat√ºrlich zu faul sind uns eine gr√∂√üere Tabelle selber zu schreiben, greifen wir zu √úbungszwecken mal auf einen Datensatz zur√ºck, der bei R von Haus aus mitgeliefert wird: sleep.\nDieser Datensatz beinhaltet die Daten aus einer Medikamentenstudie, bei der es um Schlafgewinn bzw. -verlust ging. Die Tabelle hat drei Spalten (Variablen) zu 10 Personen:\n\n\nextra: Schlafzuwachs in Stunden, positiv oder negativ f√ºr mehr bzw. weniger Schlaf als vorher\n\ngroup: Die Versuchsgruppe, sprich welches Medikament die Person bekam, 1 oder 2\n\n\nID: Die Identifikationsnummer der Person. Es ist g√§ngig, ProbandInnen pseudonymisiert durchzunummerieren, der Zuordnung unt des Datenschutzes wegen als Zahlen.\n\n\nCode# Mit head() lassen wir uns die ersten paar Zeilen (den \"Kopf\") der Tabelle anzeigen\nhead(sleep)\n#>   extra group ID\n#> 1   0.7     1  1\n#> 2  -1.6     1  2\n#> 3  -0.2     1  3\n#> 4  -1.2     1  4\n#> 5  -0.1     1  5\n#> 6   3.4     1  6\n\n\nWie viele Zeilen hat die Tabelle?\n\nCodenrow(sleep)\n#> [1] 20\n\n\nDie number of rows bekommen wir mit nrow() ‚Äî ihr d√ºrft jetzt raten, wie wir uns die Anzahl der Spalten (columns) anzeigen lassen k√∂nnen.\n\nCodencol(sleep)\n#> [1] 3\n\n\nSurprise!\nOkay, aber was interessiert uns an diesem Datensatz jetzt? Wie w√§re es mit dem durchschnittlichen Schlafzuwachs:\n\nCodemean(sleep$extra)\n#> [1] 1.54\n\n\nSch√∂n und gut, aber wir wollen ja vermutlich die beiden Gruppen (Medikamente) vergleichen, also was tun?\nSubsetting to the rescue /o/\n\nCodegruppe1 <- sleep[sleep$group == 1, ]\ngruppe2 <- sleep[sleep$group == 2, ]\n\n# Mittelwert der ersten Gruppe\nmean(gruppe1$extra)\n#> [1] 0.75\n\n# Mittelwert der zweiten Gruppe\nmean(gruppe2$extra)\n#> [1] 2.33\n\n\nOkay, Schritt f√ºr Schritt.\nHier haben wir unseren ersten logischen vergleich benutzt, um eine Teilmenge der Tabelle zu extrahieren.\nDas klingt fancy, ist aber ziemlich simpel.\nIn Worten hei√üt die Zeile gruppe1 <- sleep[sleep$group == 1] lediglich:\n‚ÄúNimm die Tabelle sleep und filtere daraus alle Zeilen, die zu der Gruppe 1 geh√∂ren, und speichere sie in die Variable gruppe1‚Äù Das Resultat sind zwei Variablen, die einen Teil der Tabelle sleep enthalten, und zwar jeweils zu einer der beiden Gruppen.\nWieso dann eigentlich noch diese ,-Sache am Ende der eckigen Klammern?\nDas geh√∂rt zur Art, wie R Tabellen indiziert, sprich wie man einzelne Bereiche der Tabelle ansteuert:\n\nCode# Die erste Spalte\nsleep[1]\n#>    extra\n#> 1    0.7\n#> 2   -1.6\n#> 3   -0.2\n#> 4   -1.2\n#> 5   -0.1\n#> 6    3.4\n#> 7    3.7\n#> 8    0.8\n#> 9    0.0\n#> 10   2.0\n#> 11   1.9\n#> 12   0.8\n#> 13   1.1\n#> 14   0.1\n#> 15  -0.1\n#> 16   4.4\n#> 17   5.5\n#> 18   1.6\n#> 19   4.6\n#> 20   3.4\n\n# Die erste Zeile\nsleep[1, ]\n#>   extra group ID\n#> 1   0.7     1  1\n\n# Die erste Zeile und die dritte Spalte\nsleep[1, 3]\n#> [1] 1\n#> Levels: 1 2 3 4 5 6 7 8 9 10\n\n\nDie allgemeine Form ist tabelle[Zeilennummer, Spaltennumer], und jetzt fragt ihr euch vermutlich, wieso wir vorhin [[ ]] benutzt haben, und jetzt [ ] ‚Äî die kurze Antwort ist: Das ist halt was anderes. Die Details sind erstmal nicht so wichtig, was ihr euch vorerst merken solltet ist folgendes:\n\n\nsleep[1] ergibt einen data.frame mit nur einer Spalte\n\n\nsleep[1, ] ergibt einen data.frame mit nur einer Zeile\n\n\nsleep[[1]] und sleep$extra sind dasselbe (weil extra die erste Spalte ist) und ergeben die erste Spalte als Vektor\n\n\nsleep$extra[[2]] und sleep$extra[2] sind hier dasselbe: Das zweite Element im Vektor sleep$extra\n\n\nBei einer Tabelle ist es n√ºtzlich mit Zeilen und Spalten zu arbeiten, um die gew√ºnschten Werte rauszuholen, aber bei einem Vektor gibt es in diesem Sinne nur eine Dimension.\nSinn der Sache ist, dass wir Funktionen wie mean oder sd nur auf Vektoren anwenden k√∂nnen, was auch intuitiv irgendwie sinnvoll scheint, denn der Mittelwert einer ganzen Tabelle mit mehreren Variablen ist ja konzeptionell etwas‚Ä¶ schwierig.\n# Okay\nmean(sleep$extra)\n#> [1] 1.54\n\n# Das selbe Ergebnis\nmean(sleep[[1]])\n#> [1] 1.54\n\n# Auch okay!\nmean(sleep[[\"extra\"]])\n#> [1] 1.54\n\n# Das hier nicht so\nmean(sleep[1])\n#> Warning in mean.default(sleep[1]): argument is not numeric or logical:\n#> returning NA\n#> [1] NA\nsleep[1] gibt euch zwar auch die Spalte extra, aber wie schon gesagt, in data.frame-Form, und nicht als Vektor.\nVermutlich verwirrt euch das ganze Geklammere jetzt mehr oder weniger stark, aber glaubt mir, wenn wir erstmal ein Gef√ºhl daf√ºr habt ist es sehr viel Wert diese Grundlagen auf dem Schirm zu haben (oder sie zumindest nachlesen zu k√∂nnen), denn in der ersten Zeit eurer R-Nutzung werdet ihr massenhaft kleinere und gr√∂√üere Fehler in dieser Art machen, wo ihr zwar das richtige meint, aber R nicht das richtige sagt.\nDie andere Sache ist, dass ihr das mit den eckigen Klammern gar nicht so h√§ufig brauchen werdet, wenn ihr euch erstmal an das tidyverse und dplyr gew√∂hnt habt, aber dazu sp√§ter mehr.\nWir schneiden das Ganze Thema Subsetting hier auch erstmal nur an, aber wenn ihr‚Äôs jetzt schon ganz genau wissen wollt, k√∂nnt ihr die Details hier nachlesen"
  },
  {
    "objectID": "chapters/04-Erste-Schritte.html#logische-vergleiche",
    "href": "chapters/04-Erste-Schritte.html#logische-vergleiche",
    "title": "\n5¬† Erste Schritte\n",
    "section": "\n5.5 Logische Vergleiche",
    "text": "5.5 Logische Vergleiche\nLogik! Eine Welt des Spa√ües, der internen Konsistenz[^Naja, fast. Aber G√∂del lassen wir mal aus.] und der unendlichen Anwendbarkeit in allen Bereichen.\nWas ihr intuitiv als Logik kennt ist alleridngs etwas anderes als formale Logik, also das, was Computer verstehen.\nWir brauchen zum Gl√ºck nicht all zu viel davon, nur den Standardkram und nichtmal das volle Spekrum Bool‚Äôscher Algebra.\nWir brauchen Logik in R in erster Linie zum indizieren von Objekten. Das hei√üt, wenn wir alle Zeilen einer Tabelle haben wollen, f√ºr die eine bestimmte Variable einen bestimmten Wert hat oder eine Bedingung erf√ºllt, dann dr√ºcken wir das durch Logik aus. Dasselbe funktioniert nat√ºrlich auch bei Vektoren (und strenggenommen funktioniert Tabellenindizierung sowieso √ºber Vektorindizierung). Man nehme folgendes Beispiel:\n\nCodesleep[sleep$extra > 3, ]\n#>    extra group ID\n#> 6    3.4     1  6\n#> 7    3.7     1  7\n#> 16   4.4     2  6\n#> 17   5.5     2  7\n#> 19   4.6     2  9\n#> 20   3.4     2 10\n\n\nDas hei√üt: ‚ÄúNimm die Tabelle sleep und gib mir alle Zeilen (das mit den eckigen Klammen), f√ºr die die Variable sleep$extra gr√∂√üer als 3 ist‚Äù.\nDas Ergebnis eines logischen Vergleichs ist immer entweder TRUE oder FALSE f√ºr wahr oder falsch.\nWenn wir in R indizieren wollen, k√∂nnen wir daf√ºr auch direkt TRUE und FALSE statt eines Vergleichs benutzen:\n\nCodefib <- c(1, 1, 2, 3, 5, 8, 13, 21) \n\nfib[c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)]\n#> [1] 1 1\n\n\nHier haben wir uns effektiv nur die ersten beiden Werte des Vektors fib ausgeben lassen, weil R alles ausgibt, was mit TRUE indiziert ist und alles wegl√§sst, was mit FALSE indiziert ist.c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE) ist hier ein logischer Vektor, also ein Vektor mit, naja, logischen Werten, der praktisch der Reihe nach jedes Element im Vektor fib entweder an oder aus schaltet, wie Lichtschalter. Wir m√ºssen daf√ºr nicht unbedingt einen logischen Vektor der gleichen L√§nge (Anzahl der Elemente) wie unser Zielvektor (der, den wir indizieren/filtern wollen) benutzen, aber es bietet sich f√ºr den Einstieg an so genau wie m√∂glich zu sein.\nWir k√∂nnten aber auch sowas machen:\n\nCode# Immer abwechselnd TRUE und FALSE, also jedes zweite Element\nfib[c(TRUE, FALSE)]\n#> [1]  1  2  5 13\n\n# Schema TRUE TRUE FALSE FALSE ginge auch\nfib[c(TRUE, TRUE, FALSE, FALSE)]\n#> [1] 1 1 5 8\n\n\nWichtig hierbei ist, dass der logische Vektor ein ganzer Faktor des Zielvektors ist, das hei√üt, dass die Anzahl der Element im Zielvektor ganz durch die Anzahl der Elemente im logischen Vektor teilbar sein muss (also ohne Rest), ansonsten bekommen wir potenziell schwer vorhersagbare Ergebnisse.\nWas R hier macht nennt sich Recycling: In der ersten Zeile im letzten Beispiel wird der Vektor c(TRUE, FALSE) solange recyclet, also wiederverwendet, bis der ganze Zeilvektor ‚Äúabgedeckt‚Äù ist. Wenn der logische Vektor nicht sauber in den Zielvektor passt (in Bezug auf die Anzahl der Elemente), dann bleibt entweder was √ºbrig oder es reicht nicht. Das w√§re schade.\n\n5.5.1 Operatoren\nEs gibt eine Reihe logischer Operatoren wie hier > f√ºr ‚Äúist gr√∂√üer als‚Äù, die wichtigsten in √úbersicht:\n\n\n== (doppeltes Gleichheitszeichen ohne Leerzeichen dazwischen)\n\n‚ÄúIst gleich‚Äù\n\n1 == 2 ‚Äì> FALSE\n\n\n3 == 3 ‚Äì> TRUE\n\n\n3 == \"Hallo\" ‚Äì> FALSE\n\n\n\n\n!=\n\n‚Äúist ungleich‚Äù\nDie Negation von ==, also immer da wo == euch TRUE zeigt, gibt != euch FALSE und andersherum.\n\npi != 3 ‚Äì> TRUE\n\n\"Psychologiestudium\" != \"Voll gute Idee\"\n\n\n\n! (ja, ein einfaches Ausrufezeichen)\n\n‚ÄúNegation‚Äù\nDreht ein FALSE zu einem TRUE um und andersherum. Wichtig: Klammern!\n!(2 == 3)\nTRUE == !FALSE\n\n\n\n> und < (spitze Klammern)\n\n‚Äúist gr√∂√üer/kleiner als‚Äù\nDa wo die Klamer spitz ist, soll das kleinere sein\n\n5 > 4 ‚Äì> TRUE\n\n\n2^10 < 1000 ‚Äì> FALSE\n\n\n2 < 5 < 4 ‚Äì> Funktioniert nicht!\n\n\n\n\n>=, <=\n\n‚ÄúGr√∂√üer gleich bzw. kleiner gleich‚Äù\nIst Entweder a > b oder a == b?\n5 >= 4\n16 <= 2^4\n\n\n\nDiese Ausdr√ºcke k√∂nnen wir auch auf bestimmte Arten verkn√ºpfen:\n\n\n& (oder auch &&)\n\n‚ÄúUnd‚Äù\nIst TRUE, wenn beide Seiten TRUE sind\n\n(1 < 3) & (5 < 10) ‚Äì> TRUE\n\n\n(5 < 2) & (2 < 10) ‚Äì> FALSE\n\n1 und 0 werden zu TRUE bzw. FALSE √ºbersetzt:\n\n\n1 & (2 == 2) ‚Äì> TRUE\n\n\n!(0 & FALSE) ‚Äì> TRUE\n\n\n\n\n\n\n| (oder auch ||)\n\n‚ÄúOder‚Äù\nIst entweder A oder B oder beides TRUE?\nDa | auch wahr ist, wenn nur eine Seite wahr ist, ist es auch Grundlage etlicher Mathe-/Logikwitze\n\n(1 < 3) | (5 < 10) ‚Äì> TRUE\n\n\n(5 < 2) | (2 < 10) ‚Äì> TRUE\n\n\n\n\nxor()\n\n‚ÄúEntweder ‚Ä¶ oder ‚Ä¶‚Äù (ausschlie√üend!)\nWenn euch | zu unspezifisch ist\nIst nur war, wenn eins von beidem wahr ist, aber nicht, wenn beides wahr ist\n\nKein bin√§rer Operator wie die anderen, sondern eine R-Funktion mit Klammern und so\n\nxor(TRUE, FALSE) ‚Äì> TRUE\n\n\nxor(TRUE, TRUE) ‚Äì> FALSE\n\n\nxor((1 < 3), (5 < 10)) ‚Äì> FALSE\n\n\nxor((5 < 2), (2 < 10)) ‚Äì> TRUE\n\n\n\n\n5.5.2 Spezielle Tests\nDie obigen Operatoren k√∂nnen wir f√ºr getrost f√ºr Vektorvergleiche benutzen, aber es gibt noch ein paar Sonderf√§lle. Was zum Beispiel, wenn wir nur generell wissen wollen, ob ein Element wie eine Zahl oder ein String in einem Vektor enthalten ist? Oder was, wenn wir wir auf spezielle Typen oder Klassen testen wollen? Was das im Detail hei√üt sehen wir in den entsprechenden Abschnitten zu [Datentypen] noch einmal, aber hier schonmal eine Kurzreferenz:\n\n\n%in% (auch hier, ohne Leerzeichen dazwischen!)\n\n‚ÄúIst in‚Äù\nMengentheoretisch ist das \\(x \\in X\\)\n\nIst Element a in Menge b?\n\n5 %in% c(1, 4, 5, 3) ‚Äì> TRUE\n\n\n\"B\" %in% c(\"a\", \"b\", \"c\") ‚Äì> FALSE\n\n\n\"B\" %in% c(\"a\", \"B\", \"c\") ‚Äì> TRUE\n\n\nc(1, 2) %in% 1:5 ‚Äì> TRUE\n\n\n\n\nis.na(): Testet auf fehlende Werte (missing values, NA)\n\nis.null(): Testet auf leere Werte (NULL)\n\nis.nan(): Testet auf NaN (Not a Number)\n\n5.5.3 Indexing: Beispiele\nDas war jetzt relativ viel Information, und ihr m√ºsst euch das auch nicht alles sofort merken, sondern nur wissen, wo ihr‚Äôs bei Bedarf nachschlagen k√∂nnt.\nDie Motivation hinter dem Logikram ist wie erw√§hnt prim√§r das Filtern von Tabellen und Vektoren, was wir nunmal relativ h√§ufig brauchen um zum Beispiel bestimmte Untergruppen in unseren Datens√§tze zu analysieren, zum Beispiel Personen √§lter als 35 (z.B. age > 35) oder Menschen, die sowohl weiblich sind als auch Medikament B bekommen haben (z.B. geschlecht == \"weiblich\" & drug == \"B\").\n\n5.5.3.1 Vektoren\nVektoren werden immer elementweise verglichen, das hei√üt, dass das Ergebnis von c(1, 2) == 1 nicht FALSE oder TRUE ist, sondern der logische Vektor TRUE FALSE. Dadurch entsteht durch den logischen Vergleich eines Vektors ein Vektor aus TRUE und FALSE, den wir zum indizieren benutzen k√∂nnen, wie wir weiter oben schon gesehen haben.\n\nCode# Irgendwelche Zahlen\nx <- c(4, 7, 2, 1, 7, 9, 6, 5, 4, 3, 3, 2, 2, 5, 8, 9, 31)\n\n# Alle Zahlen gr√∂√üer 4: \"Gib mir x, wo x > 4\"\nx[x > 4]\n#> [1]  7  7  9  6  5  5  8  9 31\n\n# Die Logik dahinter\nx > 4\n#>  [1] FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n#> [13] FALSE  TRUE  TRUE  TRUE  TRUE\n\n# Alle Zahlen gr√∂√üer 5 und kleiner 20\nx[x > 5 & x < 20]\n#> [1] 7 7 9 6 8 9\n\n\nDas Ganze l√§sst sich nat√ºrlich beliebig komplex aussehen lassen, weshalb zu viele Bedingungen in Kombination etwas verwirrend aussehen k√∂nnen.\nWeiterhin k√∂nnen wir einen Vektor nat√ºrlich auch durch einen Vergleich eines anderen Vektors indizieren.\n\nCodex <- c(4, 7, 2, 1, 7, 9, 6, 5, 4, 3)\ny <- c(6, 7, 10, 1, 9, 3, 6, 5, 6, 3)\n\n# x, wo x gr√∂√üer gleich 4 ist *und* y kleiner 6\nx[x >= 4 & (y < 6)]\n#> [1] 9 5\n\n# x, wo x und y identisch sind\nx[x == y]\n#> [1] 7 1 6 5 3\n\n# x, wo x kleiner y ist\nx[x < y]\n#> [1] 4 2 7 4\n\n\n\n5.5.3.2 Tabellen data.frame\n\nTabellenindexing ist nichts anderes als Vektorindexing mit einer anderen Struktur. Alle Regeln zum Vektorindexing, die wir bisher gesehen haben, gelten auch so f√ºr data.frames, nur dass wir hier jetzt auf einmal in Spalten und Zeilen denken m√ºssen, anstatt in Vektoren."
  }
]