[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R für Psychos",
    "section": "",
    "text": "time is a flat circle↩︎\nzumindest dieses eine Mal in 2018↩︎\nAllen voran ggplot2, das package für plots in R.↩︎"
  },
  {
    "objectID": "chapters/01-was-ist-r.html",
    "href": "chapters/01-was-ist-r.html",
    "title": "2  Was ist R",
    "section": "",
    "text": "R ist eine Programmiersprache, und ja, das klingt abschreckend.\nFür uns heißt das in erster Linie Folgendes:"
  },
  {
    "objectID": "chapters/01-was-ist-r.html#was-ist-an-r-so-toll",
    "href": "chapters/01-was-ist-r.html#was-ist-an-r-so-toll",
    "title": "2  Was ist R",
    "section": "2.1 Was ist an R so toll?",
    "text": "2.1 Was ist an R so toll?\nNicht alles an R ist toll — und sobald ihr das erste Mal mehrere Stunden damit verbracht habt, ein vergleichsweise einfaches Problem lösen zu wollen, werdet ihr wissen was ich meine.\nDie am häufigsten zitierten Vorteile sind in etwa die Folgenden:\n\nKostenlos\n\nKeine Lizenzgebühren\nKeine Update-Gebühren\n\nOpen Source\n\nSoftware-Sprech für “jeder kann sich die Innereien angucken”\nJeder kann R beliebig erweitern und modifizieren\n“Was genau macht R an Stelle XYZ” ist immer beantwortbar, weil der Quelltext offen verfügbar ist\n\nErweiterbarkeit\n\nEs gibt unzählige Erweiterungen (“packages”) für R, die neue Funktionen bereitstellen\nÜbersicht auf z.B. r-pkg.org\nSogar eure TutorInnen können packages schreiben. Tun sie sogar manchmal.\n\nGute Dokumentation (meistens)\n\nR bringt seine Hilfe selber mit, das ist der “Help”-Tab in RStudio. Jede Funktion ist dokumentiert!\nSeiten wie rdocumentation.org oder rdrr.io erlauben es so gut wie alle verfügbaren R packages nach bestimmten Funktionen zu durchsuchen, egal wie obskur der Anwendungsfall auch sein mag\nCommunities wie stackoverflow sind beliebte “Ich brauche Hilfe bei XY”-Anlaufstellen, und eine Horde von Menschen, die meistens das gleiche Problem auch schonmal hatten, können euch helfen\n\nInteraktivität: Wo SPSS auf Buttons und Befehle reagiert und dann einen Stapel PDFs produziert, kann R mit der Konsole auch einfach schnell und interaktiv benutzt werden: “Schnell mal eben was nachgucken” ist in R deutlich angenehmer als in SPSS, zumindest für einfache Sachen.\nReproduzierbarkeit: Wenn ihr ein sauberes R-Script geschrieben habt, könnt ihr das frei verfügbar machen und alle Interessierten können es bei sich selbst ausführen und BÄM!, Ergebnisse reproduziert. In case you didn’t realize, but that’s kind of a big thing in science.\nVisualisierung: R hat fantastische Werkzeuge zur Datenvisualisierung, primär sei hier ggplot2 erwähnt, was euch erlaubt wunderschöne Grafiken aus euren Daten zu zaubern, und auch das vollkommen reproduzierbar (versucht das mal mit SPSS oder Excel. Worlds of pain.)\nFlexibilität: R ist eine Programmiersprache, das heißt per default kann R erstmal alles. Vielleicht nicht alles gut, aber prinzipiell lässt sich zumindest theoretisch alles damit anstellen. Dieses Dokument hier? In R (RMarkdown, bookdown) geschrieben. Dynamische Webseiten? Auch möglich, googlet “R shiny”. Interaktive Elemente? Auch kein Ding, googlet “R htmlwidgets”. Daten aus Software wie SPSS, Excel oder sogar Google Sheets importieren? Auch kein Problem. You get the idea.\nAktive Entwicklung & Community: R wird immer besser. Immer mehr Leute benutzen R, von diesen Leuten haben einige gute Ideen, und davon wiederum gibt es einige, die diese sogar umsetzen. Das Resultat ist ein stetig wachsendes und gedeihendes Ökosystem um R und eine aktive Community auf diversen Netzwerken, die sowohl Hilfestellung liefern können als auch aktiv an besseren Tools rund um R arbeiten, von besserer Dokumentation bis zu besserer Integration mit anderer Software."
  },
  {
    "objectID": "chapters/01-was-ist-r.html#was-ist-r-nicht",
    "href": "chapters/01-was-ist-r.html#was-ist-r-nicht",
    "title": "2  Was ist R",
    "section": "2.2 Was ist R nicht?",
    "text": "2.2 Was ist R nicht?\nR ist nicht wie SPSS. R “nackt” ist ein Kommandozeilenprogramm. Terminal/Konsole, wie man es auch nennen mag, aber es ist nicht wie die Programme, die ihr im Alltag benutzt. Es gibt keine Knöpfe zum drücken und alles ist Text, ohne Formatierungskram wie fett oder kursiv, weil die Grundlagen bzw. Vorstufen von R aus einer Zeit kommen, in der Computer noch anders waren und die Mauer noch frisch war.\nWeil das wenig benutzerfreundlich bzw. einsteigerfreundlich ist, gibt es Programme wie RStudio, was sozusagen auf R sitzt und es benutzbar macht. Wenn R ein Pferd ist, ist RStudio ein Sattel.\nDas heißt für euch aber auch, dass ihr eine Datenanalyse nicht durch bloßes Knöpfchendrücken zusammenstecken könnt wie das bei SPSS möglich ist — ihr müsst Befehle lernen, eure Daten(struktur) verstehen, und euch sicher sein, was ihr tun wollt.\nIch weiß, dass das alles wirklich eher krampfig klingt wenn ihr das so lest, weshalb es auch häufig vorkommt, dass Studierende in den ersten Semestern R eher ignorieren und sich lieber mit SPSS beschäftigen, weil das weniger kognitiver Aufwand ist — aber glaubt mir wenn ich euch sage, dass “R lernen” eine gute Investition ist. SPSS könnt ihr euch immer noch irgendwie beibringen oder Youtube-Tutorials gucken oder Befehlslisten ausdrucken und sowieso und überhaupt, R hingegen ist entsprechend komplexer, also nutzt die Zeit in der euch TutorInnen noch helfen können, bevor ihr dann vor eurem Expra-Datensatz sitzt, mit SPSS nicht weiter kommt und wie der Ochs vor’m Berg an R sitzt.\nIch betone das übrigens nicht, weil ich SPSS doof finde (was ich tue), oder R so toll finde (was ich tue), sondern tatsächlich aus Erfahrung und Überzeugung.\nWenn euch Statistik egal ist und ihr einfach nur bestehen wollt, dann reicht euch vielleicht SPSS. Wenn ihr langfristig gut mit Methodik und quantitativen Methoden arbeiten können wollt, dann ist R eine gute Investition."
  },
  {
    "objectID": "chapters/01-was-ist-r.html#wieso-nicht-einfach-spss",
    "href": "chapters/01-was-ist-r.html#wieso-nicht-einfach-spss",
    "title": "2  Was ist R",
    "section": "2.3 Wieso nicht einfach SPSS?",
    "text": "2.3 Wieso nicht einfach SPSS?\nSPSS ist viel.\nSPSS kann viel.\nSPSS kostet unsäglich viel.\nSPSS nimmt euch das Denken ab — im guten wie im schlechten Sinn.\nWenn ihr SPSS bedienen könnt, ihr wisst was ihr tut und entweder ihr oder eure ArbeitgeberIn tief in die Tasche gegriffen haben um eine Lizenz bereitzustellen, dann ist das schön und gut, und ihr könnt den Knopf mit “Mach mal Statistik” drücken und dann kommen da PDFs raus wo Statistik drinsteht.\nSchön.\nMöglicherweise habt ihr aber nicht die finanziellen Ressourcen für SPSS.\nMöglicherweise braucht ihr mehr Flexibilität.\nVielleicht funktioniert SPSS für euch nur mittels einer Remotedesktop-Verbindung (*hust hust*), das heißt sobald ihr irgendwo ohne schnelle Verbindung seid, könnt ihr nicht mehr arbeiten.\nSo sicher wie der Tod und Steuern müsst ihr auch irgendwann ein Expra durchführen, die erhobenen Daten auswerten und darstellen. Solltet ihr das mit SPSS machen, dürft ihr keine der Grafiken oder Tabellen benutzen (außer ihr verzichtet freiwillig auf eine gute Note). Das gleiche gilt in schwächerer Gewichtung für euer Differentielle Projekt und natürlich ggf. in stärkerer Gewichtung für eure Bachelorarbeit.\nVielleicht gefällt euch aber auch nur, dass ihr mit R interaktiv und schnell1 einfache Dinge ausprobieren könnt."
  },
  {
    "objectID": "chapters/02-installation.html",
    "href": "chapters/02-installation.html",
    "title": "\n3  Installation\n",
    "section": "",
    "text": "Hier eine kurze Anleitung um R und RStudio zu installieren.\nKurz zum Kontext: R ist eine Programmiersprache, das heißt auch “R installieren” ist anders als “Spotify installieren”.\nIhr installiert zunächst R, und bekommt dann auf dem Desktop Verknüpfungen angeboten für “R GUI” (o.Ä.) — Dabei handelt es sich um “nackte” Konsolenprogramme.\nDamit könntet ihr R benutzen, aber es macht beim besten Willen keinen Spaß.Deshalb installiert ihr RStudio — Ein Programm (wie Spotify, nur ganz anders!), mit dem ihr R komfortabler benutzen könnt."
  },
  {
    "objectID": "chapters/02-installation.html#r-installieren",
    "href": "chapters/02-installation.html#r-installieren",
    "title": "\n3  Installation\n",
    "section": "\n3.1 R installieren",
    "text": "3.1 R installieren\nR bekommt ihr von der offiziellen seite, hier: https://cran.r-project.org/\n\n\n\n\n\nJa, die Seite sieht nach heutigen Standards furchtbar alt aus, aber die gibt’s nunmal auch schon ewig und sie hat den Anspruch möglichst spartanisch zu sein um auch auf jedem noch so ranzigen Computer ordentlich dargstellt und ggf. von Scripten ausgelesen zu werden.\n\n3.1.1 Windows\nKlickt auf der oben genannte Seite auf Download R for Windows. Vollkommen unerwartet.\n\n\n\n\n\nHier benötigt ihr base (der R installer):\n\n\n\n\n\n…und sicherheitshalber auch Rtools (fragt nicht. Vorerst installiert ihr es einfach, nur für den Fall, das es euch später Probleme erspart).\n\n\n\n\n\nDa ich akut keinen Windows-Computer zur Hand habe, gehe ich einfach davon aus, dass ihr das Prinzip “.exe-Datei doppelklicken und alles brav mit ja oder OK bestätigen” beherrscht. Schafft ihr bei Spotify ja auch.\nDas war die R-Installation!\nUnd jetzt installiert ihr RStudio\n\n3.1.2 Mac OS X (macOS)\nKlickt auf der oben genannte Seite auf Download R for (Mac) OS X. Auch das, vollkommen unerwartet.\n\n\n\n\n\n\nWenn euer Betriebssystem auf dem aktuellen Stand ist, benutzt die aktuelle Version des R-installers.\n\nWenn ihr aus unerfindlichen Gründen noch eine sehr alte OS X version laufen habt:\n\nMöge die Deität eurer Wahl euch beistehen\nAktualisiert euer Betriebssystem, oder wenn das nicht möglich ist…\n…müsst ihr vermutlich den Installer mit snowleopard im Namen benutzen\n\n\nWenn ihr nicht wisst, welche OS X Version ihr benutzt: Versucht’s erstmal mit dem aktuellen Installer, wenn das nicht funktioniert, versucht den älteren. Ansonsten: Googlet.\n\nAnsonsten braucht ihr nichts runterzuladen. Den Installer (die .pkg-Datei) einfach doppelklicken und alles brav bejahen.\nFertig.\n\n3.1.3 Linux\nWenn ihr Linux benutzt, solltet ihr unabhängig von der Geschmacksrichtung auch wissen, wie man da Software installiert.\nEs gibt diese Info-Seite für Ubuntu: https://cloud.r-project.org/bin/linux/ubuntu/README.html.\nWenn ihr nicht wisst, was https://<my.favorite.cran.mirror>/bin/linux/ubuntu sein soll, dann setzt für <my.favorite.cran.mirror> am besten einfach cloud.r-project.org ein. Die Zeilen unter “Installation” im verlinkten Dokument würden dann so aussehen (für Ubuntu 18.04 bionic):\n\ndeb https://cloud.r-project.org/bin/linux/ubuntu bionic/\n\nZusätzlich solltet ihr vermutlich einige Systempakete (also außerhalb R) installieren, für den Fall der Fälle.\nFür Ubuntu zum Beispiel (nur aus eigener Erfahrung, YMMV):\nsudo apt install libcurl4-openssl-dev curl git libxml2-dev libcairo2-dev\nDamit installiert ihr ein paar Pakete, die ihr für manche R-packages als dependencies benötigt.\nDie Liste ist nicht vollständig für alle möglichen R packages, aber zumindest alle, die wir im Laufe dieser Intro benutzen oder benutzen könnten sollten damit abgedeckt sein."
  },
  {
    "objectID": "chapters/02-installation.html#rstudio-install",
    "href": "chapters/02-installation.html#rstudio-install",
    "title": "\n3  Installation\n",
    "section": "\n3.2 RStudio installieren",
    "text": "3.2 RStudio installieren\nRStudio bekommt ihr hier: https://www.rstudio.com/products/rstudio/download/#download\n\n\n\n\n\nHier dasselbe Spiel:\nInstallationsdatei für euer Betriebssystem runterladen und installieren traue ich euch zu.\nEnttäuscht mich nicht.\nNach der Installation solltet ihr jedenfalls folgendes Symbol entweder auf eurem Desktop oder in eurem Programmordner finden:\n\n\n\n\n\nDas wollt ihr anklicken, dann sollte sich RStudio öffnen und ihr habt erfolgreich R und RStudio installiert.\nGratuliere.\nFalls ihr Windows 10 benutzt und sich keine Desktopverknüfung erstellt habt, wollt ihr eure Suchfunktion benutzen und “RStudio” suchen. Vollkommen unerwartet, ich weiß."
  },
  {
    "objectID": "chapters/02-installation.html#rstudio-benutzen",
    "href": "chapters/02-installation.html#rstudio-benutzen",
    "title": "\n3  Installation\n",
    "section": "\n3.3 RStudio benutzen",
    "text": "3.3 RStudio benutzen\nDas ist keine Anleitung, das ist eine Aufforderung.\nIhr benutzt ausschließlich RStudio. Alle anderen Desktopverknüpfungen die im Laufe der Installationen erschienen sein sollten könnt ihr getrost löschen, die braucht ihr nicht.\nDazu gehören solche Dinge wie “R Console” oder auch “R GUI” oder ähnliches. Das sind die Verknüpfungen für das reine R, aber wir wollen R ja durch RStudio benutzen.\nTrust me, it’s better that way.\nIn RStudio könnt ihr jetzt vermutlich noch nicht viel machen, außer in der Konsole aus Spaß “print('Wurstwasser')” eingeben und Enter drücken."
  },
  {
    "objectID": "chapters/03-orientierung.html",
    "href": "chapters/03-orientierung.html",
    "title": "\n4  Orientierung\n",
    "section": "",
    "text": "Wenn ihr vorher noch nie eine Programmiersprache benutzt habt… ist das auch eigentlich gar nicht so schlimm, denn R verhält sich sowieso für den Einstieg etwas anders.\n“Programmiersprache” klingt so abschreckend, weil es nach kompliziertem Informatikkram klingt, aber wenn ihr es in eurer Schulzeit geschafft habt einen Taschenrechner zu bedienen, dann bekommt ihr auch den Einstieg in R hin.\nWas der Begriff “Programmiersprache” für uns heißt ist recht simpel:\nR folgt Anweisungen. Anweisungen, die wir entweder in die Konsole (in RStudio das Fenster unten links) schreiben können, und dann mit der Entertaste bestätigt werden. R guckt dann, ob es weiß wovon ihr redet, und rödelt dann los — und wenn es weiß was es mit eurem Befehl anfangen soll, gibt es euch auch direkt eine Antwort.\nGute Praxis1 ist es übrigens, ein Script zu erstellen, das Scriptfenster ist dann in RStudio oben links. Dort könnt ihr einen Befehl pro Zeile schreiben und als Datei abspeichern, so müsst ihr euch bei eurer Arbeit nicht jeden Befehl einzeln merken, sondern könnt einfach das Script wieder neu ausführen und eure Ergebnisse tauchen alle wieder auf."
  },
  {
    "objectID": "chapters/03-orientierung.html#rstudio",
    "href": "chapters/03-orientierung.html#rstudio",
    "title": "\n4  Orientierung\n",
    "section": "\n4.1 RStudio",
    "text": "4.1 RStudio\nWenn ihr RStudio öffnet, seht ihr vermutlich folgendes:\n\n\n\n\nEin frisches RStudio Fenster\n\n\n\n\nAuf der rechten Seite habr ihr unter dem Reiter “Environment” eine Übersicht eurer Dateien und angelegten Variablen, sowie darunter mit der Hilfe und diversem anderem Krams, der uns zuerst noch nicht interessiert.\nDas große Fenster zur linken Seite ist die Konsole, mit der beschäftigen wir uns zuerst.\nBevor wir hier aber irgendwas machen, schaffen wir erstmal ein bisschen Struktur und erstellen ein neues Projekt.\nEin Projekt ist einfach nur ein bestimmter Ordner, in dem ihr arbeiten könnt. Idealerweise ist es auch ein Ordner, den ihr auf eurem Computer einfach wiederfindet.\n\n\n\n\nEin neues RStudio Projekt erstellen\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAm Ende solltet ihr euer erstes Projekt erstellt haben.\nHier könnt ihr jetzt den Rest der Einführung über bleiben und Scripte erstellen und sowieso und überhaupt, und wenn ihr brav alles gespeichert habt, könnt ihr darauf auch in drei Wochen noch wieder zurückgreifen, indem ihr einfach das Projekt aus der entsprechenden Leiste in RStudio auswählt.\n\n\n\n\nRStudio merkt sich eure letzten paar Projekte\n\n\n\n\nAlternativ könnt ihr auch auf eurem Computer den Ordner mit dem Projekt öffnen2, dort dann einfach die Datei mit dem RStudio-Logo und der .Rproj-Endung öffnen. Falls ihr Windows benutzt, werden die Dateiendungen per Standard nicht angezeigt - die Datei hat aber den gleichen Namen, den ihr auch dem Projekt gegeben habt und das Symbol sieht ungefähr so aus:\n\n\n\n\nEin RStudio Projektordner\n\n\n\n\nAls nächstes können wir uns Konsole und Text Editor widmen: Ihr könnt in der Regel immer nur in einem der beiden Bereiche schreiben, und erkennt den aktiven Bereich am blinkenden Cursor (ein bisschen wie in Textprogrammen á la Word) — Konsole und Editor sind die wichtigsten Bereiche in RStudio, und dort wird auch der Großteil eurer Arbeit gemacht."
  },
  {
    "objectID": "chapters/03-orientierung.html#konsole",
    "href": "chapters/03-orientierung.html#konsole",
    "title": "\n4  Orientierung\n",
    "section": "\n4.2 Konsole",
    "text": "4.2 Konsole\nJetzt habt ihr ein frisches Projekt und könnt loslegen.\nAls erstes müssen wir uns mit der Konsole (dem Teil unten links) vertraut machen.\nHier könnt ihr Frage-Antwort-mäßig Befehle eingeben, mit Enter bestätigen, und erhaltet eine Antwort.\nHier kommt die Taschenrechner-Analogie wieder — versucht mal folgendes:\n928 + 182\n\n\n\n\nOh Schreck, es funktioniert tatsächlich!\n\n\n\n\nDie Mathe-Basics in R:\n\nAddition: +: 52 + 365 –> 417\nSubtraktion: -: 2017 - 18 –> 1999\nMultiplikation: *: 4*21 –> 84\nDivision: /: 936/12 –> 78\nExponentiation: ^: 2^10 –> 1024\nKlammern: (, ): 3 * (12 - 8) + 2^(5/2)\n\nWie beim Taschenrechner: Lieber zwei mehr als nötig als eine zu wenig\n…und ja, jede offene Klammer braucht eine geschlossen Klammer, sonst gibt’s Fehler\n\n\nDas Dezimaltrennzeichen ist der Punkt .: 12,1 wird eingegeben als 12.1\n\n\nAnsonsten gibt es etliche weitere mathematischen Funktionen, und wir können das ganze beliebig komplex aussehen lassen:\n2 + sin((2*pi)/3) * exp(5)\nHier sehen wir mehrere neue Dinge:\nErstens: pi ist wirklich, naja, \\(\\pi\\). Das mit dem Kreis. Als Konstante schon in R vorgespeichert, weil ja kein Mensch \\(\\pi\\) auf der Tastatur findet3.\nZweitens: sin() und exp() sind Funktionen. Die sind ziemlich wichtig, aber denen wenden wir uns erst im nächsten Abschnitt zu.\nWas wir da geschrieben haben sieht übersetzt in Mathe übrigens so aus…\n\\[2 + \\sin \\left( \\frac{2\\pi}{3} \\right) \\cdot e^{5}\\]\n… und ergibt etwa 130,5. Aber darum geht’s eigentlich gar nicht.\n\n4.2.1 Gängige Probleme\nWas den meisten Leuten während der R-Einführung passiert ist, dass sie einen Befehl in die Konsole eingeben und Enter drücken, aber der Befehl nicht richtig abgeschlossen (korrekt terminiert) wurde. Das passiert zum Beispiel, wenn ihr eine schließende Klammer vergesst, oder etwa ein + am Ende der Zeile habt. In diesen Fällen drückt ihr Enter und R nimmt euren Befehl entgegen, aber es merkt, dass da irgendwas fehlt und wartet auf den Rest des Befehls.\nIhr erkennt das daran, dass das Symbol an der linken Seite eurer Konsole auf einmal ein +-Symbol statt eines > ist und auch wiederholtes Drücken der Entertaste nichts daran ändert.\n\n\n\n\nPlus was denn?!\n\n\n\n\nIhr habt an dieser Stelle zwei Möglichkeiten:\n\nDrückt Escape (esc) um den Befehl abzubrechen und es nochmal zu versuchen\nFührt den Befehl korrekt zu Ende, sprich schließt ggf. offene Klammern etc."
  },
  {
    "objectID": "chapters/03-orientierung.html#text-editor",
    "href": "chapters/03-orientierung.html#text-editor",
    "title": "\n4  Orientierung\n",
    "section": "\n4.3 Text Editor",
    "text": "4.3 Text Editor\nAlles was in der Konsole passiert ist schön und gut, aber es ist flüchtig. Stellt es euch vor wie eine Timeline auf Twitter oder ein Snapchat… Snapchat Dings oder was auch immer diese jungen Leute heutzutage benutzen.\nSobald ihr mehr als vier oder fünf Befehle eingegeben habt, müsst ihr hochscrollen, um eure alten Ergebnisse wieder zu finden. Das ist vollkommen okay um mal schnell etwas auszuprobieren, aber eher unpraktisch für eure Arbeit, die in der Regel sowas wie Reproduzierbarkeit erfordert.\nDazu gibt es Scripte. Scripte sind im Grunde nur Textdateien, in die ihr R-Befehle eingebt.\nSchön brav einen Befehl pro Zeile, wie in der Konsole.\nScripte könnt ihr speichern und an andere Leute verschicken oder hochladen oder euch ausdrucken und an die Backe tackern — der Kreativität sind keine Grenzen gesetzt! Scripte schreibt und speichert ihr, um eure Befehle / Auswertung / Code später wiederzufinden und nachvollziehen zu können. Ergebnisse reproduzieren könnt ihr indem ihr den Code aus dem Script nochmal ausführt.\nUm euer erstes Script zu erstellen klickt ihr in RStudio oben links den Button, der nach “neuer Datei” aussieht:\n\n\n\n\nLiebes Tagebuch: Heute habe ich einen Button geklickt. Es war sehr schön.\n\n\n\n\nDanach ploppt das Fenster oben links auf und begrüßt euch mit einem leeren Textfeld:\n\n\n\n\nNa, auch hier?\n\n\n\n\nIm Moment heißt euer Script noch Untitled1 — das heißt, euer Script hat noch keinen Namen und ist noch nicht gespeichert. Letzteres wollt ihr umgehend ändern, weil all eure schönen Befehle für die Katz sind, wenn ihr euren Kram nicht speichert.\nIhr könnt zum speichern entweder den anachronistischen Diskettenbutton klicken und eurem Script einen schönen Namen geben, oder ihr drückt STRG + S oder auf dem Mac cmd + S — der wohl wichtigste Keyboard-Shortcut der Welt. Wenn ihr Probleme habt eure Tasten zu finden oder zu benennen, dann guckt im Glossar oder googlet halt.\n\n\n\n\nDer “Datei speichern…”-Dialog\n\n\n\n\nGebt eurem Script einen aussagekräftigen Namen. Ihr wollt ja auch in zwei Wochen noch wissen, was ihr da gemacht habt.\nAußerdem solltet ihr darauf achten, am besten ausschließlich Zahlen und Buchstaben sowie - und _ zu verwenden. Leerzeichen und Umlaute (äöü) sind zwar in der Theorie kein Problem, aber glaubt mir, sobald ihr euer Script an KommilitonInnen mit anderen Betriebssystemen verschickt, kann auch jedes noch so harmlos aussehende Ü auf einmal zu einer Reihe von kleinen Problemen führen, deren Ursache ihr erst nach Stundenlanger Probiererei (oder niemals) finden würdet. Das ist im übrigen kein R-Ding, sondern gilt auch für alles andere; Word- & Excel-Dateien, PDFs, Pornovideos…\nEtwas ähnliches gilt auch für den Text in eurem Script:\nVermeidet nach Möglichkeit besondere Zeichen wie Emoji 😊 (auch wenn die theoretisch korrekt angezeigt werden). Leerzeichen sind kein Problem, und sollten sogar der besseren Lesbarkeit halber großzügig eingesetzt werden.\nWas der Lesbarkeit auch sehr hilft: Kommentare.\nR ignoriert in Scripten sowie in der Konsole generell alles, was rechts neben einem # steht. Wir nennen dieses Zeichen übrigens entweder Raute, Lattenzaun oder Octothorpe. Wer es hashtag nennt muss leider 5€ in die Millenial-Dose werfen.\nDamit können wir sowas machen:\n# Wie alt bin ich nochmal?\n2022 - 1991\n\n# Wie viele Stunden im Jahr?\n24 * 365\nDamit bekommen eure Befehle Kontext, und sowohl ihr als auch eure KommilitonInnen können leicht rausfinden, was zum Geier ihr euch da eigentlich gedacht habt.\nKommentare sind auch praktisch, wenn ihr ein längere Script ausführt, aber ein Befehl Probleme bereitet. Wenn ihr einfach ein # davor setzt, ist die Zeile auskommentiert, und wird von R ignoriert.\nWenn ihr dann ein paar Zeilen Code angesammelt habt, könnt ihr euer Script ausführen.\nEin Script wird von oben nach unten (und von links nach rechts) ausgeführt, wenn ihr auf “Source” klickt oder Shift + STRG + Enter drückt (auf dem Mac Shift + cmd + Enter).\nWenn ihr nur die aktuelle Zeile (da wo euer Cursor gerade ist, ist “aktuell”) ausführen wollt, reicht STRG + R (Mac: cmd + R). Auch hier kann das Glossar helfen."
  },
  {
    "objectID": "chapters/03-orientierung.html#und-das-da-rechts",
    "href": "chapters/03-orientierung.html#und-das-da-rechts",
    "title": "\n4  Orientierung\n",
    "section": "\n4.4 Und das da rechts?",
    "text": "4.4 Und das da rechts?\nAuf der rechten Seite in RStudio findet ihr unter Anderem die Hilfe (Help), die Dateien in eurem Projektordner (Files), eine Übersicht der installierten packages (Packages), eine Variablenübersicht (Environment) und von euch erstelle Graphiken (Plots). Wenn ihr das hier in der richtigen Reihenfolge lest, habt ihr vermutlich keine Ahnung was das alles heißen soll — und genau deswegen wenden wir uns dem Ganzen auch Schritt wir Schritt in späteren Abschnitten zu, wenn ihr ein bisschen mehr Übersicht über die Grundlagen habt."
  },
  {
    "objectID": "chapters/04-erste-schritte.html",
    "href": "chapters/04-erste-schritte.html",
    "title": "\n5  Erste Schritte\n",
    "section": "",
    "text": "Im letzten Abschnitt habt ihr R als glorifizierten Taschenrechner gesehen.\nAls nächstes schauen wir uns an, was wir sonst so damit anstellen können.\nZuerst ein bisschen Terminologie:\nOder in der Sprach-Analogie: Alles was in R existiert (Variablen, Tabellen, etc.) ist ein Nomen (Objekt) und alles, was etwas tut, ist ein Verb (Funktion)."
  },
  {
    "objectID": "chapters/04-erste-schritte.html#grundfunktionen",
    "href": "chapters/04-erste-schritte.html#grundfunktionen",
    "title": "\n5  Erste Schritte\n",
    "section": "\n5.1 Grundfunktionen",
    "text": "5.1 Grundfunktionen\nDie einfachsten Funktionen haben wir in Form der Rechenzeichen + - / * schon kennengelernt, aber es gibt natürlich noch mehr.\nEine Funktion in R hat sieht immer ungefähr so aus: sqrt(8). Der Name der Funktion, hier sqrt, (immer ohne Leerzeichen) gefolgt von Klammern, in denen ein oder mehrere Argumente stehen. Ein Argument ist das, womit die Funktion arbeiten soll. Eine gängige Veranschaulichung für Funktionen sind Verben einer Sprache, denn sie tun etwas.\nEine der wichtigsten Grundfunktionen ist c(), für combine. Mit c verbindet ihr mehrere Zahlen zu einem Vektor (ja, wie in der linearen Algebra. Mathe und so. Wisstschon.). Wenn ihr mehrere Zahlen zu einem Vektor kombiniert habt, könnt ihr damit so spaßige Dinge machen wie Mittelwerte ausrechen, sie aufsummieren oder zwei Vektoren gleicher Länge addieren.\nProbiert mal ein paar Beispiele aus:\n\nCode# Ein paar Zahlen\nc(1, 1, 2, 3, 5, 8, 13, 21)\n#> [1]  1  1  2  3  5  8 13 21\n\n# Was ist der Mittelwert der Zahlen?\nmean(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 6.75\n\n# Und die Summe?\nsum(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 54\n\n# Und wenn wir quadrieren?\nc(1, 1, 2, 3, 5, 8, 13, 21)^2\n#> [1]   1   1   4   9  25  64 169 441\n\n# Oder die Wurzel ziehen?\nsqrt(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 1.000000 1.000000 1.414214 1.732051 2.236068 2.828427 3.605551 4.582576\n\n\nWas wir hier sehen ist der Unterschied zwischen Funktionen, die aus mehreren Zahlen eine machen (mean, sum), und Funktionen, die auf jeder Zahl einzeln operieren (sqrt, ^).\nWas wir außerdem sehen: Jedes mal die Liste von Zahlen c(1, 1, 2, 3, 5, 8, 13, 21) kopieren und in eine Funktion einsetzen ist ziemlich unpraktisch. Stellt euch vor, ihr habt eine Reihe von Testergebnissen von hunderten ProbandInnen und müsst da alles einzeln, also, nein, das wäre ja albern.\nFür sowas gibt es dann Abstraktionen wie Variablen und Datensätze, die entweder eine Liste von Werten oder auch eine Liste einer Liste von Werten handlich machen — das sehen wir dann in den nächsten beiden Abschnitten.\nEine weitere praktische Funktion ist length(): Sie sagt uns, wie lang das Argument ist.\nWenn wir uns also angucken, wie der Mittelwert funktioniert…\n\\[\\bar{x} = \\frac{1}{n} \\sum^n_{i=1} x_i\\]\n…und wir das übersetzen in “Die Summe aller Werte geteilt durch die Anzahl der Werte”, dann können wir statt mean also auch folgendes schreiben:\n\nCode# in lang\nsum(c(1, 1, 2, 3, 5, 8, 13, 21))/length(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 6.75\n\n# in kurz\nmean(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 6.75\n\n\nIhr seht vielleicht so langsam, wieso wir das mit den Klammern und den Leerzeichen für die Lesbarkeit erwähnt haben.\nAber gut, so langsam wird’s unübersichtlich, es wird Zeit ein paar Variablen anzulegen.\n\n5.1.1 Funktionsbeispiele\nWenn ihr R lernt, werdet ihr erfahrungsgemäß die meiste Zeit damit verbringen herauszufinden wie bestimmte Funktionen funktionieren und welche Funktion für euer Vorhaben die richtige ist.\nFunktionen sind zwar vom Schema immer gleich — ihr steckt irgendwelche Argumente rein, und es kommt irgendein Ergebnis raus — aber wie die Argumente aussehen unterscheidet sich von Funktion zu Funktion.sd() zum Beispiel hat zwei Argumente:\n\n\nx: Ein Vektor aus Zahlen, aus denen die Standardabweichung berechnet werden soll\n\nna.rm: Für NA remove, entweder TRUE oder FALSE. Wenn x fehlende Werte (NA) enthält, dann werden diese automatisch ignoriert, wenn na.rm = TRUE\n\n\n\nCodezahlen <- c(3, 6, 8, 3, 1, 2, 5, 6, 4, 3, NA, 4, 5, 7, NA, 1, 4)\n\n# Ergibt NA :(\nsd(zahlen)\n#> [1] NA\n\n# Ergibt ein Ergebnis :)\nsd(zahlen, na.rm = TRUE)\n#> [1] 2.065591\n\n\nDer default für na.rm ist bei den meisten Funktionen (z.B auch mean) FALSE, das heißt fehlende Werte werden nicht automatisch ignoriert. Wenn euer input aber NA enthält, dann lässt sich daraus nicht sauber ein Mittelwert oder eine Standardabweichung berechnen, weil wir nichts über NA wissen (wir widmen uns NA im Kapitel zu Datentypen).\nNicht jede Funktion hat ein Argument namens na.rm, aber ihr werdet im Laufe der Zeit lernen, bei welchen Funktionen ihr darauf achten müsst, wie mit fehlenden Werten umgegangen wird.\nEinige andere Funktionen, die insbesondere zum Lernen und Ausprobieren praktisch sind, werden zur Erstellung von Sequenzen benutzt — also Reihen von Zahlen in einem bestimmten Muster:\n\nCode# Die Zahlen von 1 bis 100\n1:100\n#>   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n#>  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n#>  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n#>  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n#>  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n#>  [91]  91  92  93  94  95  96  97  98  99 100\n\n# 10 bis 15 in 0.5er-Schritten\nseq(10, 15, 0.5)\n#>  [1] 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0\n\n# Äquivalent, mit explizit benannten Argumenten:\nseq(from = 10, to = 15, by = 0.5)\n#>  [1] 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0\n\n# Von 5 bis -5 in ganzen Schritten\nseq(5, -5)\n#>  [1]  5  4  3  2  1  0 -1 -2 -3 -4 -5\n\n# Sequenz von 1 mit Länge 5, dasselbe wie 1:5\nseq_len(5)\n#> [1] 1 2 3 4 5\nseq_len(length.out = 5)\n#> [1] 1 2 3 4 5\n\n\nDas : ist eine einfache Funktion und kann gelesen werden wie “Von … bis … in ganzen Schritten”. Zusötzlich gibt es die Funktion seq(), die etwas flexibler ist. Außerdem gibt es diverse Funktionen für zufallsgenerierte Zahlen:\n\nCode# Normalverteilte Zufallszahlen (10 Stück, Mittelwert 5, Standardabweichung 2) \nrnorm(n = 10, mean = 5, sd = 2)\n#>  [1] 3.125531 4.290414 3.257567 6.157613 8.736960 5.762605 3.971103 3.725957\n#>  [9] 3.205225 6.926189\n\n# Gleichverteilte Zufallszahlen (sprich \"r unif\", nicht \"run if\")\nrunif(n = 10)\n#>  [1] 0.87405632 0.06917889 0.43218638 0.45629630 0.73254597 0.39701918\n#>  [7] 0.13624601 0.81409080 0.21727864 0.46286741\n\n# Münzwurf (Binomialverteilte Ergebnisse), 10 Stück\nrbinom(n = 10, size = 1, prob = 0.5)\n#>  [1] 1 1 1 1 1 0 0 1 0 1\n\n# Würfel (W6) (10 Stück)\nsample(x = 1:6, size = 10, replace = TRUE)\n#>  [1] 6 3 6 3 5 6 3 6 3 5"
  },
  {
    "objectID": "chapters/04-erste-schritte.html#variablen",
    "href": "chapters/04-erste-schritte.html#variablen",
    "title": "\n5  Erste Schritte\n",
    "section": "\n5.2 Variablen",
    "text": "5.2 Variablen\nWenn Funktionen wie Verben sind, dann sind Variablen wie Nomen. Sie haben einen Namen, und mit ihnen kann man Dinge tun. Oder sogar Sachen machen.\nVariablen werden durch eine Zuweisung (Assignment) erstellt, was in R traditionell via <- passiert.\nIn den meisten anderen Programmiersprachen benutzt man dafür =, aber nun ja, R ist historisch gewachsen1, also nehmt für den Anfang einfach mal hin, dass das nunmal so ist.\nWir speichern also mal ein paar Dinge:\n\nCode# Speichern in \"fib\"\nfib <- c(1, 1, 2, 3, 5, 8, 13, 21) \n\n# Ausgeben lassen\nfib\n#> [1]  1  1  2  3  5  8 13 21\n\n# Mittelwert…\nmean(fib)\n#> [1] 6.75\n\n# …funktioniert immer noch. Angenehm.\n# Und wenn wir…\nfib + fib\n#> [1]  2  2  4  6 10 16 26 42\n\n# Abgefahrener Kram.\n\n\nHier haben wir die Zahlen 1, 1, 2, 3, 5, 8, 13, 21 in die Variable fib gespeichert, weil es die ersten paar Fibonacci-Zahlen sind, und wir unsere Variablen immer so benennen sollten, dass wir später noch wissen wofür sie da sind. Viele Tutorials beginnen damit, Variablen wie x, y und z anzulegen, aber da blickt ja irgendwann kein Mensch mehr durch.\nWenn ihr jetzt mit euren Zahlen arbeiten wollt, könnt ihr einfach in jeder Funktion fib statt der Liste mit c(…) einsetzen, und alles funktioniert wie vorher. Das liegt daran, dass R bei jedem Befehl erstmal nachschaut, ob ihr eine Variable benutzt (alles was Text ohne Anführungszeichen ist), und ob es die Variable findet. Wenn es die Variable gefunden hat, guckt es nach, was da drinsteht, in diesem Fall also c(1, 1, 2, 3, 5, 8, 13, 21), dann benutzt R den Inhalt der Variablen.\nAn dieser Stelle bietet es sich an, einen neuen Typ einzuführen: Den String (oder auch character). Als String bezeichnet man im Kontext von, naja, Computerkram generell eigentlich, alles was als Text durchgeht. Sobald wir etwas nicht mehr nur durch Zahlen darstellen können, ist es ein String.\nStrings stehen in R immer in Anführungszeichen, entweder in \"doppelten\" oder in 'einfachen'.\nWichtig dabei ist, dass sich Anführungszeichen ähnlich verhalten wie Klammern. Wenn wir einen String mit “ beginnen, müssen wir ihn auch wieder mit ” schließen, ansonsten wartet R brav darauf, dass endlich das zweite “ kommt und verläuft sich.\nEin Beispiel:\n\nCode# Vollkommen okay\nnamen <- c(\"Tobi\", \"Lukas\", \"Nadja\", \"Christoph\")\n\n# Auch okay, aber inkonsistent und daher eher unschön\nnamen <- c('Tobi', \"Lukas\", 'Nadja', \"Christoph\")\n\n# Tod und Verderben (=> funktioniert nicht)\nnamen <- c(\"Tobi\", 'Lukas\", 'Nadja, Christop\")\n\n\nWir können auch Zahlen in \"\" setzen — das ist kein Problem, aber dann sind es nunmal keine Zahlen in diesem Sinne mehr, es sind Strings, und mit Strings können wir nicht rechnen.\nProbiert folgendes aus:\n\nCode# Okay\n5 + 5\n\n# Hä?\n5 + \"5\"\n\n\nIhr sehr jetzt vermutlich die Meldung Error in 5 + \"5\" : non-numeric argument to binary operator.\nDas non-numeric argument hier ist die \"5\". Merken: 5 ist numerisch, aber \"5\" ist ein character (=> String).\nDer binary operator an dieser Stelle ist übrigens das +. Ein Operator, weil es, äh… operiert? Naja, es tut Dinge, und wenn etwas in R Dinge tut, ist es meistens ein Operator in irgendeinem Sinne. Das binary heißt, dass es zwei (bi, binär, binary, zwei halt) Argumente nimmt.\nWie schon gesagt, Argumente sind die Dinge, die wir an Funktionen übergeben, und wenn wir an eine Funktion wie + oder auch mean() ein Argument übergeben, mit denen sie nichts anfangen können, dann beschwert sich R weil es nicht weiß was zum Geier ihr da vorhabt.\n\nCodenamen <- c(\"Tobi\", \"Lukas\", \"Nadja\", \"Christoph\")\n\nfib <- c(1, 1, 2, 3, 5, 8, 13, 21) \n\n# Alles knorke\nmean(fib)\n#> [1] 6.75\n\n# Alles CHAOS UND UNHEIL\nmean(namen)\n#> Warning in mean.default(namen): argument is not numeric or logical:\n#> returning NA\n#> [1] NA\n\n\nWas es mit NA auf sich hat, und was es noch so für Datentypen gibt, sehen wir dann im Abschnitt zu [Datentypen].\nEine letzte Sache noch: Strings sind “dominanter” als Zahlen, das heißt, wir können zwar Zahlen verbinden zu c(1, 2, 3), und Strings zu c(\"A\", \"B\", \"C\"), aber wenn wir c(\"A\", 2, \"C\", 4) schreiben, dann behandelt R einfach alle Elemente des Vektors (=> Das, was in c(…)) steht, als wären es character-Werte.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: Merke: Ein Vektor in R muss immer Elemente des gleichen Typs haben, Zahlen und Buchstaben zusammen werden zu Strings konvertiert!"
  },
  {
    "objectID": "chapters/04-erste-schritte.html#tabellen",
    "href": "chapters/04-erste-schritte.html#tabellen",
    "title": "\n5  Erste Schritte\n",
    "section": "\n5.3 Tabellen",
    "text": "5.3 Tabellen\nJetzt haben wir schonmal das Vokabular an der Hand um Zahlen und beliebige Strings in R zu verarbeiten, aber noch ist das alles etwas unhandlich um damit richtig zu arbeiten.\nStellt euch vor, wir wollen einen kleinen Datensatz erstellen über die Statistiktutorien in QM mit Variablen wie Namen, Alter, und vielleicht sowas wie Beliebtheit auf einer Skala von 1-10.\nWir könnten sowas machen:\n\nCodenamen <- c(\"Tobi\", \"Christoph\", \"Nadja\", \"Lukas\")\nalter <- c(20, 35, 30, 12) # (Nicht alle diese Werte sind korrekt)\n\nmean(alter)\n#> [1] 24.25\n\n\nSchön und gut, aber das ist ja unhandlich. Was, wenn wir die Namen aller TutorInnen haben wollen, die jünger als 30 sind? Alles was wir mit alter machen, passiert unabhängig von namen.\nUm mehrere Variablen in Kontext zu setzen, gibt es tabellarischen Datenstrukturen, namentlich nennt sich sowas in R dann data.frame. Letztendlich ist das nichts anderes als eine Tabelle, aber für R ist eine Tabelle praktische eine Liste von Vektoren mit gleicher länge:\n\nCodeleute <- data.frame(name = c(\"Tobi\", \"Christoph\", \"Nadja\", \"Lukas\"),\n                    alter = c(20, 35, 30, 12),\n                    beliebtheit = c(9, 10, 8, 3))\n\n# Anzeigen lassen\nleute\n#>        name alter beliebtheit\n#> 1      Tobi    20           9\n#> 2 Christoph    35          10\n#> 3     Nadja    30           8\n#> 4     Lukas    12           3\n\n\nWas haben wir da gemacht?\n\nWir haben einen data.frame mit der gleichnamigen Funktion erstellt\nDie Argumente der Funktion haben die Form Spaltenname = Werte der Spalte\n\nMehrere Argumente werden mit , getrennt und optional mit einem Zeilenumbruch übersichtlich gehalten\n\nDas Ergebnis ist eine Variable leute, die drei Spalten mit je vier Werten hat.\nJede Spalte ist eine Variable, und jede Zeile der Tabelle kann als eine Beobachtung betrachtet werden.\nEine Beobachtung (Observation) sind alle Werte, die wir zu einem Untersuchungsobjekt haben, also in diesem Beispiel eine Person. Wenn wir uns nur die erste Zeile anschauen, sehen wir nur die Werte, die zu Tobi gehören, in der zweiten Zeile sehen wir die Werte zu Christoph etc.\nTabellen, und damit data.frames, sind für uns die wichtigsten Objekte in R, weil wir fast ausschließlich mit Datensätzen in dieser Form arbeiten werden um unsere Statistik da draufzuwerfen.\nWie können wir jetzt mit einzelnen Variablen arbeiten?\n\nCode# Die Variable \"name\" ausgeben lassen\nleute$name\n#> [1] \"Tobi\"      \"Christoph\" \"Nadja\"     \"Lukas\"\n\n# Den Mittelwert von \"alter\" bestimmen\nmean(leute$alter)\n#> [1] 24.25\n\n# Die Standardabweichung von \"beliebtheit\"\nsd(leute$beliebtheit)\n#> [1] 3.109126\n\n# Was auch funktioniert:\nleute[[\"name\"]]\n#> [1] \"Tobi\"      \"Christoph\" \"Nadja\"     \"Lukas\"\nleute[[\"alter\"]]\n#> [1] 20 35 30 12\n\n\nDas mit den “Levels” wird im Abschnitt zu [Datentypen] erklärt\nWas wir hier benutzen nennt sich Subsetting, also im Grunde nur einen Teil von etwas rausholen. Hier also einen Teil der Tabelle on Form einer einzelnen Spalte.\nSpalten können wir mit $ oder [[ ]] direkt aus einem data.frame ansteuern, was unser Leben gleich viel einfacher macht. Strenggenommen sidn $ und [[ auch eigene Funktionen, aber dazu vielleicht später mehr, im Moment ist für uns nur wichtig, dass wir einzelne Spalten (Variablen) einer Tabelle (data.frame) einfach adressieren und genauso behandeln können wie die einzelnen Variablen name und alter, die wir weiter oben erstellt haben."
  },
  {
    "objectID": "chapters/04-erste-schritte.html#umgang-mit-datensätzen",
    "href": "chapters/04-erste-schritte.html#umgang-mit-datensätzen",
    "title": "\n5  Erste Schritte\n",
    "section": "\n5.4 Umgang mit Datensätzen",
    "text": "5.4 Umgang mit Datensätzen\nDa wir noch nicht an dem Punkt sind, wo wir beliebige Daten einlesen können, und wir natürlich zu faul sind uns eine größere Tabelle selber zu schreiben, greifen wir zu Übungszwecken mal auf einen Datensatz zurück, der bei R von Haus aus mitgeliefert wird: sleep.\nDieser Datensatz beinhaltet die Daten aus einer Medikamentenstudie, bei der es um Schlafgewinn bzw. -verlust ging. Die Tabelle hat drei Spalten (Variablen) zu 10 Personen:\n\n\nextra: Schlafzuwachs in Stunden, positiv oder negativ für mehr bzw. weniger Schlaf als vorher\n\ngroup: Die Versuchsgruppe, sprich welches Medikament die Person bekam, 1 oder 2\n\n\nID: Die Identifikationsnummer der Person. Es ist gängig, ProbandInnen pseudonymisiert durchzunummerieren, der Zuordnung unt des Datenschutzes wegen als Zahlen.\n\n\nCode# Mit head() lassen wir uns die ersten paar Zeilen (den \"Kopf\") der Tabelle anzeigen\nhead(sleep)\n#>   extra group ID\n#> 1   0.7     1  1\n#> 2  -1.6     1  2\n#> 3  -0.2     1  3\n#> 4  -1.2     1  4\n#> 5  -0.1     1  5\n#> 6   3.4     1  6\n\n\nWie viele Zeilen hat die Tabelle?\n\nCodenrow(sleep)\n#> [1] 20\n\n\nDie number of rows bekommen wir mit nrow() — ihr dürft jetzt raten, wie wir uns die Anzahl der Spalten (columns) anzeigen lassen können.\n\nCodencol(sleep)\n#> [1] 3\n\n\nSurprise!\nOkay, aber was interessiert uns an diesem Datensatz jetzt? Wie wäre es mit dem durchschnittlichen Schlafzuwachs:\n\nCodemean(sleep$extra)\n#> [1] 1.54\n\n\nSchön und gut, aber wir wollen ja vermutlich die beiden Gruppen (Medikamente) vergleichen, also was tun?\nSubsetting to the rescue /o/\n\nCodegruppe1 <- sleep[sleep$group == 1, ]\ngruppe2 <- sleep[sleep$group == 2, ]\n\n# Mittelwert der ersten Gruppe\nmean(gruppe1$extra)\n#> [1] 0.75\n\n# Mittelwert der zweiten Gruppe\nmean(gruppe2$extra)\n#> [1] 2.33\n\n\nOkay, Schritt für Schritt.\nHier haben wir unseren ersten logischen vergleich benutzt, um eine Teilmenge der Tabelle zu extrahieren.\nDas klingt fancy, ist aber ziemlich simpel.\nIn Worten heißt die Zeile gruppe1 <- sleep[sleep$group == 1] lediglich:\n“Nimm die Tabelle sleep und filtere daraus alle Zeilen, die zu der Gruppe 1 gehören, und speichere sie in die Variable gruppe1” Das Resultat sind zwei Variablen, die einen Teil der Tabelle sleep enthalten, und zwar jeweils zu einer der beiden Gruppen.\nWieso dann eigentlich noch diese ,-Sache am Ende der eckigen Klammern?\nDas gehört zur Art, wie R Tabellen indiziert, sprich wie man einzelne Bereiche der Tabelle ansteuert:\n\nCode# Die erste Spalte\nsleep[1]\n#>    extra\n#> 1    0.7\n#> 2   -1.6\n#> 3   -0.2\n#> 4   -1.2\n#> 5   -0.1\n#> 6    3.4\n#> 7    3.7\n#> 8    0.8\n#> 9    0.0\n#> 10   2.0\n#> 11   1.9\n#> 12   0.8\n#> 13   1.1\n#> 14   0.1\n#> 15  -0.1\n#> 16   4.4\n#> 17   5.5\n#> 18   1.6\n#> 19   4.6\n#> 20   3.4\n\n# Die erste Zeile\nsleep[1, ]\n#>   extra group ID\n#> 1   0.7     1  1\n\n# Die erste Zeile und die dritte Spalte\nsleep[1, 3]\n#> [1] 1\n#> Levels: 1 2 3 4 5 6 7 8 9 10\n\n\nDie allgemeine Form ist tabelle[Zeilennummer, Spaltennumer], und jetzt fragt ihr euch vermutlich, wieso wir vorhin [[ ]] benutzt haben, und jetzt [ ] — die kurze Antwort ist: Das ist halt was anderes. Die Details sind erstmal nicht so wichtig, was ihr euch vorerst merken solltet ist folgendes:\n\n\nsleep[1] ergibt einen data.frame mit nur einer Spalte\n\n\nsleep[1, ] ergibt einen data.frame mit nur einer Zeile\n\n\nsleep[[1]] und sleep$extra sind dasselbe (weil extra die erste Spalte ist) und ergeben die erste Spalte als Vektor\n\n\nsleep$extra[[2]] und sleep$extra[2] sind hier dasselbe: Das zweite Element im Vektor sleep$extra\n\n\nBei einer Tabelle ist es nützlich mit Zeilen und Spalten zu arbeiten, um die gewünschten Werte rauszuholen, aber bei einem Vektor gibt es in diesem Sinne nur eine Dimension.\nSinn der Sache ist, dass wir Funktionen wie mean oder sd nur auf Vektoren anwenden können, was auch intuitiv irgendwie sinnvoll scheint, denn der Mittelwert einer ganzen Tabelle mit mehreren Variablen ist ja konzeptionell etwas… schwierig.\n# Okay\nmean(sleep$extra)\n#> [1] 1.54\n\n# Das selbe Ergebnis\nmean(sleep[[1]])\n#> [1] 1.54\n\n# Auch okay!\nmean(sleep[[\"extra\"]])\n#> [1] 1.54\n\n# Das hier nicht so\nmean(sleep[1])\n#> Warning in mean.default(sleep[1]): argument is not numeric or logical:\n#> returning NA\n#> [1] NA\nsleep[1] gibt euch zwar auch die Spalte extra, aber wie schon gesagt, in data.frame-Form, und nicht als Vektor.\nVermutlich verwirrt euch das ganze Geklammere jetzt mehr oder weniger stark, aber glaubt mir, wenn wir erstmal ein Gefühl dafür habt ist es sehr viel Wert diese Grundlagen auf dem Schirm zu haben (oder sie zumindest nachlesen zu können), denn in der ersten Zeit eurer R-Nutzung werdet ihr massenhaft kleinere und größere Fehler in dieser Art machen, wo ihr zwar das richtige meint, aber R nicht das richtige sagt.\nDie andere Sache ist, dass ihr das mit den eckigen Klammern gar nicht so häufig brauchen werdet, wenn ihr euch erstmal an das tidyverse und dplyr gewöhnt habt, aber dazu später mehr.\nWir schneiden das Ganze Thema Subsetting hier auch erstmal nur an, aber wenn ihr’s jetzt schon ganz genau wissen wollt, könnt ihr die Details hier nachlesen"
  },
  {
    "objectID": "chapters/04-erste-schritte.html#logische-vergleiche",
    "href": "chapters/04-erste-schritte.html#logische-vergleiche",
    "title": "\n5  Erste Schritte\n",
    "section": "\n5.5 Logische Vergleiche",
    "text": "5.5 Logische Vergleiche\nLogik! Eine Welt des Spaßes, der internen Konsistenz[^Naja, fast. Aber Gödel lassen wir mal aus.] und der unendlichen Anwendbarkeit in allen Bereichen.\nWas ihr intuitiv als Logik kennt ist alleridngs etwas anderes als formale Logik, also das, was Computer verstehen.\nWir brauchen zum Glück nicht all zu viel davon, nur den Standardkram und nichtmal das volle Spekrum Bool’scher Algebra.\nWir brauchen Logik in R in erster Linie zum indizieren von Objekten. Das heißt, wenn wir alle Zeilen einer Tabelle haben wollen, für die eine bestimmte Variable einen bestimmten Wert hat oder eine Bedingung erfüllt, dann drücken wir das durch Logik aus. Dasselbe funktioniert natürlich auch bei Vektoren (und strenggenommen funktioniert Tabellenindizierung sowieso über Vektorindizierung). Man nehme folgendes Beispiel:\n\nCodesleep[sleep$extra > 3, ]\n#>    extra group ID\n#> 6    3.4     1  6\n#> 7    3.7     1  7\n#> 16   4.4     2  6\n#> 17   5.5     2  7\n#> 19   4.6     2  9\n#> 20   3.4     2 10\n\n\nDas heißt: “Nimm die Tabelle sleep und gib mir alle Zeilen (das mit den eckigen Klammen), für die die Variable sleep$extra größer als 3 ist”.\nDas Ergebnis eines logischen Vergleichs ist immer entweder TRUE oder FALSE für wahr oder falsch.\nWenn wir in R indizieren wollen, können wir dafür auch direkt TRUE und FALSE statt eines Vergleichs benutzen:\n\nCodefib <- c(1, 1, 2, 3, 5, 8, 13, 21) \n\nfib[c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)]\n#> [1] 1 1\n\n\nHier haben wir uns effektiv nur die ersten beiden Werte des Vektors fib ausgeben lassen, weil R alles ausgibt, was mit TRUE indiziert ist und alles weglässt, was mit FALSE indiziert ist.c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE) ist hier ein logischer Vektor, also ein Vektor mit, naja, logischen Werten, der praktisch der Reihe nach jedes Element im Vektor fib entweder an oder aus schaltet, wie Lichtschalter. Wir müssen dafür nicht unbedingt einen logischen Vektor der gleichen Länge (Anzahl der Elemente) wie unser Zielvektor (der, den wir indizieren/filtern wollen) benutzen, aber es bietet sich für den Einstieg an so genau wie möglich zu sein.\nWir könnten aber auch sowas machen:\n\nCode# Immer abwechselnd TRUE und FALSE, also jedes zweite Element\nfib[c(TRUE, FALSE)]\n#> [1]  1  2  5 13\n\n# Schema TRUE TRUE FALSE FALSE ginge auch\nfib[c(TRUE, TRUE, FALSE, FALSE)]\n#> [1] 1 1 5 8\n\n\nWichtig hierbei ist, dass der logische Vektor ein ganzer Faktor des Zielvektors ist, das heißt, dass die Anzahl der Element im Zielvektor ganz durch die Anzahl der Elemente im logischen Vektor teilbar sein muss (also ohne Rest), ansonsten bekommen wir potenziell schwer vorhersagbare Ergebnisse.\nWas R hier macht nennt sich Recycling: In der ersten Zeile im letzten Beispiel wird der Vektor c(TRUE, FALSE) solange recyclet, also wiederverwendet, bis der ganze Zeilvektor “abgedeckt” ist. Wenn der logische Vektor nicht sauber in den Zielvektor passt (in Bezug auf die Anzahl der Elemente), dann bleibt entweder was übrig oder es reicht nicht. Das wäre schade.\n\n5.5.1 Operatoren\nEs gibt eine Reihe logischer Operatoren wie hier > für “ist größer als”, die wichtigsten in Übersicht:\n\n\n== (doppeltes Gleichheitszeichen ohne Leerzeichen dazwischen)\n\n“Ist gleich”\n\n1 == 2 –> FALSE\n\n\n3 == 3 –> TRUE\n\n\n3 == \"Hallo\" –> FALSE\n\n\n\n\n!=\n\n“ist ungleich”\nDie Negation von ==, also immer da wo == euch TRUE zeigt, gibt != euch FALSE und andersherum.\n\npi != 3 –> TRUE\n\n\"Psychologiestudium\" != \"Voll gute Idee\"\n\n\n\n! (ja, ein einfaches Ausrufezeichen)\n\n“Negation”\nDreht ein FALSE zu einem TRUE um und andersherum. Wichtig: Klammern!\n!(2 == 3)\nTRUE == !FALSE\n\n\n\n> und < (spitze Klammern)\n\n“ist größer/kleiner als”\nDa wo die Klamer spitz ist, soll das kleinere sein\n\n5 > 4 –> TRUE\n\n\n2^10 < 1000 –> FALSE\n\n\n2 < 5 < 4 –> Funktioniert nicht!\n\n\n\n\n>=, <=\n\n“Größer gleich bzw. kleiner gleich”\nIst Entweder a > b oder a == b?\n5 >= 4\n16 <= 2^4\n\n\n\nDiese Ausdrücke können wir auch auf bestimmte Arten verknüpfen:\n\n\n& (oder auch &&)\n\n“Und”\nIst TRUE, wenn beide Seiten TRUE sind\n\n(1 < 3) & (5 < 10) –> TRUE\n\n\n(5 < 2) & (2 < 10) –> FALSE\n\n1 und 0 werden zu TRUE bzw. FALSE übersetzt:\n\n\n1 & (2 == 2) –> TRUE\n\n\n!(0 & FALSE) –> TRUE\n\n\n\n\n\n\n| (oder auch ||)\n\n“Oder”\nIst entweder A oder B oder beides TRUE?\nDa | auch wahr ist, wenn nur eine Seite wahr ist, ist es auch Grundlage etlicher Mathe-/Logikwitze\n\n(1 < 3) | (5 < 10) –> TRUE\n\n\n(5 < 2) | (2 < 10) –> TRUE\n\n\n\n\nxor()\n\n“Entweder … oder …” (ausschließend!)\nWenn euch | zu unspezifisch ist\nIst nur war, wenn eins von beidem wahr ist, aber nicht, wenn beides wahr ist\n\nKein binärer Operator wie die anderen, sondern eine R-Funktion mit Klammern und so\n\nxor(TRUE, FALSE) –> TRUE\n\n\nxor(TRUE, TRUE) –> FALSE\n\n\nxor((1 < 3), (5 < 10)) –> FALSE\n\n\nxor((5 < 2), (2 < 10)) –> TRUE\n\n\n\n\n5.5.2 Spezielle Tests\nDie obigen Operatoren können wir für getrost für Vektorvergleiche benutzen, aber es gibt noch ein paar Sonderfälle. Was zum Beispiel, wenn wir nur generell wissen wollen, ob ein Element wie eine Zahl oder ein String in einem Vektor enthalten ist? Oder was, wenn wir wir auf spezielle Typen oder Klassen testen wollen? Was das im Detail heißt sehen wir in den entsprechenden Abschnitten zu [Datentypen] noch einmal, aber hier schonmal eine Kurzreferenz:\n\n\n%in% (auch hier, ohne Leerzeichen dazwischen!)\n\n“Ist in”\nMengentheoretisch ist das \\(x \\in X\\)\n\nIst Element a in Menge b?\n\n5 %in% c(1, 4, 5, 3) –> TRUE\n\n\n\"B\" %in% c(\"a\", \"b\", \"c\") –> FALSE\n\n\n\"B\" %in% c(\"a\", \"B\", \"c\") –> TRUE\n\n\nc(1, 2) %in% 1:5 –> TRUE\n\n\n\n\nis.na(): Testet auf fehlende Werte (missing values, NA)\n\nis.null(): Testet auf leere Werte (NULL)\n\nis.nan(): Testet auf NaN (Not a Number)\n\n5.5.3 Indexing: Beispiele\nDas war jetzt relativ viel Information, und ihr müsst euch das auch nicht alles sofort merken, sondern nur wissen, wo ihr’s bei Bedarf nachschlagen könnt.\nDie Motivation hinter dem Logikram ist wie erwähnt primär das Filtern von Tabellen und Vektoren, was wir nunmal relativ häufig brauchen um zum Beispiel bestimmte Untergruppen in unseren Datensätze zu analysieren, zum Beispiel Personen älter als 35 (z.B. age > 35) oder Menschen, die sowohl weiblich sind als auch Medikament B bekommen haben (z.B. geschlecht == \"weiblich\" & drug == \"B\").\n\n5.5.3.1 Vektoren\nVektoren werden immer elementweise verglichen, das heißt, dass das Ergebnis von c(1, 2) == 1 nicht FALSE oder TRUE ist, sondern der logische Vektor TRUE FALSE. Dadurch entsteht durch den logischen Vergleich eines Vektors ein Vektor aus TRUE und FALSE, den wir zum indizieren benutzen können, wie wir weiter oben schon gesehen haben.\n\nCode# Irgendwelche Zahlen\nx <- c(4, 7, 2, 1, 7, 9, 6, 5, 4, 3, 3, 2, 2, 5, 8, 9, 31)\n\n# Alle Zahlen größer 4: \"Gib mir x, wo x > 4\"\nx[x > 4]\n#> [1]  7  7  9  6  5  5  8  9 31\n\n# Die Logik dahinter\nx > 4\n#>  [1] FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n#> [13] FALSE  TRUE  TRUE  TRUE  TRUE\n\n# Alle Zahlen größer 5 und kleiner 20\nx[x > 5 & x < 20]\n#> [1] 7 7 9 6 8 9\n\n\nDas Ganze lässt sich natürlich beliebig komplex aussehen lassen, weshalb zu viele Bedingungen in Kombination etwas verwirrend aussehen können.\nWeiterhin können wir einen Vektor natürlich auch durch einen Vergleich eines anderen Vektors indizieren.\n\nCodex <- c(4, 7, 2, 1, 7, 9, 6, 5, 4, 3)\ny <- c(6, 7, 10, 1, 9, 3, 6, 5, 6, 3)\n\n# x, wo x größer gleich 4 ist *und* y kleiner 6\nx[x >= 4 & (y < 6)]\n#> [1] 9 5\n\n# x, wo x und y identisch sind\nx[x == y]\n#> [1] 7 1 6 5 3\n\n# x, wo x kleiner y ist\nx[x < y]\n#> [1] 4 2 7 4\n\n\n\n5.5.3.2 Tabellen data.frame\n\nTabellenindexing ist nichts anderes als Vektorindexing mit einer anderen Struktur. Alle Regeln zum Vektorindexing, die wir bisher gesehen haben, gelten auch so für data.frames, nur dass wir hier jetzt auf einmal in Spalten und Zeilen denken müssen, anstatt in Vektoren."
  },
  {
    "objectID": "chapters/05-datentypen.html",
    "href": "chapters/05-datentypen.html",
    "title": "\n6  Datentypen\n",
    "section": "",
    "text": "Es gibt eine Reihe von Unterscheidungsmöglichkeiten zwischen verschiedenen Arten von Daten.\nNeben der naheliegenden Unterscheidung zwischen “Zahlen” und “Buchstaben” gibt es diverse andere Typen, die R verwendet.\nTechnisch gesehen müssten wir hier noch zwischen Typen und Klassen unterscheiden, aber für die meisten unserer normalen Anwendungszwecke ist es nicht unbedingt notwendig Typen und Klassen auseinanderhalten zu können, weshalb wir hier auch mehr oder weniger beides gleichzeitig abhandeln.\n“Und wieso sollte uns interessieren, wie R da unterscheidet?”\nR ist verwirrt, wenn wir Buchstaben in eine Funktion stecken, die Zahlen erwartet. Genauso ist R verwirrt, wenn wir den Mittelwert aus einer Tabelle berechnen wollen. Mittelwerte sind nur dann sinnvoll, wenn wir sie aus einem Vektor aus numerischen Werten berechnen. Da eure Daten in verschiedenen Formaten ankommen, und unterschiedliche Repräsentationen unterschiedliche Vor- und Nachteile haben, ist es wichtig, dass ihr im Zweifelsfall herausfinden könnt was ihr da vor der Nase habt und wie ihr damit arbeiten könnt.\nWas eine R-Funktion mit einem Objekt anstellt hängt von der Klasse des Objekts ab, das ganze fällt vermutlich irgendwo unter “object oriented programming”, und wenn ihr InformatikerInnen kennt und die euch Fragen, ob R eine funktionale oder objektorientierte Frage ist, könnt ihr getrost “ja” sagen1.\nDie wichtigste Funktion für diesen Abschnitt ist class(), was euch sagt was R unter einem bestimmten Objekt versteht (die Klasse des Objekts):\n(Was es mit factor auf sich hat sehen wir ein paar Abschnitte weiter)\nZusätzlich gibt es typeof(), eine Funktion, die so speziell ist, dass ich sie in meinen ~4 Jahren R erst neulich entdeckt habe, weil der exakte Typ eines Objekts meistens weniger relevant ist als die Klasse:"
  },
  {
    "objectID": "chapters/05-datentypen.html#numeric-zahlen-und-so",
    "href": "chapters/05-datentypen.html#numeric-zahlen-und-so",
    "title": "\n6  Datentypen\n",
    "section": "\n6.1 Numeric (Zahlen und so)\n",
    "text": "6.1 Numeric (Zahlen und so)\n\nZahlen in R (und in den meisten anderen Programmiersprachen, beziehungsweise generell irgendwo, wo Maschinen rechnen) kommen in zwei Geschmacksrichtungen: Integer (ganze Zahlen) und double (Dezimalzahlen, Fließkommazahlen, floating point numbers).\nDer Grund dafür hat damit zu tun, wie Computer intern Zahlen abbilden, binäres Zahlensystem, Bits, ihr wisst schon — komplizierter Kram wo sich kluge Menschen Dinge ausdachten, mit denen wir arbeiten können, wir aber nicht im Detail verstehen müssen.\nFließkommazahlen sind so gängig, dass R sogar eine einfache ganze Zahl wie 2 erstmal als double, also praktisch als 2.0 interpretiert, und wir explizit 2L schreiben müssen, wenn wir “2, aber als integer” meinen. Wieso wir dafür L brauchen sei dahingestellt, aber nun ja, der Unterschied ist da:\n\nCode# Beides \"numeric\"\nclass(2)\n#> [1] \"numeric\"\nclass(2.5)\n#> [1] \"numeric\"\n\n# Aber…\ntypeof(2L)\n#> [1] \"integer\"\n\n# …und\ntypeof(2.5)\n#> [1] \"double\"\n\n\nIntegers sind ziemlich unproblematisch, werden aber in der Praxis nicht häufig explizit genutzt.\nFließkommazahlen (double) hingegen tauchen häufiger auf, weil Computer in den letzten Jahrzehnten echt verdammt gut darin geworden sind, mit Fließkommazhalen zu rechnen. Arithmetik mit integers ist auch okay, aber wenn eure Datensätze riesig und eure Statistik komplex ist, dann ist Geschwindigkeit von Rechenoperationen auf ein mal ein wichtiger Faktor.\nDas Problem an der Sache ist nur leider, dass Fließkommazahlen seltsam sind. Nicht nur vom initialen Verständnis her, dazu empfehle ich euch herzlichst dieses schöne Video von Tom Scott, sondern auch für ganz reale Konsequenzen, über die wir stolpern können, wenn wir nicht aufpassen:\n\nCode# Wurzel aus 2, ganz harmlos\nsqrt(2)\n#> [1] 1.414214\n\n# Quadrierte Wurzel aus 2 ergibt 2, ja, kommt hin\nsqrt(2)^2\n#> [1] 2\n\n# Das sollte ja dann…\nsqrt(2)^2 == 2\n#> [1] FALSE\n\n\nWait, what?\nUnd das ist der Grund warum Fließkommazahlen (double) seltsam sind.\nDie kurze Version: \\(\\sqrt{2}\\) ist eine irrationale Zahl, das heißt sie hat unendlich viele Nachkommastellen. Computer können nur eine begrenzte Anzahl an Nachkommastellen speichern, weshalb das Resultat von einer Berechnung wie \\(\\left(\\sqrt{2}\\right)^2\\) zwar für alle praktischen Zwecke immer noch 2 ist, aber irgendwie auch nicht. Wenn wir mit Datensätzen arbeiten und darin rumrechnen dann sind solche kleinen Rundungsfehler egal, aber wenn wir uns auf Operatoren wie == verlassen, um berechnete Werte zu vergleichen, dann müssen wir vorsichtig sein.\nAn dieser Stelle ein kurzer Exkurs in die Numerik:\nDie absolut kleinste Toleranz, die euer Computer für Fließkommazahlen berücksichtigt, könnt ihr euch mit .Machine$double.eps anzeigen lassen2. .Machine ist ein besonderes Objekt in R, dass Informationen zu eurem Computer (sprich eurer Maschine) sammelt.\n\nCode# Wie groß ist die Abweichung vom erwarteten Ergebnis?\nsqrt(2)^2 - 2\n#> [1] 4.440892e-16\n\n\n4.4408920985e-16 ist Computer für \\(4.4408920985 \\cdot 10^{-16}\\), also ungefähr…\n\\[\\frac{4.4408920985}{10000000000000000} \\approx 0.00000000000000044\\]\nDas ist… ziemlich wenig, und im Alltag auch ziemlich egal, aber wie gesagt: Für R ist das ein Unterschied.\n\nCode# Wie groß ist die Toleranz?\n.Machine$double.eps\n#> [1] 2.220446e-16\n\n# Moment mal…\n.Machine$double.eps * 2\n#> [1] 4.440892e-16\n\n# Wenn jetzt…\n(.Machine$double.eps * 2) == (sqrt(2)^2 - 2)\n#> [1] TRUE\n\n\nTatsache.\nWir könnten noch weiter damit rumspielen, aber als Lektion sollte eigentlich nur hängenbleiben, dass Zahlen in R gerne mal mehr sind, als euch in der Konsole angezeigt wird.\n\n\n\n\n\n\nNote\n\n\n\n\nOne does not simply round floating point numbers — Programmer Boromir\n\n\n\nWenn ihr mal auf sowas stoßen solltet, dann verwendet am besten einfach die Funktion round() um eure Werte auf eine sinnvolle Anzahl Nachkommastellen zu runden:\n\nCode# Auf 5 Stellen gerundete Wurzel 2\nround(sqrt(2), digits = 5)\n#> [1] 1.41421\n\n# Gerundetes Ergebnis von \"Wurzel 2 hoch 2\"\nround(sqrt(2)^2, digits = 5)\n#> [1] 2\n\n# Literally close enough.\nround(sqrt(2)^2, digits = 5) == 2\n#> [1] TRUE\n\n\n\n\n\n\n\n\nNote\n\n\n\nIm Zweifelsfall einfach Genauigkeit opfern um den Verstand zu behalten\n\n\nTheoretisch ist “numeric” für Zahlen eine Klasse, und integer und double sind die beiden Typen, aus denen die Klasse besteht."
  },
  {
    "objectID": "chapters/05-datentypen.html#character-buchstabenzeugs",
    "href": "chapters/05-datentypen.html#character-buchstabenzeugs",
    "title": "\n6  Datentypen\n",
    "section": "\n6.2 Character (Buchstabenzeugs)\n",
    "text": "6.2 Character (Buchstabenzeugs)\n\nCharacters sind Strings sind irgendwas was aus mehr als nur Zahlen besteht (zumindest meistens). Die Unterscheidung zwischen numeric und character ist intuitiv ziemlich einfach, und in eurer statistischen Praxis werdet ihr vermutlich meistens auf numerics treffen, wobei characters dann meistens nur für nominale Variablen (Gruppenzugehörigkeiten, Entscheidungen für A, B, C) gebraucht werden. Tatsächlich werden eure nominalen Variablen sogar eher als factor daherkommen, dazu dann der nächste Abschnitt.\nCharacters verhalten sich im Grunde wie Worte. Wir können sie aneinanderhängen, wir können sie vergleichen, aber wir können zum Beispiel keine Berechnungen damit durchführen:\nnamen <- c(\"Lukas\", \"Tobias\", \"Christoph\")\nmean(namen)\n#> Warning in mean.default(namen): argument is not numeric or logical:\n#> returning NA\n#> [1] NA\n\n# Zahlen != Buchstaben\n5 == \"5\"\n#> [1] TRUE\n\n# Groß- / Kleinschreibung ist wichtig!\n\"Lukas\" == \"Lukas\"\n#> [1] TRUE\n\"Lukas\" == \"LUKAS\"\n#> [1] FALSE\n\n# Strings aneinanderhängen\npaste(\"Lukas\", \"hat\", \"Spass\", sep = \"_\")\n#> [1] \"Lukas_hat_Spass\"\nDie Funktionen paste und paste0 sind ziemlich praktisch wenn ihr mit Strings arbeitet, die werdet ihr früher oder später mal brauchen.\nAnsonsten dürfte euch aufgefallen sein, dass man Spaß mit ß schreibt. Das ist korrekt. Allerdings zählt ß als Sonderzeichen, genauso wie Umlaute (üöä). R kann damit zwar prinzipiell umgehen, solange ihr das richtige Encoding verwendet, aber dennoch bietet es sich an auf Sonderzeichen in R-Code zu verzichten, um Inkompatibilität mit anderen vorzubeugen.\nUm eure Einstellungen anzupassen und auf Nummer sicher zu gehen, öffnet die Einstellungen von RStudio und setzt die folgende Einstellung auf UTF-8 (Unicode):\n\n\n\n\nRStudio > Optionen > Code > Saving: UTF-8\n\n\n\n\nEncoding ist so der einfachste Grund aus dem eure Scripte und Dokumente auf einmal kaputt aussehen, wenn ihr sie von einem Windows-Rechner an einen Mac oder eine Linux-Kiste schickt. Mac und Linux können sich wenigstens meistens auf Unix-Standards und Unicode eignen, aber Windows… Windows ist seltsam.\n\n\n\n\n\n\nNote\n\n\n\nEncoding ist kodifizierter Selbsthass, aber Unicode ist großer Spaß"
  },
  {
    "objectID": "chapters/05-datentypen.html#factor-here-be-dragons",
    "href": "chapters/05-datentypen.html#factor-here-be-dragons",
    "title": "\n6  Datentypen\n",
    "section": "\n6.3 Factor (Here be dragons)\n",
    "text": "6.3 Factor (Here be dragons)\n\nOkay, der haarige Teil.\nDie factor-Klasse in R ist unheimlich praktisch, aber auch ziemlich unintuitiv bei der ersten Verwendung. Das liegt nicht zuletzt daran, dass ein factor von aussehen meistens einfach aussieht wie ein character, aber nunmal kein character ist.Factors haben zwei Bestandteile:\n\n\nlevel: Die Merkmalsausprägung, so wie R den factor sieht. Meistens numeric.\n\nlabel: (Optional) Die Bezeichnung der Merkmalsausprägungen, meistens character, für die bessere Lesbarkeit.\n\nEin Beispiel aus dem sleep-Datensatz:\n\nCode# Die Vairable \"group\"\nsleep$group\n#>  [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2\n#> Levels: 1 2\n\n# …hat die Klasse \"factor\"\nclass(sleep$group)\n#> [1] \"factor\"\n\n# Und die levels…\nlevels(sleep$group)\n#> [1] \"1\" \"2\"\n\n\nWir sehen, dass group die Merkmalsausprägungen (levels) 1 und 2 hat, aber das ist für uns möglicherweise nicht wirklich aussagekräftig. Wir können die Variable modifizieren, und einen schöneren factor daraus machen:\n\nCode# Wir modifizieren nur die labels, nicht die level\nsleep$group <- factor(sleep$group, levels = c(1, 2), labels = c(\"Medikament A\", \"Medikament B\"))\n\n# Jetzt werden uns unsere Labels angezeigt\nsleep$group\n#>  [1] Medikament A Medikament A Medikament A Medikament A Medikament A\n#>  [6] Medikament A Medikament A Medikament A Medikament A Medikament A\n#> [11] Medikament B Medikament B Medikament B Medikament B Medikament B\n#> [16] Medikament B Medikament B Medikament B Medikament B Medikament B\n#> Levels: Medikament A Medikament B\n\n# Und unsere unveränderten Levels\nlevels(sleep$group)\n#> [1] \"Medikament A\" \"Medikament B\"\n\n# Aber wir können den factor immer noch wie Zahlen behandeln\nas.numeric(sleep$group)\n#>  [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2\n\n\nMit factor können wir praktisch zwei Lagen an Informationen in nur einer Variable speichern, einmal numerische levels und einmal character labels. Die Levels sind die eigentlich wichtige Information und die Labels sind praktisch nur für uns zur besseren Lesbarkeit da, zum Beispiel bei Tabellen oder Grafiken."
  },
  {
    "objectID": "chapters/05-datentypen.html#besondere-typen",
    "href": "chapters/05-datentypen.html#besondere-typen",
    "title": "\n6  Datentypen\n",
    "section": "\n6.4 Besondere Typen",
    "text": "6.4 Besondere Typen\nEure Daten kommen meistens von anderen, zumindest in den ersten Semestern eures Studiums.\nMeistens kommen eure Daten auch mit Fehlenden oder irgendwie kaputten Werten, mit denen ihr ohne Weiteres nichts anfangen könnt.\n\n6.4.1 Fehlende Werte: NA\n\nVermutlich der wichtigste Datentyp, der euch begegnen wird. NA steht für Not Available und heißt, dass es an dieser Stelle einfach keinen Wert gibt. In einem Fragebogen wäre das zum Beispiel eine nicht ausgefüllte Frage, und das heißt für euch, dass ihr ohne Weiteres keine Annahme über diese Wert machen könnt. NA heißt nicht “da ist nichts”, sondern eher “da könnte was sein, aber ich weiß nicht”.\nDas ist auch der Grund, warum der Mittelwert nicht funktioniert, wenn da NA drinstecken:\n\nCodemean(c(1, 2, NA, 4, 5, NA, 7))\n#> [1] NA\n\n\nKlar könnten wir einfach annehmen, dass die fehlenden Werte 3 und 6 sind, aber das wissen wir nunmal nicht, und da R in der Regel nicht rät, sagt es halt auch “weiß nicht” in Form von NA.\nIn solchen Fällen müsst ihr explizit NA ignorieren:\n\nCodemean(c(1, 2, NA, 4, 5, NA, 7), na.rm = TRUE)\n#> [1] 3.8\n\n\nIhr könnt auch mit der Funktion is.na prüfen, ob ihr fehlende Werte habt. Beachtet, dass == zum vergleichen nicht funktioniert!\n\nCodezahlen <- c(1, 2, NA, 4, 5, NA, 7)\n\nis.na(zahlen)\n#> [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE\n\n# Alle 'zahlen', für die is.na() _nicht_ TRUE ist\nzahlen[!is.na(zahlen)]\n#> [1] 1 2 4 5 7\n\n# An welcher Position sind die NAs?\nwhich(is.na(zahlen))\n#> [1] 3 6\n\n\n\n6.4.2 Leere Werte: NULL\n\nWenn NA fehlende Werte sind, was soll dann NULL sein?\nNaja, ich merke mir das immer ungefähr so:\n\n\nNULL: Da ist nichts, also so wirlich nichts, und ich weiß das auch!\n\nNA: Da ist zwar nichts, aber ich hab keine Ahnung ob da nicht doch was sein sollte ¯\\_(ツ)_/¯\n\nNULL wird euch vermutlich weniger häufig begegnen als NA, zumindest in Datensätzen.\nAnsonsten taucht NULL eher bei R-Funktionen als default argument auf, also ein Argument einer Funktion, das nicht gesetzt ist, außer ihr setzt es explizit. Das klingt jetzt etwas abstrakt, aber wir werden im Laufe dieser Einführung vermutlich noch Beispiele dafür sehen.\n\n\n\n\n\n\nNote\n\n\n\nNULL ist leer, und zwar mir SicherheitNA ist leer, aber man weiß es nicht so recht\n\n\n\n6.4.3 To Inf and BeyoNaNd!\nHabt ihr schonmal durch 0 geteilt? Oder überlegt was \\(0^0\\) ist?\nDas ist die Ecke, in der Inf und NaN auftauchen.\nInf und -Inf stehen erstmal nur für \\(\\infty\\) und \\(-\\infty\\) und sind Rs Weg euch zu sagen, dass ihr da gerade den Bereich der alltagstauglichen Zahlen überschritten habt.\nNehmt mal folgendes Beispiel:\n\nCode# 2 hoch 10… geht noch\n10^10\n#> [1] 1e+10\n\n# Auch das…\n10^100\n#> [1] 1e+100\n\n# Okay, aber jetzt…\n10^1000\n#> [1] Inf\n\n\nDas ist R einfach zu viel, bzw. es ist eurem Computer generell zu viel.\nKurzer reminder: 1e10 ist Computer für \\(1 \\cdot 10^{10}\\), also eine 1 mit 10 Nullen, also…\n\\[1e10 = 1 \\cdot 10^{10} = 10000000000\\]\nDementsprechend könnt ihr euch vorstellen, wie groß \\(10^{1000}\\) wäre, und R macht solche Späße nicht mit und sagt einfach Inf.\nWenn ihr Inf oder -Inf in euren Ergebnissen seht, dann solltet ihr nur wissen, dass es da ein entweder viel zu großes oder viel zu kleines Ergebnis gab.\nUnd dann ist da noch die Sache mit NaN.NaN steht für not a number und passiert dann, wenn ihr irgendwas mathematisch fragwürdiges macht, wie zum Beispiel 0 durch 0 teilen:\n\nCode0 / 0\n#> [1] NaN\n\n\nDas ist mathematisch nicht definiert, und wieso das so ist und mehr dazu findet ihr zum Beispiel bei Numberphile gut erklärt.\nHier solltet ihr auch nur wissen, dass es das gibt und dass ihr es im Zweifelsfall vermeiden wollt, wenn es in euren Ergebnissen auftaucht."
  },
  {
    "objectID": "chapters/05-datentypen.html#tabellen-data.frame",
    "href": "chapters/05-datentypen.html#tabellen-data.frame",
    "title": "\n6  Datentypen\n",
    "section": "\n6.5 Tabellen: data.frame\n",
    "text": "6.5 Tabellen: data.frame\n\nAll eure Datensätze im Studium kommen in Tabellenform.\nTabellen in R sind im Grunde nichts anderes als Listen von Vektoren mit gleiche Länge: Der sleep-Datensatz zum Beispiel besteht aus drei Vektoren der Länge 20, und jede Spalte verhält sich wie ein Vektor mit bestimmten Typen.\nUm sich einen Überblick über einen Datensatz zu verschaffen empfiehlt sich die Funktion str (lies structure), oder auch head:\n\nCode# Die ersten paar Zeilen\nhead(sleep)\n#>   extra        group ID\n#> 1   0.7 Medikament A  1\n#> 2  -1.6 Medikament A  2\n#> 3  -0.2 Medikament A  3\n#> 4  -1.2 Medikament A  4\n#> 5  -0.1 Medikament A  5\n#> 6   3.4 Medikament A  6\n\n# Nur die ersten 2 Zeilen\nhead(sleep, n = 2)\n#>   extra        group ID\n#> 1   0.7 Medikament A  1\n#> 2  -1.6 Medikament A  2\n\n# Struktur des Datensatzes\nstr(sleep)\n#> 'data.frame':    20 obs. of  3 variables:\n#>  $ extra: num  0.7 -1.6 -0.2 -1.2 -0.1 3.4 3.7 0.8 0 2 ...\n#>  $ group: Factor w/ 2 levels \"Medikament A\",..: 1 1 1 1 1 1 1 1 1 1 ...\n#>  $ ID   : Factor w/ 10 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10 ...\n\n\nDas Output von str sagt euch alles, was ihr braucht:\n\nDie Klasse des Objekts, hier ein data.frame, das Tabellenformat\n\nDie Anzahl der Zeilen (20 obs.), und Spalten (3 variables)\n\n\nDie Spalten der Tabelle mit den ersten Werten\n\n\nextra: Numerisch (num)\n\ngroup: factor mit 2 Merkmalsausprägungen (w/ 2 levels), die Labels und die Levels\n\n\nID: factor mit 10 Labels (\"1\", \"2\", \"3\" …) und Levels (1 2 3 4 …)\n\n\n\nSpäter werden wir noch andere Klassen für Tabellen sehen, die data.frame erweitern bzw. etwas aufhübschen, namentlich wird das tbl_df bzw. tibble sein, aber dazu müssen wir uns erst Packages ansehen."
  },
  {
    "objectID": "chapters/05-datentypen.html#convert",
    "href": "chapters/05-datentypen.html#convert",
    "title": "\n6  Datentypen\n",
    "section": "\n6.6 Prüfen & Konvertieren",
    "text": "6.6 Prüfen & Konvertieren\nWas wir im Abschnitt zu factor am Ende mit as.numeric gemacht haben fällt unter Coercion, und heißt, dass Werte eines Typs in einen anderen Typ konvertiert werden sollen. Das Gegenstück dazu wäre is.numeric, was nachsieht, ob eine Variable bereits numeric ist.\n\nCodeas.numeric(\"5\")\n#> [1] 5\nas.numeric(5)\n#> [1] 5\n\nis.numeric(\"5\")\n#> [1] FALSE\nis.character(10)\n#> [1] FALSE\n\nas.character(c(2, 5, 4, 3))\n#> [1] \"2\" \"5\" \"4\" \"3\"\n\n\nEs gibt etliche solcher Konvertierungsfunktionen in R, manche mehr oder weniger nützlich, aber nun gut, sie sind da:\n\nCode# Römische Zahlen\nas.roman(2017)\n#> [1] MMXVII\n\n# Hexadezimal\nas.hexmode(255)\n#> [1] \"ff\"\n\n# Logische Werte\nas.logical(0)\n#> [1] FALSE\nas.logical(1)\n#> [1] TRUE"
  },
  {
    "objectID": "chapters/06-packages.html",
    "href": "chapters/06-packages.html",
    "title": "\n7  Packages\n",
    "section": "",
    "text": "Fast jede Software hat Erweiterungen irgendeiner Art. Manche haben extensions, andere plug-ins, wieder andere haben add-ons. Unterschiedliche Terminologie für dasselbe Prinzip: Mehr Features durch Erweiterungen anderer Leute.\nBei Programmiersprachen heißt sowas meistens library oder package1.\nR hat sowas natürlich auch, als populäre open-source Software. Hier heißt sowas packages und besteht aus Funktionen, die andere Leute für bestimmte Anwendungsfälle geschrieben haben, und durch ein Verteilungssystem verfügbar machen, sodass wir alle sie benutzen können.\nDer Kern von R wird auch base genannt und umfasst die wichtigstens Grundfunktionen — mit denen kommen wir auch schon relativ weit, wir können zum Beispiel problemlos diverse Statistiken berechnen und sogar Visualisierungen machen, aber wir wollen natürlich mehr, einfacher, schneller und besser."
  },
  {
    "objectID": "chapters/06-packages.html#installieren-laden-updaten",
    "href": "chapters/06-packages.html#installieren-laden-updaten",
    "title": "\n7  Packages\n",
    "section": "\n7.1 Installieren, Laden, Updaten",
    "text": "7.1 Installieren, Laden, Updaten\nPackages ladet ihr aus dem Internet runter, woraufhin sie ggf. kompiliert und in eure R-library eingepflegt werden müssen.\nDas klingt kompliziert, und deshalb passiert das auch alles automatisch!\nWir installieren ein package mit einem einfachen Befehl in der Konsole:\ninstall.packages(\"ggplot2\")\n\n\n\n\n\n\nNote\n\n\n\nWindows-BenutzerInnen: Wenn ihr Antivirus-Software benutzt (Norton, Kaspersky, whatever) kann es sein dass diese euch beim installieren stört. Ihr bekommt dann wenig aussagekräftige Fehler. Schaltet eure Antivirus-Software aus wenn ihr Probleme bei der Installation habt.\n\n\nAchtet darauf, dass ihr Groß- und Kleinschreibung beachtet habt, und dass der Name des packages in \" \" steht (wie ein character).\nWenn ihr Enter gedrückt habt sollte R anfangen loszurödeln, vielelicht gehen auch einige Fenster mit Fortschrittsbalken auf, wenn ihr Windows benutzt.\nDas schöne an diesem Befehl ist, dass es auch direkt alle packages installiert, die wir in unserem package benutzen: Sogenannte dependencies. Eine dependency (Abhängigkeit) ist in diesem Kontext ein package, das von einem anderen package gebraucht wird um zu funktionieren. Wir benutzen im package tadaatoolbox zum Beispiel auch die packages dplyr, pixiedust und sjlabelled, deswegen sollte der Befehl diese packages auch gleich mitinstallieren.\nAlternativ könnt ihr rechts in RStudio im “Packages”-Tab den “Install”-Button drücken, den namen des packages (tadaatoolbox) eingeben, und dann macht RStudio im Hintergrund genau dasselbe Spielchen mit install.packages().\nIn diesem Fenster ist auch von Repositories die Rede. Damit ist der Web-Adresse gemeint, von der die packages geladen werden sollen. RStudio sollte da automatisch die schnellste Quelle auswählen, aber wenn ihr mal in die Verlegenheit kommt euch entscheiden zu müssen, versucht am besten folgende Adresse:\nhttps://cloud.r-project.org\nUnd da packages auch nur Software sind, und Software auf dem aktuellen Stand gehalten werden will, bietet es sich an sporadisch (spätestens alle paar Monate) mal den Update-Button zu drücken und einfach alles zu aktualisieren, was aktualisiert werden kann.\nDas könnt ihr auch aus der Konsole heraus machen indem ihr den Befehl update.packages(ask = FALSE) ausführt. R fragt euch dann, ob ihr sicherheitshalber R neustarten wollt, das könnt ihr tun oder auch nicht, aber wenn ihr es nicht tut, dann solltet ihr auf jeden Fall die R-Session neu starten nachdem ihr alle Updates gemacht habt (RStudio -> Session -> Restart R).\nWieso? Nun ja, packages werden von R geladen, das heißt verfügbar gemacht, und wenn ihr ein package ersetzt (was beim Update passiert), dann zieht ihr damit R praktisch den Boden unter den Füßen weg und es ist sauer weil Dinge anders sind, als sie eben noch waren.\nDieses “verfügbar machen” sieht übrigens so aus:\nlibrary(ggplot2)\nWenn ihr diesen Befehl ausgeführt hat, dann läd R für die aktuelle Session das package und ihr könnt die Funktionen darin benutzen.\nNormalerweise beginnen eure R-Scripte mit einer Reihe von library()-Befehlen um eure Analyse vorzubereiten und alle benötigten packages zu laden, da ihr diesen Schritt jedes mal wiederholen müsst, wenn ihr eine neue R-Session starten (z.B. beim Neustart von RStudio, Computerneustart etc.).\nAußerdem gebt ihr so euren KommilitonInnen eine gute Gelegenheit abzuschätzen, was in eurem Script so passiert, wenn sie direkt erkennen können, welche packages ihr dafür benutzt habt.\nEs gibt tausende R-packages, und die meisten davon sind für euch vollkommen uninteressant, aber einige wiederum sind so dermaßen praktisch, dass wir sie uns hier im Detail anschauen.\n\n7.1.1 Quellen\nDie wichtigste Quelle für R-packages ist das erwähnte CRAN, kurz für “Comprehensive R Archive Network”. Packages müssen diverse Anforderungen erfüllen, um auf CRAN publiziert zu werden, was eine gewisse Hürde darstellt. Deswegen gibt es diverse packages, die gerade in frühen, potenziell noch nicht ausgereiften Versionen an anderen Stellen verfügbar gemacht werden.\nDie wohl populärster dieser Sekundärquellen ist GitHub.\nOptional könnt ihr packages auch direkt von GitHub installieren, was insbesondere dann interessant ist, wenn das package noch jung und experimentell ist.\nIn euren normalen Projekten solltet ihr euch nicht auf GitHub-packages verlassen, sondern nach Möglichkeit ausschließlich packages von CRAN benutzen, aber wenn euch nach Abenteuer ist, dann fühlt euch frei:\n# Wir brauchen das devtools package\ninstall.packages(\"remotes\")\n\n# remotes package laden\nlibrary(remotes)\n\n# install_github ist eine Funktion aus dem remotes package\ninstall_github(\"tadaadata/tadaatoolbox\")\n\n7.1.2 Maintenance\nPackages installieren ist einfach, aber wie jede Software wollen auch R-packages auf dem neusten Stand gehalten werden. Oder zumindest auf einem “nicht total veraltet”-Stand.\nUpdaten ist ziemlich einfach:\nEntweder ihr klickt im “Packages”-Tab von RStudio auf den “Update”-Button, wählt alle Packages aus und installiert die Updates so, oder ihr gebt in der Konsole folgendes ein:\nupdate.packages(ask = FALSE)\n…dann rödelt R die Updates durch. RStudio wird euch an dieser Stelle fragen, ob ihr die R-Session vorher neustarten wollt – das könnt ihr tun, aber er könnt damit auch warten bis ihr alle Updates installiert habt anstatt für jedes einzelne Update die Session neuzustarten.\nWichtig ist auf jeden Fall, dass ihr die R-Session neustartet bevor ihr weiter arbeitet.\n\n\n\n\n\n\nNote\n\n\n\nWenn ein package geladen (library()) ist während ihr Updates durchführt, muss die R-Session danach neugestartet werden! Wenn ein package aktualisiert wird während es geladen ist macht das R sehr traurig und Fehler treten auf.\nRStudio –> Session –> Restart R\n\n\nSolltet ihr mal ein package löschen wollen, aus welchem Grund auch immer, dann geht das entweder auch über den Package-Tab in RStudio (das Kreuzchen rechts neben dem Namen des packages), oder ihr gebt folgendes in der Konsole ein:\nremove.packages(\"ggplot2\")\n…um das package ggplot2 zu deinstallieren.\nAber wieso solltet ihr das tun wollen.\nWieso nur.\nIhr Monster.\n\n7.1.2.1 Tabellen\nFür Kreuztabellen, wie wir sie relativ häufig in QM1 brauchen für unsere nominal- und ordinalskalierten Statistiken:\n\n\n\nOder einfache Häufigkeitstabellen:\nUnd für lineare Modelle, in deutlich schöner als summary():\n\nCodemodel <- lm(zufrieden ~ alter * berufsvorstellung, data = qmsurvey)\n\n\n\n7.1.2.2 Plots\nKlassiker: Histogramm mit Normalverteilungskurve:"
  },
  {
    "objectID": "chapters/06-packages.html#das-tidyverse",
    "href": "chapters/06-packages.html#das-tidyverse",
    "title": "\n7  Packages\n",
    "section": "\n7.2 Das tidyverse\n",
    "text": "7.2 Das tidyverse\n\nDas tidyverse ist eine Ansammlung von packages, die alle mehr oder weniger gut miteinander auskommen und auf ähnliche Art zu benutzen sind.\nEine Übersicht und ganz viel Dokumentation und Beispiele findet ihr auf https://tidyverse.org.\nEs gibt ein catchall R-package, das die wichtigstens packages für euch installiert:\ninstall.packages(\"tidyverse\")\nIhr könnt danach entweder das package laden und habt damit die wichtigsten Funktionen parat, oder ihr ladet die packages nach Bedarf einzeln.\nIch würde zu letzterem raten, weil ihr so eher ein Gefühl dafür bekommt welches package für welche Funktionen zuständig ist, und nebenbei geht es auch ein bisschen schneller.\nHier eine kurze Übersicht über die wichtigsten tidyverse-packages/Funktionen für alltägliche Aufgaben:\n\n\n%>%: Der pipe-Operator aus magrittr, der von den meisten der packages re-exportiert wird\n\nggplot2: Für Visualisierungen\n\ndplyr: Datenmanipulation\n\n\nmutate: Neue Variablen erstellen/ bestehende Verändern\n\nselect: Variablen auswählen\n\nfilter: Datensätze filtern\n\ngroup_by: Gruppieren…\n\nsummarize: Und zusammenfassen\n\n\n\ntidyr: Datenmanipulation\n\n\ngather: Konvertiert von wide in long format (mehrere Spalten zu zwei zusammenfassen)\n\nspread: Gegenstück, konvertiert von long in wide format"
  },
  {
    "objectID": "chapters/06-packages.html#die-tadaatoolbox",
    "href": "chapters/06-packages.html#die-tadaatoolbox",
    "title": "\n7  Packages\n",
    "section": "\n7.3 Die tadaatoolbox\n",
    "text": "7.3 Die tadaatoolbox\n\nDie tadaatoolbox ist das Produkt von Lukas’ und Tobis Frustration mit diversem Kleinkram in R, wie etwa der Optik von statistischen Testoutput.\nIm Fokus steht in erster Linie schnelles, einfaches Output mit möglichst wenig Aufwand. Zusätzlich bietet die Toolbox einige Sammelfunktionen um beispielsweise diverse nominal- oder ordinalskalierte Statistiken auf einen Rutsch anzuzeigen, optimiert auf Output in RMarkdown-Dokumenten (Siehe [Berichte])."
  },
  {
    "objectID": "chapters/06-packages.html#addendum-installier-mal-alles",
    "href": "chapters/06-packages.html#addendum-installier-mal-alles",
    "title": "\n7  Packages\n",
    "section": "\n7.4 Addendum: “Installier mal alles”",
    "text": "7.4 Addendum: “Installier mal alles”\nHier ein Stück Code, das ihr im Zweifelsfall einfach copypasten könnt.\nEs sollte euch so ziemlich alles oder zumindest das meiste an (vorerst) relevanten packages installieren, und dient mehr so der Vollständigkeit.\ninstall.packages(\"magrittr\")\ninstall.packages(\"ggplot2\")\ninstall.packages(\"dplyr\")\ninstall.packages(\"tidyr\")\ninstall.packages(\"stringr\")\ninstall.packages(\"devtools\")\ninstall.packages(\"forcats\")\ninstall.packages(\"readr\")\ninstall.packages(\"lubridate\")\ninstall.packages(\"purrr\")\ninstall.packages(\"readxl\")\ninstall.packages(\"haven\")\ninstall.packages(\"rvest\")\ninstall.packages(\"scales\")\n\ninstall.packages(\"cowplot\")\ninstall.packages(\"ggrepel\")\ninstall.packages(\"psych\")\ninstall.packages(\"DescTools\")\ninstall.packages(\"ggthemes\")\ninstall.packages(\"hrbrthemes\")\ninstall.packages(\"rmarkdown\")\ninstall.packages(\"viridis\")\ninstall.packages(\"RColorBrewer\")\ninstall.packages(\"nortest\")\ninstall.packages(\"plotly\")\ninstall.packages(\"car\")\ninstall.packages(\"afex\")"
  },
  {
    "objectID": "chapters/07-die-hilfe.html",
    "href": "chapters/07-die-hilfe.html",
    "title": "\n8  Die Hilfe\n",
    "section": "",
    "text": "Wir haben bereits Seiten wie rdrr.io erwähnt, wo ihr euch Dokumentation anschauen könnt. Unter Dokumentation verbirgt sich übrigens nichts weltbewegendes, in der Regel geht es nur darum wie einzelne Funktionen zu benutzen sind. Diese Seiten sind im Wesentlichen aufgebohrte Versionen der Hilfe, die R von Haus aus mitbringt — allerdings mit bells & whistles in Form von schönerer Optik, erweiterter Suchfunktion, Verlinkungen etc.\nDiie Hilfe findet ihr auf der rechten Seite in RStudio, unter dem \"Help\"-Tab:\nIn die Suchleiste oben rechts könnt ihr Suchbegriffe eingeben. Denkt daran, dass die Hilfe in erster Linie auf englisch verfügbar ist."
  },
  {
    "objectID": "chapters/07-die-hilfe.html#format",
    "href": "chapters/07-die-hilfe.html#format",
    "title": "\n8  Die Hilfe\n",
    "section": "\n8.1 Format",
    "text": "8.1 Format\nDie Dokumentation von Funktionen hat immer das gleiche Format mit bestimmtem Pflichtbereichen und mehreren optionalen Abschnitten.\n\n\nDescription: Was macht die Funktion?\n\nUsage: Wie benutzt man die Funktion?\n\nValue: Was kommt dabei raus?\n\nSee Also: Welche anderen Funktionen sind verwandt?\n\nExamples: Anwendungsbeispiele"
  },
  {
    "objectID": "chapters/07-die-hilfe.html#sprache",
    "href": "chapters/07-die-hilfe.html#sprache",
    "title": "\n8  Die Hilfe\n",
    "section": "\n8.2 Sprache",
    "text": "8.2 Sprache\nDie R-Hilfe ist primär auf englisch verfügbar.\nWenn euch das überrascht, dann geht mal vor die Tür.\nZusätzlich ist die Hilfe meistens von den AutorInnen der jeweiligen Packages/Funktionen geschrieben, was zwar den Vorteil hat, dass sie in der Regel zumindest inhaltlich korrekt ist, aber für Laien manchmal nur so mäßig verständlich ist, was da jetzt eigentlich genau gesagt wird.\nHäufig werden Begriffe verwendet, die für euch womöglich eher fremd erscheinen, weil ihr vermutlich keinen Hintergrund in der Programmierung / Numerik / whatever habt, aber keine Angst. Früher oder später lernt ihr die Begriffe, die relevant sind, und wenn ihr mal was so gar nicht versteht, dann fragt ihr eben einfach bei TutorInnen nach, googlet den Quatsch, oder ignoriert es einfach und versucht halt so weiter zu kommen."
  },
  {
    "objectID": "chapters/08-datenimport.html",
    "href": "chapters/08-datenimport.html",
    "title": "\n9  Datenimport\n",
    "section": "",
    "text": "Im Laufe eures Studiums (und vermutlich darüberhinaus) werdet ihr sehr viel Zeit damit verbringen Daten aus verschiedenen Quellen in die Statistiksoftware eurer Wahl (oder auch nicht eurer Wahl, aber der eurer Arbeitstselle) zu quetschen.\nDas funktioniert mal mehr und mal weniger einfach, denn je nachdem wie die Originaldaten aussehen, kann das mitunter anstrengend bis deprimierend werden.\nSaubere (tidy) Daten sehen immer gleich aus, aber unsaubere Daten sind alle auf ihre eigene Art unsauber. Mal fehlen Variablenbeschriftungen, mal sind da Umlaute durch Encoding kaputtgegangen, manchmal werden numerische Werte als character interpretiert und manchmal sind fehlende Werte mit irgendwelchen willkürlichen Werten kodiert (z.B. -99 anstatt NA).\nVielleicht wundert ihr euch auch, wieso dieses Kapitel erst so spät in dieser Einführung auftaucht. Das liegt primär daran, dass ihr unter Umständen ein ausreichend großes Repertoire an Grundlagen braucht, um Daten auf alle Fälle sauber eingelesen zu bekommen.\nIn vielen Fällen, und besonders in QM, ist das Ganze noch relativ überschaubar und eure TutorInnen können entsprechende Hilfestellung bieten, aber irgendwann seid ihr auf euch allein gestellt, und dann macht ein bisschen Bonus-Wissen hier und da den Unterschied zwischen einem anstrengenden Nachmittag voller Leid und Schmerz oder 10 Minuten Probiererei und schnellem Erfolg.\nWenn ihr Daten von eurer Festplatte einlesen wollt, und ihr keine Ahnung habt wie Dateipfade funktionieren, was euer Home Ordner ist, was beispielsweise ~/Documents sein soll oder wie ihr rausfindet, wo ihr gerade auf euren Computern seid, dann lest euch das bitte selber an.\nAuch hier liefert RStudio jedenfalls im “Files”-Tab entsprechende Orientierungshilfe:\nDas rot umrandete ist der Pfad zum Projektordner, in R würde ich den also so eingeben müssen:\nWobei die Tilde ~ eine Abkürzung für das Home-Verzeichnis ist."
  },
  {
    "objectID": "chapters/08-datenimport.html#quellen",
    "href": "chapters/08-datenimport.html#quellen",
    "title": "\n9  Datenimport\n",
    "section": "\n9.1 Quellen",
    "text": "9.1 Quellen\nDa in QM nur SPSS und R benutzt werden, werdet ihr vermutlich meistens auf Datensätze aus SPSS (.sav) stoßen. R kann zwar SPSS-Daten einlesen, aber SPSS kann mit R-Daten nichts anfangen. Außerdem beinhalten SPSS-Datensätze auch ein bisschen Metadaten, wie zum Beispiel Labels für eure Variablen oder nominalskalierte Variablen, die wir in R dann für bessere Optik benutzen können — andere Formate wie Textdateien (.csv, .txt, plain text) sind spartanischer und haben sowas nicht.\nDie einfachste Option ist meistens die RStudio-Funktio zum Datenimport, aber auch hier solltet ihr erstmal wissen, wo eure Daten herkommen und ggf. über die ein oder andere Eigenart bescheid wissen.\n\n\n\n\nRStudio Import-Tool\n\n\n\n\nBei den Textdateien sind mit base und readr die beiden unterschiedlichen Möglichkeiten gemeint, mit denen wir Daten einlesen können, aber mehr dazu im entsprechenden Abschnitt.\nEine Sache noch zum Encoding: Um kaputte Umlaute und andere Krämpfe zu vermeiden bietet es sich an, überall alles immer auf Unicode bzw. UTF-8 zu stellen wenn ihr irgendwo nach Encoding gefragt werdet.\n\n9.1.1 Roher Text (.csv, .txt)\n\nBenötigte packages: readr\n\nAnstrengend? Entweder alles super oder Riesenkrampf\n\nEinfacher Text (plain text) ist die einfachste Möglichkeit Datensätze zu speichern bzw. zu übertragen, da Text so ziemlich der kleinste gemeinsame Nenner jeder gängigen Software ist. CSV heißt auch nur “comma separated values”, und wird euch vermutlich noch häufiger begegnen. Eine CSV-Datei könnt ihr mit jedem beliebigen Texteditor öffnen (ihr müsst dafür kein Office rauskramen, auf Windows tut es auch das Notepad), und ihr seht dann vermutlich sowas in der Art:\n\"extra\",\"group\",\"ID\"\n0.7,\"1\",\"1\"\n-1.6,\"1\",\"2\"\n-0.2,\"1\",\"3\"\n-1.2,\"1\",\"4\"\n-0.1,\"1\",\"5\"\n3.4,\"1\",\"6\"\nDas Prinzip ist ziemlich einfach: In der ersten Zeile stehen die Variablennamen, und in jeder folgenden Zeile steht jeweils der Wert der zugehörigen Variable, getrennt durch ein Komma.\nDie Schwierigkeit kommt dann, wenn die Werte zum Beispiel Text enthalten, der wiederum ein Komma enthalten kann, und der Wert nicht richtig in Anführsungszeichen gesetzt ist. Es gibt auch noch Varianten mit Tabs statt Kommata als Trennzeichen, das wäre dann strenggenommen TSV (ihr dürft raten wofür das T steht).\nTextformate sind also ziemlich einfach um eure Daten zu speichern oder zu verschicken, aber es ist auch sehr fragil, sobald mal irgendwo ein \" fehlt oder zu viel ist, wird’s kompliziert.\nZum lesen und schreiben empfehle ich herzlichst das readr-package mit den Funktionen read_csv, write_csv etc. zu benutzen, die sind weniger anfällig für Murks als die base-Standardfunktionen mit gleichem Namen aber . statt _ (read.csv, write.csv).\nAls Beispiel laden wir mal diesen schönen Game of Thrones-Datensatz:\n\nCodelibrary(readr)\ngotdeaths <- read_csv(\"data/got_deaths.csv\")\n\nhead(gotdeaths)\n\n\nHier habe ich col_types = cols() nur benutzt, um das Output zu unterdrücken. Ihr könnt über dieses Argument aber auch manuell spezifizieren, welchen Typ jede Spalte haben soll, damit eure Daten explizit so eingelesen werden, wie ihr sie erwartet.\nDie schmutzigen Details gibt’s natürlich in der Hilfe: ?read_csv und online.\n\n9.1.2 SPSS (.sav)\n\nBenötigte packages: haven.\nAnstrengend? Manchmal.\n\nlibrary(haven)\n\nngo <- read_spss(\"data/NGO.SAV\")\nDie Funktionen read_sav und read_spss sind identisch.\n\n9.1.3 R (.rds, .rda & .RData)\n\nBenötigte packages: Keins (Base R reicht, optional readr als Alternative)\nAnstrengend? Nope, alles tutti.\n\nDer wohl einfachste und dankbarste Anwendungsfall: Von R zu R.\nHier habt ihr zwei Möglichkeiten: .rds und .rda (auch .RData): Generell scheint .rds die präferierte Option zu sein.\n\n9.1.3.1 .rds\n\nDaten einlesen ist simpel:\n\nCodeqmsurvey <- readRDS(\"data/qm_survey_ss2017.rds\")\n\ntibble::as_tibble(qmsurvey)\n\n\nWir benutzen hier das tibble package nur, damit der Datensatz kompakter angezeigt wird. Das ist für euch keine Notwendigkeit, aber ich empfehle es in der Regel gerne, weil euch so nicht die Konsole vollgeklatscht wird, wenn ihr euch euren Datensatz mal schnell anschauen wollt.\nDaten speichern auch:\nsaveRDS(datensatz, \"pfad/zur/datei.rds\")\nHier zum Beispiel der Datensatz zur Tutoriumsteilnahme, den ihr von https://public.tadaa-data.de/data/participation.rds runterladen könnt:\nparticipation <- readRDS(\"~/Downloads/participation.rds\")\nAlternativ könnt ihr das readr-package benutzen. Die Funktion daraus sieht fast gleich aus, und macht auch exakt das gleiche wie readRDS. Der einzige Grund für read_rds ist die Konsistenz der Funktionsnamen.\nlibrary(readr)\n\nparticipation <- read_rds(\"~/Downloads/participation.rds\")\n\n9.1.3.2 .rda, .RData\n\nNein, ihr benutzt nicht save und load für einzelne Datensätze.\nBei .rda bzw. .RData-Dateien ist zu beachten, dass diese den Namen des Objekts gleich mitspeichern, das heißt ihr müsst den eingelesenen Datensatz keinen Namen geben — der kommt schon mit der Datei.\nTheoretisch kann so eine Datei auch mehrere Variablen enthalten, und wenn ihr zum Beispiel RStudio schließt und wieder öffnet, dann werden in der Zwischenzeit auch eure Variablen der aktuellen Session in Form einer .RData-Datei im Projektordner abgelegt und beim nächsten Start wieder eingelesen.\nload(\"pfad/zur/datei.rda\")\n\n# Oder…\nload(\"pfad/zur/datei.RData\")\nSpeichern:\nsave(datensatz, file = \"pfad/zur/Datei.rda\")\n\n9.1.4 Excel (.xlsx)\n\nBenötigte packages: readxl\n\nAnstrengend? Manchmal. Aber wenn, dann richtig.\n\nWenn ihr ein sauberes (i.e. ohne Schnickschnak) Spreadsheet habt in dem auch wirklich nur eure Werte drinstehen, dann ist das Ganze recht simpel und ihr seid mit readxl auch gut bedient.\nWenn ihr einen dreckigen Haufen dampfender Menschenverachtung vor euch habt, dann… viel Spaß.\nEs gibt da das ein oder andere Projekt für die komplexeren Fälle, aber wenn ihr die Möglichkeit habt, macht es euch so einfach (und rechteckig) wie möglich.\n\n9.1.5 Google Sheets\n\nBenötigte packages: googlesheets\n\nAnstrengend? Meistens geht’s ganz gut.\n\nWenn euch Excel zu unpraktisch ist, dann bietet sich Google Sheets an. Es ist kostenlos, einfach und ausreichend mächtig für alles, was ihr so vorhaben könntet — mitunter weil ihr für alle komplexeren Sachen sowieso R benutzen wollt. Sheets ist praktisch wie Excel, nur halt in der CloudTM und von Google, aber für überschaubare Datensammlungen reicht’s auf alle Fälle. Die Tutoriumsteilnahmedaten haben wir da auch gesammelt, und da das Sheet immer an der selben Stelle ist muss man einfach nur den Code zum einlesen und auswerten erneut ausführen und schon hat man eine mehr oder weniger selbstupdatende Analyse. Nett.\nIn besagtem Projekt sieht das zum Beispiel so aus:\nparticipation_1 <- gs_title(\"Tutoriumsteilnehmer\") %>%\n  gs_read(ws = \"WS1516\", range = cellranger::cell_cols(1:7))\nZuerst müsst ihr aber die Authentifizierung mit eurem Google-Account abhandeln:\nlibrary(googlesheets)\n\ngs_ls()\nMit diesem Befehl zeigt euch das package all eure Google Sheets an nachdem es euch nach einem Login gefragt hat, von da aus könnt ihr dann weiterarbeiten. Mehr Informationen und Beispiele gibt’s in der Vignette."
  },
  {
    "objectID": "chapters/08-datenimport.html#daten-angucken-sauber-machen",
    "href": "chapters/08-datenimport.html#daten-angucken-sauber-machen",
    "title": "\n9  Datenimport\n",
    "section": "\n9.2 Daten angucken & sauber machen",
    "text": "9.2 Daten angucken & sauber machen\n\nHappy families are all alike; every unhappy family is unhappy in its own way.\n— Leo Tolstoy\n\n\nand every messy data is messy in its own way - it’s easy to define the characteristics of a clean dataset (rows are observations, columns are variables, columns contain values of consistent types). If you start to look at real life data you’ll see every way you can imagine data being messy (and many that you can’t)!\n— Hadley Wickham (answering ‘in what way messy data sets are messy’) R-help (January 2008)\n\nUm festzustellen, ob eure frisch eingelesenen Daten auch brauchbar sind, empfiehlt sich ein Blick in die Daten via View(daten) bzw. Über einen Klick auf den Datensatz im Environment-Tab von RStudio (das da oben rechts).\nZusätzlich ist auch hier natürlich str() praktisch, um zum Beispiel schnell zu überprüfen, ob eure Variablen auch alle die Klasse haben, die ihr erwartet (alle Zahlen sind numeric und Nominaldaten sind factor oder wenigstens character).\nEs gibt da kein one-size-fits-all Rezept zur Datenbereinigung, denn jeder Datensatz ist auf seine eigene Art dreckig. Ihr könnt nur darauf hoffen, dass euer konkreter Anwendungsfall gut googlebar ist, oder ihr sowas ähnliches schonmal gemacht habt.\nDie gängigsten Probleme sind recoding, umbenennen oder zusammenfassen, und das meiste lässt sich entweder mit dplyr, sjmisc oder ggf. tidyr erledigen. Versucht es erstmal innerhalb des tidyverse, das ist vermutlich angenehmer als zusammengehackte Google-Lösungen. Aber auch hier, wie gesagt: Je nachdem was ihr vorhabt. Mehr dazu findet sich in [Data Munging].\nDatenbereinigung ist entweder sehr einfach oder sehr komplex, oder irgendwo dazwischen. In diesem Sinne: Learning by example und so."
  },
  {
    "objectID": "chapters/10-berichte.html",
    "href": "chapters/10-berichte.html",
    "title": "\n10  Berichte\n",
    "section": "",
    "text": "Scripte schreiben ist schön und gut, aber das was dabei rauskommt ist in erster Linie ein Haufen Konsolen-Output, gespickt mit Plots, die ihr ggf. manuell speichern müsst, und dann wollt ihr das in eure krummen Word-Dokumente stecken und das will doch niemand. In SPSS ist das einfach. Ihr drückt den großen bunten Knopf wo “Mach mal Statistik” draufsteht und dann fallen da PDFs raus. In R ist das anders. Habt ihr vermutlich gemerkt. Das erste Output, das ihr mit R erzeugt wird wahrscheinlich nicht besonders hübsch aussehen — das ist schade, aber es ist nunmal auch die einfachste Art. Was in der Konsole passiert, kann auch problemlos auf großen Servern in der CloudTM passieren und ferngesteuert werden — bei SPSS bleibt euch nur Remotedesktop-Kram. Aber ich schweife ab. Das schöne an R ist jedenfalls die Flexibilität, die wir beim Output haben. Vielleicht habt ihr den Abschnitt zu sjPlot im Kapitel zu [Packages] schon gelesen, und wie die sjt.*-Funktionen hübsche Tabellen produzieren. Diese Tabellen sind HTML — dasselbe Zeug, aus dem Webseiten zusammengesteckt werden, und auch dasselbe Zeug, das so grob auch in Word-Dokumenten steckt. Wir können auch gleich eine ganze Analyse in HTML produzieren, mit Plots an den richtigen stellen und Tabellen in schön!\nWie das funktioniert soll in diesem Kapitel erklärt werden. Als Vorraussetzung bzw. further reading könnt ihr euch bei diesen RStudio-Ressourcen umschauen:"
  },
  {
    "objectID": "chapters/10-berichte.html#markdown",
    "href": "chapters/10-berichte.html#markdown",
    "title": "\n10  Berichte\n",
    "section": "\n10.1 Markdown",
    "text": "10.1 Markdown\nHabt ihr schonmal HTML gesehen? So mit <html><body><p>Hallo Welt</p></body></html>?\nDen Scheiß will kein Mensch per Hand schreiben, wenn’s nur um Text und vielleicht mal Bilder geht.\nDafür gibt es Markdown.\nMarkdown zu lernen wird euch ungefähr 5 Minuten kosten, wenn ihr euch Zeit lasst und zwischendurch nochmal auf Klo geht.\nDer obige Paragraph sieht im Markdown-Rohtext übrigens so aus:\nHabt ihr schonmal HTML gesehen? So mit `<html><body><p>Hallo Welt</p></body></html>`?  \nDen Scheiß will *kein Mensch* per Hand schreiben, wenn's nur um Text und vielleicht mal Bilder geht.  \nDafür gibt es [Markdown](https://rmarkdown.rstudio.com/authoring_basics.html).  \nMarkdown zu lernen wird euch **ungefähr 5 Minuten** kosten, _wenn_ ihr euch Zeit lasst und zwischendurch nochmal auf Klo geht.\nNicht so schwer, oder?\nDas wird übersetzt in folgendes HTML:\n<p>Habt ihr schonmal HTML gesehen? So mit <code>&lt;html&gt;&lt;body&gt;&lt;p&gt;Hallo Welt&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code>?<br />\nDen Scheiß will <em>kein Mensch</em> per Hand schreiben, wenn’s nur um Text und vielleicht mal Bilder geht.<br />\nDafür gibt es <a href=\"https://rmarkdown.rstudio.com/authoring_basics.html\">Markdown</a>.<br />\nMarkdown zu lernen wird euch <strong>ungefähr 5 Minuten</strong> kosten, <em>wenn</em> ihr euch Zeit lasst und zwischendurch nochmal auf Klo geht.</p>\nAnstrengend.\nWas RStudio euch mittels RMarkdown erlaubt ist ein Bericht in Markdown geschrieben, zwischendurch mit R Code Chunks, die von R einfach ausgeführt werden, und am Ende fällt eine HTML-Datei raus, die ihr einfach im Browser öffnen könnt.\nOptional könnt ihr da auch ein PDF rausfallen lassen, aber das erfordert möglicherweise rudimentäre LaTeX-Kenntnisse, und das will ja niemand."
  },
  {
    "objectID": "chapters/10-berichte.html#rmarkdown",
    "href": "chapters/10-berichte.html#rmarkdown",
    "title": "\n10  Berichte\n",
    "section": "\n10.2 RMarkdown",
    "text": "10.2 RMarkdown\nRMarkdown ist R + Markdown. Jip.\nIhr schreibt ganz normales Markdown, und wenn ihr R Code einfügen wollt, setzt ihr da so einen Block rein:\n```{r}\nnrow(sleep)\n```\nUnd in eurem fertigen Dokument landet dann euer Text und der R Code und das Output des R-Codes.\nDiese ganze Einführung ist in RMarkdown geschrieben, inklusive allen Code-Beispiele, Bildern und sowieso, und wenn ihr euch erstmal ein bisschen durch die oben verlinkte Einführung geklickt habt und gesehen habt, dass das gar nicht so schwer ist, werdet auch ihr irgendwann vermutlich lieber RMarkdown benutzen als Word.\nIhr könnt damit loslegen, sobald ihr RMarkdown installiert habt:\n# Für die Grundfunktion\ninstall.packages(\"rmarkdown\")\n\n# Schöne HTML Output-Formate (optional)\ninstall.packages(\"rmdformats\")\n\n# Schöne Präsentationen (Optional)\ninstall.packages(\"revealjs\")\nAlso los, macht mal ein neues RMarkdown-Dokument auf:\n\n\n\n\nNeues Dokument für RMarkdown\n\n\n\n\nSoweit alle mitgekommen? Gut.\nAls nächstes dürft ihr euch was wünschen: Einen Dateinamen und einen AutorInnennamen.\n\n\n\n\nBeliebig ausfüllen und “HTML” ausgewählt lassen\n\n\n\n\nUnd sieheda, ein RMarkdown default document:\n---\ntitle: \"Untitled\"\nauthor: \"Lukas\"\ndate: \"8/15/2017\"\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n## R Markdown\n\nThis is an R Markdown document. Markdown is a simple formatting  \nsyntax for authoring HTML, PDF, and MS Word documents. For more  \ndetails on using R Markdown see <https://rmarkdown.rstudio.com>.\n\nWhen you click the **Knit** button a document will be generated \n that includes both content as well as the output of any embedded  \n R code chunks within the document. You can embed an R code chunk like this:\n\n```{r cars}\nsummary(cars)\n```\n\n## Including Plots\n\nYou can also embed plots, for example:\n\n```{r pressure, echo=FALSE}\nplot(pressure)\n```\n\nNote that the `echo = FALSE` parameter was added to the code  \nchunk to prevent printing of the R code that generated the plot.\nDas könnt ihr jetzt erstmal speichern, vielleicht testhalber etwas reinschreiben und sobald ihr den “Knit”-Button drückt, rödelt RMarkdown im Hintergrund los und spuckt euch ein HTML aus.\nSo einfach.\nJetzt könnt ihr damit beliebig experimentieren, den Text anpassen, eigenen Code reinschreiben und wenn ihr Fragen habt, googlet ihr die einfach solange, bis ihr jemanden findet, der/die die gleiche Frage auch schon hatte und rausgefunden hat wie’s geht.\nOder es steht in der oben verlinkten Dokumentation von RStudio.\nVermutlich letzteres.\n\n10.2.1 Der YAML-Header\nAls nächstes könnt ihr ein bisschen an den Optionen rumspielen:\n\n\n\n\nOutput Optionen für diversen Kram\n\n\n\n\nSo Dinge wie die Dimensionen der ausgegebenen Plots (“figure height/width”), Inhaltsverzeichnis (“Table of Contents”) etc. sind einfach über dieses Menü machbar, alles was irgendwie darüberhinausgeht muss über die Optionen am Anfang des Dokuments gesetzt werden.\nDas oben ist der YAML header. YAML ist auch eine Markup-Sprache wie HTML, und weil es so viele dieser Markup-Sprachen gibt, heißt YAML lang “Yet Another Markup Language”1. Es gibt auch noch HAML und TOML\nIhr erkennt das Muster.\nDer Standard-Header definiert nur die wichtigstens Elemente, aber wir können den unter Anderem durch die Optionen im Menü erweitern. Ein umfangreicheres Beispiel aus einem alten QM-Aufgabenzettel sieht zum Beispiel so aus:\n---\ntitle: \"Aufgabenblatt 5\"\nauthor: \"Lukas\"\ndate: \"Rendered `r format(Sys.time(), '%F %H:%M')`\"\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n    toc_depth: 4\n    highlight: tango\n    fig_width: 9\n    fig_retina: 2\n    theme: yeti\n    code_folding: show\n    df_print: paged\n---\nWas euch da komisch vorkommen könnte ist der Teil mit dem date:. Das rechts daneben ist ein String mit einem inline code chunk, und alles was in RMarkdown zwischen `r und ` steht wird wie R-Code behandelt und ausgeführt, das heißt das Datum des Dokuments wird in diesem Fall automatisch auf format(Sys.time(), '%F %H:%M') gesetzt, was folgendes ergibt:\n\nCodeformat(Sys.time(), \"%F %H:%M\")\n#> [1] \"2022-05-08 17:48\"\n\n\nBoom, Dokument zeigt immer automatisch an, wann es zuletzt generiert (rendered, bzw. knitted) wurde.\nSpitzfindigen Lesenden wird etwas aufgefallen sein: “Aber seltsamer Nerd Mensch”, werden sie sagen, “wenn dieses Dokument hier in RMarkdon geschrieben wurde, und diese inline Code chunks automatisch ausgeführt werden” werden sie feststellen, woraufhin sie sich fragen werden: “wie ist es dann möglich den rohen Code dafür hier reinzuschreiben ohne, dass er ausgeführt wird?” — und dazu, liebe hypothetische Lesende, habe ich eine Antwort: Zero-width non-joiners everywhere, vielleicht ASCII escape characters, und extra `. Ihr werdet dieses Wissen vermutlich nie brauchen, aber ich habe ~30 Minuten damit verbracht herauszufinden wie ich das anstelle, also will ich dafür auch mindestens ein bisschen street cred."
  },
  {
    "objectID": "chapters/a01-ressourcen.html",
    "href": "chapters/a01-ressourcen.html",
    "title": "Appendix A — Ressourcen",
    "section": "",
    "text": "Es gibt viele freie Quellen für schöne Datensätze zum Üben oder rumspielen, und einige packages bringen auch entsprechende Datensätze mit, die geeignet sind um bestimmte Funktionen auszuprobieren.\n\n\n\nGängige Standarddatensätze:\n\nmtcars\nsleep\nattitude\n\npalmerpenguins::penguins: Pinguine!\ndplyr::starwars: Star Wars-stuff mit list-columns\nbabynames::babynames: Naja, baby names.\ntadaatoolbox::ngo: NGO-Datensatz aus QM (bzw. aus dem Kähler)\n\n\n\n\n\ndata.world: Hier kommt z.B. der Game of Thrones deaths-Datensatz her\n\n\n\n\nHier liegen diverse Datensätze aus unseren Projekten, wie z.B. die QM-Surveys und die Tutorienteilnahme.\n\ndata.tadaa-data.de"
  },
  {
    "objectID": "chapters/a01-ressourcen.html#bücher",
    "href": "chapters/a01-ressourcen.html#bücher",
    "title": "Appendix A — Ressourcen",
    "section": "A.2 Bücher",
    "text": "A.2 Bücher\n\n“R for Data Science” – Hadley Wickham\n“Advanced R” – Hadley Wickham\nggplot2 – Hadley Wickham\n“Tidyverse Cookbook”\n“R Programming for Data Science” – Roger Peng\n“Exploratory Data Analysis with R” – Roger Peng\n“Top 50 ggplot2 Visualizations”\n“R Cookbook”\nMehr Bücher\n\n\nA.2.1 Kollaboration und Organisation\n\nA.2.1.1 Git & GitHub\n\nhappygitwithr.com – Jenny Bryan\nohshitgit"
  },
  {
    "objectID": "chapters/a01-ressourcen.html#kurse-workshops",
    "href": "chapters/a01-ressourcen.html#kurse-workshops",
    "title": "Appendix A — Ressourcen",
    "section": "A.3 Kurse & Workshops",
    "text": "A.3 Kurse & Workshops\n\nA.3.1 Kostenlose Tutorials/Videos\n\nRStudio Webinars\nStat545\nLOTR Data"
  },
  {
    "objectID": "chapters/a01-ressourcen.html#blogs",
    "href": "chapters/a01-ressourcen.html#blogs",
    "title": "Appendix A — Ressourcen",
    "section": "A.4 Blogs",
    "text": "A.4 Blogs\n\nAggregator: R-Bloggers\n\nSiehe auch: Blogs in blogdown"
  },
  {
    "objectID": "chapters/a01-ressourcen.html#community",
    "href": "chapters/a01-ressourcen.html#community",
    "title": "Appendix A — Ressourcen",
    "section": "A.5 Community",
    "text": "A.5 Community\n\nStackoverflow\nTwitter: #rstats"
  },
  {
    "objectID": "chapters/a01-ressourcen.html#dokumentation",
    "href": "chapters/a01-ressourcen.html#dokumentation",
    "title": "Appendix A — Ressourcen",
    "section": "A.6 Dokumentation",
    "text": "A.6 Dokumentation\n\nR help (inoffizielle bookdown-Version)\nrdrr.io\nPackage-specific\n\ntidyverse.org"
  }
]