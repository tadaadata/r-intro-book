[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R f√ºr Psychos",
    "section": "",
    "text": "time is a flat circle‚Ü©Ô∏é\nzumindest dieses eine Mal in 2018‚Ü©Ô∏é\nAllen voran ggplot2, das package f√ºr plots in R.‚Ü©Ô∏é"
  },
  {
    "objectID": "chapters/01-was-ist-r.html",
    "href": "chapters/01-was-ist-r.html",
    "title": "2¬† Was ist R",
    "section": "",
    "text": "R ist eine Programmiersprache, und ja, das klingt abschreckend.\nF√ºr uns hei√üt das in erster Linie Folgendes:"
  },
  {
    "objectID": "chapters/01-was-ist-r.html#was-ist-an-r-so-toll",
    "href": "chapters/01-was-ist-r.html#was-ist-an-r-so-toll",
    "title": "2¬† Was ist R",
    "section": "2.1 Was ist an R so toll?",
    "text": "2.1 Was ist an R so toll?\nNicht alles an R ist toll ‚Äî und sobald ihr das erste Mal mehrere Stunden damit verbracht habt, ein vergleichsweise einfaches Problem l√∂sen zu wollen, werdet ihr wissen was ich meine.\nDie am h√§ufigsten zitierten Vorteile sind in etwa die Folgenden:\n\nKostenlos\n\nKeine Lizenzgeb√ºhren\nKeine Update-Geb√ºhren\n\nOpen Source\n\nSoftware-Sprech f√ºr ‚Äújeder kann sich die Innereien angucken‚Äù\nJeder kann R beliebig erweitern und modifizieren\n‚ÄúWas genau macht R an Stelle XYZ‚Äù ist immer beantwortbar, weil der Quelltext offen verf√ºgbar ist\n\nErweiterbarkeit\n\nEs gibt unz√§hlige Erweiterungen (‚Äúpackages‚Äù) f√ºr R, die neue Funktionen bereitstellen\n√úbersicht auf z.B. r-pkg.org\nSogar eure TutorInnen k√∂nnen packages schreiben. Tun sie sogar manchmal.\n\nGute Dokumentation (meistens)\n\nR bringt seine Hilfe selber mit, das ist der ‚ÄúHelp‚Äù-Tab in RStudio. Jede Funktion ist dokumentiert!\nSeiten wie rdocumentation.org oder rdrr.io erlauben es so gut wie alle verf√ºgbaren R packages nach bestimmten Funktionen zu durchsuchen, egal wie obskur der Anwendungsfall auch sein mag\nCommunities wie stackoverflow sind beliebte ‚ÄúIch brauche Hilfe bei XY‚Äù-Anlaufstellen, und eine Horde von Menschen, die meistens das gleiche Problem auch schonmal hatten, k√∂nnen euch helfen\n\nInteraktivit√§t: Wo SPSS auf Buttons und Befehle reagiert und dann einen Stapel PDFs produziert, kann R mit der Konsole auch einfach schnell und interaktiv benutzt werden: ‚ÄúSchnell mal eben was nachgucken‚Äù ist in R deutlich angenehmer als in SPSS, zumindest f√ºr einfache Sachen.\nReproduzierbarkeit: Wenn ihr ein sauberes R-Script geschrieben habt, k√∂nnt ihr das frei verf√ºgbar machen und alle Interessierten k√∂nnen es bei sich selbst ausf√ºhren und B√ÑM!, Ergebnisse reproduziert. In case you didn‚Äôt realize, but that‚Äôs kind of a big thing in science.\nVisualisierung: R hat fantastische Werkzeuge zur Datenvisualisierung, prim√§r sei hier ggplot2 erw√§hnt, was euch erlaubt wundersch√∂ne Grafiken aus euren Daten zu zaubern, und auch das vollkommen reproduzierbar (versucht das mal mit SPSS oder Excel. Worlds of pain.)\nFlexibilit√§t: R ist eine Programmiersprache, das hei√üt per default kann R erstmal alles. Vielleicht nicht alles gut, aber prinzipiell l√§sst sich zumindest theoretisch alles damit anstellen. Dieses Dokument hier? In R (RMarkdown, bookdown) geschrieben. Dynamische Webseiten? Auch m√∂glich, googlet ‚ÄúR shiny‚Äù. Interaktive Elemente? Auch kein Ding, googlet ‚ÄúR htmlwidgets‚Äù. Daten aus Software wie SPSS, Excel oder sogar Google Sheets importieren? Auch kein Problem. You get the idea.\nAktive Entwicklung & Community: R wird immer besser. Immer mehr Leute benutzen R, von diesen Leuten haben einige gute Ideen, und davon wiederum gibt es einige, die diese sogar umsetzen. Das Resultat ist ein stetig wachsendes und gedeihendes √ñkosystem um R und eine aktive Community auf diversen Netzwerken, die sowohl Hilfestellung liefern k√∂nnen als auch aktiv an besseren Tools rund um R arbeiten, von besserer Dokumentation bis zu besserer Integration mit anderer Software."
  },
  {
    "objectID": "chapters/01-was-ist-r.html#was-ist-r-nicht",
    "href": "chapters/01-was-ist-r.html#was-ist-r-nicht",
    "title": "2¬† Was ist R",
    "section": "2.2 Was ist R nicht?",
    "text": "2.2 Was ist R nicht?\nR ist nicht wie SPSS. R ‚Äúnackt‚Äù ist ein Kommandozeilenprogramm. Terminal/Konsole, wie man es auch nennen mag, aber es ist nicht wie die Programme, die ihr im Alltag benutzt. Es gibt keine Kn√∂pfe zum dr√ºcken und alles ist Text, ohne Formatierungskram wie fett oder kursiv, weil die Grundlagen bzw. Vorstufen von R aus einer Zeit kommen, in der Computer noch anders waren und die Mauer noch frisch war.\nWeil das wenig benutzerfreundlich bzw. einsteigerfreundlich ist, gibt es Programme wie RStudio, was sozusagen auf R sitzt und es benutzbar macht. Wenn R ein Pferd ist, ist RStudio ein Sattel.\nDas hei√üt f√ºr euch aber auch, dass ihr eine Datenanalyse nicht durch blo√ües Kn√∂pfchendr√ºcken zusammenstecken k√∂nnt wie das bei SPSS m√∂glich ist ‚Äî ihr m√ºsst Befehle lernen, eure Daten(struktur) verstehen, und euch sicher sein, was ihr tun wollt.\nIch wei√ü, dass das alles wirklich eher krampfig klingt wenn ihr das so lest, weshalb es auch h√§ufig vorkommt, dass Studierende in den ersten Semestern R eher ignorieren und sich lieber mit SPSS besch√§ftigen, weil das weniger kognitiver Aufwand ist ‚Äî aber glaubt mir wenn ich euch sage, dass ‚ÄúR lernen‚Äù eine gute Investition ist. SPSS k√∂nnt ihr euch immer noch irgendwie beibringen oder Youtube-Tutorials gucken oder Befehlslisten ausdrucken und sowieso und √ºberhaupt, R hingegen ist entsprechend komplexer, also nutzt die Zeit in der euch TutorInnen noch helfen k√∂nnen, bevor ihr dann vor eurem Expra-Datensatz sitzt, mit SPSS nicht weiter kommt und wie der Ochs vor‚Äôm Berg an R sitzt.\nIch betone das √ºbrigens nicht, weil ich SPSS doof finde (was ich tue), oder R so toll finde (was ich tue), sondern tats√§chlich aus Erfahrung und √úberzeugung.\nWenn euch Statistik egal ist und ihr einfach nur bestehen wollt, dann reicht euch vielleicht SPSS. Wenn ihr langfristig gut mit Methodik und quantitativen Methoden arbeiten k√∂nnen wollt, dann ist R eine gute Investition."
  },
  {
    "objectID": "chapters/01-was-ist-r.html#wieso-nicht-einfach-spss",
    "href": "chapters/01-was-ist-r.html#wieso-nicht-einfach-spss",
    "title": "2¬† Was ist R",
    "section": "2.3 Wieso nicht einfach SPSS?",
    "text": "2.3 Wieso nicht einfach SPSS?\nSPSS ist viel.\nSPSS kann viel.\nSPSS kostet uns√§glich viel.\nSPSS nimmt euch das Denken ab ‚Äî im guten wie im schlechten Sinn.\nWenn ihr SPSS bedienen k√∂nnt, ihr wisst was ihr tut und entweder ihr oder eure ArbeitgeberIn tief in die Tasche gegriffen haben um eine Lizenz bereitzustellen, dann ist das sch√∂n und gut, und ihr k√∂nnt den Knopf mit ‚ÄúMach mal Statistik‚Äù dr√ºcken und dann kommen da PDFs raus wo Statistik drinsteht.\nSch√∂n.\nM√∂glicherweise habt ihr aber nicht die finanziellen Ressourcen f√ºr SPSS.\nM√∂glicherweise braucht ihr mehr Flexibilit√§t.\nVielleicht funktioniert SPSS f√ºr euch nur mittels einer Remotedesktop-Verbindung (*hust hust*), das hei√üt sobald ihr irgendwo ohne schnelle Verbindung seid, k√∂nnt ihr nicht mehr arbeiten.\nSo sicher wie der Tod und Steuern m√ºsst ihr auch irgendwann ein Expra durchf√ºhren, die erhobenen Daten auswerten und darstellen. Solltet ihr das mit SPSS machen, d√ºrft ihr keine der Grafiken oder Tabellen benutzen (au√üer ihr verzichtet freiwillig auf eine gute Note). Das gleiche gilt in schw√§cherer Gewichtung f√ºr euer Differentielle Projekt und nat√ºrlich ggf. in st√§rkerer Gewichtung f√ºr eure Bachelorarbeit.\nVielleicht gef√§llt euch aber auch nur, dass ihr mit R interaktiv und schnell1 einfache Dinge ausprobieren k√∂nnt."
  },
  {
    "objectID": "chapters/02-installation.html",
    "href": "chapters/02-installation.html",
    "title": "\n3¬† Installation\n",
    "section": "",
    "text": "Hier eine kurze Anleitung um R und RStudio zu installieren.\nKurz zum Kontext: R ist eine Programmiersprache, das hei√üt auch ‚ÄúR installieren‚Äù ist anders als ‚ÄúSpotify installieren‚Äù.\nIhr installiert zun√§chst R, und bekommt dann auf dem Desktop Verkn√ºpfungen angeboten f√ºr ‚ÄúR GUI‚Äù (o.√Ñ.) ‚Äî Dabei handelt es sich um ‚Äúnackte‚Äù Konsolenprogramme.\nDamit k√∂nntet ihr R benutzen, aber es macht beim besten Willen keinen Spa√ü.Deshalb installiert ihr RStudio ‚Äî Ein Programm (wie Spotify, nur ganz anders!), mit dem ihr R komfortabler benutzen k√∂nnt."
  },
  {
    "objectID": "chapters/02-installation.html#r-installieren",
    "href": "chapters/02-installation.html#r-installieren",
    "title": "\n3¬† Installation\n",
    "section": "\n3.1 R installieren",
    "text": "3.1 R installieren\nR bekommt ihr von der offiziellen seite, hier: https://cran.r-project.org/\n\n\n\n\n\nJa, die Seite sieht nach heutigen Standards furchtbar alt aus, aber die gibt‚Äôs nunmal auch schon ewig und sie hat den Anspruch m√∂glichst spartanisch zu sein um auch auf jedem noch so ranzigen Computer ordentlich dargstellt und ggf. von Scripten ausgelesen zu werden.\n\n3.1.1 Windows\nKlickt auf der oben genannte Seite auf Download R for Windows. Vollkommen unerwartet.\n\n\n\n\n\nHier ben√∂tigt ihr base (der R installer):\n\n\n\n\n\n‚Ä¶und sicherheitshalber auch Rtools (fragt nicht. Vorerst installiert ihr es einfach, nur f√ºr den Fall, das es euch sp√§ter Probleme erspart).\n\n\n\n\n\nDa ich akut keinen Windows-Computer zur Hand habe, gehe ich einfach davon aus, dass ihr das Prinzip ‚Äú.exe-Datei doppelklicken und alles brav mit ja oder OK best√§tigen‚Äù beherrscht. Schafft ihr bei Spotify ja auch.\nDas war die R-Installation!\nUnd jetzt installiert ihr RStudio\n\n3.1.2 Mac OS X (macOS)\nKlickt auf der oben genannte Seite auf Download R for (Mac) OS X. Auch das, vollkommen unerwartet.\n\n\n\n\n\n\nWenn euer Betriebssystem auf dem aktuellen Stand ist, benutzt die aktuelle Version des R-installers.\n\nWenn ihr aus unerfindlichen Gr√ºnden noch eine sehr alte OS X version laufen habt:\n\nM√∂ge die Deit√§t eurer Wahl euch beistehen\nAktualisiert euer Betriebssystem, oder wenn das nicht m√∂glich ist‚Ä¶\n‚Ä¶m√ºsst ihr vermutlich den Installer mit snowleopard im Namen benutzen\n\n\nWenn ihr nicht wisst, welche OS X Version ihr benutzt: Versucht‚Äôs erstmal mit dem aktuellen Installer, wenn das nicht funktioniert, versucht den √§lteren. Ansonsten: Googlet.\n\nAnsonsten braucht ihr nichts runterzuladen. Den Installer (die .pkg-Datei) einfach doppelklicken und alles brav bejahen.\nFertig.\n\n3.1.3 Linux\nWenn ihr Linux benutzt, solltet ihr unabh√§ngig von der Geschmacksrichtung auch wissen, wie man da Software installiert.\nEs gibt diese Info-Seite f√ºr Ubuntu: https://cloud.r-project.org/bin/linux/ubuntu/README.html.\nWenn ihr nicht wisst, was https://<my.favorite.cran.mirror>/bin/linux/ubuntu sein soll, dann setzt f√ºr <my.favorite.cran.mirror> am besten einfach cloud.r-project.org ein. Die Zeilen unter ‚ÄúInstallation‚Äù im verlinkten Dokument w√ºrden dann so aussehen (f√ºr Ubuntu 18.04 bionic):\n\ndeb https://cloud.r-project.org/bin/linux/ubuntu bionic/\n\nZus√§tzlich solltet ihr vermutlich einige Systempakete (also au√üerhalb R) installieren, f√ºr den Fall der F√§lle.\nF√ºr Ubuntu zum Beispiel (nur aus eigener Erfahrung, YMMV):\nsudo apt install libcurl4-openssl-dev curl git libxml2-dev libcairo2-dev\nDamit installiert ihr ein paar Pakete, die ihr f√ºr manche R-packages als dependencies ben√∂tigt.\nDie Liste ist nicht vollst√§ndig f√ºr alle m√∂glichen R packages, aber zumindest alle, die wir im Laufe dieser Intro benutzen oder benutzen k√∂nnten sollten damit abgedeckt sein."
  },
  {
    "objectID": "chapters/02-installation.html#rstudio-install",
    "href": "chapters/02-installation.html#rstudio-install",
    "title": "\n3¬† Installation\n",
    "section": "\n3.2 RStudio installieren",
    "text": "3.2 RStudio installieren\nRStudio bekommt ihr hier: https://www.rstudio.com/products/rstudio/download/#download\n\n\n\n\n\nHier dasselbe Spiel:\nInstallationsdatei f√ºr euer Betriebssystem runterladen und installieren traue ich euch zu.\nEntt√§uscht mich nicht.\nNach der Installation solltet ihr jedenfalls folgendes Symbol entweder auf eurem Desktop oder in eurem Programmordner finden:\n\n\n\n\n\nDas wollt ihr anklicken, dann sollte sich RStudio √∂ffnen und ihr habt erfolgreich R und RStudio installiert.\nGratuliere.\nFalls ihr Windows 10 benutzt und sich keine Desktopverkn√ºfung erstellt habt, wollt ihr eure Suchfunktion benutzen und ‚ÄúRStudio‚Äù suchen. Vollkommen unerwartet, ich wei√ü."
  },
  {
    "objectID": "chapters/02-installation.html#rstudio-benutzen",
    "href": "chapters/02-installation.html#rstudio-benutzen",
    "title": "\n3¬† Installation\n",
    "section": "\n3.3 RStudio benutzen",
    "text": "3.3 RStudio benutzen\nDas ist keine Anleitung, das ist eine Aufforderung.\nIhr benutzt ausschlie√ülich RStudio. Alle anderen Desktopverkn√ºpfungen die im Laufe der Installationen erschienen sein sollten k√∂nnt ihr getrost l√∂schen, die braucht ihr nicht.\nDazu geh√∂ren solche Dinge wie ‚ÄúR Console‚Äù oder auch ‚ÄúR GUI‚Äù oder √§hnliches. Das sind die Verkn√ºpfungen f√ºr das reine R, aber wir wollen R ja durch RStudio benutzen.\nTrust me, it‚Äôs better that way.\nIn RStudio k√∂nnt ihr jetzt vermutlich noch nicht viel machen, au√üer in der Konsole aus Spa√ü ‚Äúprint('Wurstwasser')‚Äù eingeben und Enter dr√ºcken."
  },
  {
    "objectID": "chapters/03-orientierung.html",
    "href": "chapters/03-orientierung.html",
    "title": "\n4¬† Orientierung\n",
    "section": "",
    "text": "Wenn ihr vorher noch nie eine Programmiersprache benutzt habt‚Ä¶ ist das auch eigentlich gar nicht so schlimm, denn R verh√§lt sich sowieso f√ºr den Einstieg etwas anders.\n‚ÄúProgrammiersprache‚Äù klingt so abschreckend, weil es nach kompliziertem Informatikkram klingt, aber wenn ihr es in eurer Schulzeit geschafft habt einen Taschenrechner zu bedienen, dann bekommt ihr auch den Einstieg in R hin.\nWas der Begriff ‚ÄúProgrammiersprache‚Äù f√ºr uns hei√üt ist recht simpel:\nR folgt Anweisungen. Anweisungen, die wir entweder in die Konsole (in RStudio das Fenster unten links) schreiben k√∂nnen, und dann mit der Entertaste best√§tigt werden. R guckt dann, ob es wei√ü wovon ihr redet, und r√∂delt dann los ‚Äî und wenn es wei√ü was es mit eurem Befehl anfangen soll, gibt es euch auch direkt eine Antwort.\nGute Praxis1 ist es √ºbrigens, ein Script zu erstellen, das Scriptfenster ist dann in RStudio oben links. Dort k√∂nnt ihr einen Befehl pro Zeile schreiben und als Datei abspeichern, so m√ºsst ihr euch bei eurer Arbeit nicht jeden Befehl einzeln merken, sondern k√∂nnt einfach das Script wieder neu ausf√ºhren und eure Ergebnisse tauchen alle wieder auf."
  },
  {
    "objectID": "chapters/03-orientierung.html#rstudio",
    "href": "chapters/03-orientierung.html#rstudio",
    "title": "\n4¬† Orientierung\n",
    "section": "\n4.1 RStudio",
    "text": "4.1 RStudio\nWenn ihr RStudio √∂ffnet, seht ihr vermutlich folgendes:\n\n\n\n\nEin frisches RStudio Fenster\n\n\n\n\nAuf der rechten Seite habr ihr unter dem Reiter ‚ÄúEnvironment‚Äù eine √úbersicht eurer Dateien und angelegten Variablen, sowie darunter mit der Hilfe und diversem anderem Krams, der uns zuerst noch nicht interessiert.\nDas gro√üe Fenster zur linken Seite ist die Konsole, mit der besch√§ftigen wir uns zuerst.\nBevor wir hier aber irgendwas machen, schaffen wir erstmal ein bisschen Struktur und erstellen ein neues Projekt.\nEin Projekt ist einfach nur ein bestimmter Ordner, in dem ihr arbeiten k√∂nnt. Idealerweise ist es auch ein Ordner, den ihr auf eurem Computer einfach wiederfindet.\n\n\n\n\nEin neues RStudio Projekt erstellen\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAm Ende solltet ihr euer erstes Projekt erstellt haben.\nHier k√∂nnt ihr jetzt den Rest der Einf√ºhrung √ºber bleiben und Scripte erstellen und sowieso und √ºberhaupt, und wenn ihr brav alles gespeichert habt, k√∂nnt ihr darauf auch in drei Wochen noch wieder zur√ºckgreifen, indem ihr einfach das Projekt aus der entsprechenden Leiste in RStudio ausw√§hlt.\n\n\n\n\nRStudio merkt sich eure letzten paar Projekte\n\n\n\n\nAlternativ k√∂nnt ihr auch auf eurem Computer den Ordner mit dem Projekt √∂ffnen2, dort dann einfach die Datei mit dem RStudio-Logo und der .Rproj-Endung √∂ffnen. Falls ihr Windows benutzt, werden die Dateiendungen per Standard nicht angezeigt - die Datei hat aber den gleichen Namen, den ihr auch dem Projekt gegeben habt und das Symbol sieht ungef√§hr so aus:\n\n\n\n\nEin RStudio Projektordner\n\n\n\n\nAls n√§chstes k√∂nnen wir uns Konsole und Text Editor widmen: Ihr k√∂nnt in der Regel immer nur in einem der beiden Bereiche schreiben, und erkennt den aktiven Bereich am blinkenden Cursor (ein bisschen wie in Textprogrammen √° la Word) ‚Äî Konsole und Editor sind die wichtigsten Bereiche in RStudio, und dort wird auch der Gro√üteil eurer Arbeit gemacht."
  },
  {
    "objectID": "chapters/03-orientierung.html#konsole",
    "href": "chapters/03-orientierung.html#konsole",
    "title": "\n4¬† Orientierung\n",
    "section": "\n4.2 Konsole",
    "text": "4.2 Konsole\nJetzt habt ihr ein frisches Projekt und k√∂nnt loslegen.\nAls erstes m√ºssen wir uns mit der Konsole (dem Teil unten links) vertraut machen.\nHier k√∂nnt ihr Frage-Antwort-m√§√üig Befehle eingeben, mit Enter best√§tigen, und erhaltet eine Antwort.\nHier kommt die Taschenrechner-Analogie wieder ‚Äî versucht mal folgendes:\n928 + 182\n\n\n\n\nOh Schreck, es funktioniert tats√§chlich!\n\n\n\n\nDie Mathe-Basics in R:\n\nAddition: +: 52 + 365 ‚Äì> 417\nSubtraktion: -: 2017 - 18 ‚Äì> 1999\nMultiplikation: *: 4*21 ‚Äì> 84\nDivision: /: 936/12 ‚Äì> 78\nExponentiation: ^: 2^10 ‚Äì> 1024\nKlammern: (, ): 3 * (12 - 8) + 2^(5/2)\n\nWie beim Taschenrechner: Lieber zwei mehr als n√∂tig als eine zu wenig\n‚Ä¶und ja, jede offene Klammer braucht eine geschlossen Klammer, sonst gibt‚Äôs Fehler\n\n\nDas Dezimaltrennzeichen ist der Punkt .: 12,1 wird eingegeben als 12.1\n\n\nAnsonsten gibt es etliche weitere mathematischen Funktionen, und wir k√∂nnen das ganze beliebig komplex aussehen lassen:\n2 + sin((2*pi)/3) * exp(5)\nHier sehen wir mehrere neue Dinge:\nErstens: pi ist wirklich, naja, \\(\\pi\\). Das mit dem Kreis. Als Konstante schon in R vorgespeichert, weil ja kein Mensch \\(\\pi\\) auf der Tastatur findet3.\nZweitens: sin() und exp() sind Funktionen. Die sind ziemlich wichtig, aber denen wenden wir uns erst im n√§chsten Abschnitt zu.\nWas wir da geschrieben haben sieht √ºbersetzt in Mathe √ºbrigens so aus‚Ä¶\n\\[2 + \\sin \\left( \\frac{2\\pi}{3} \\right) \\cdot e^{5}\\]\n‚Ä¶ und ergibt etwa 130,5. Aber darum geht‚Äôs eigentlich gar nicht.\n\n4.2.1 G√§ngige Probleme\nWas den meisten Leuten w√§hrend der R-Einf√ºhrung passiert ist, dass sie einen Befehl in die Konsole eingeben und Enter dr√ºcken, aber der Befehl nicht richtig abgeschlossen (korrekt terminiert) wurde. Das passiert zum Beispiel, wenn ihr eine schlie√üende Klammer vergesst, oder etwa ein + am Ende der Zeile habt. In diesen F√§llen dr√ºckt ihr Enter und R nimmt euren Befehl entgegen, aber es merkt, dass da irgendwas fehlt und wartet auf den Rest des Befehls.\nIhr erkennt das daran, dass das Symbol an der linken Seite eurer Konsole auf einmal ein +-Symbol statt eines > ist und auch wiederholtes Dr√ºcken der Entertaste nichts daran √§ndert.\n\n\n\n\nPlus was denn?!\n\n\n\n\nIhr habt an dieser Stelle zwei M√∂glichkeiten:\n\nDr√ºckt Escape (esc) um den Befehl abzubrechen und es nochmal zu versuchen\nF√ºhrt den Befehl korrekt zu Ende, sprich schlie√üt ggf. offene Klammern etc."
  },
  {
    "objectID": "chapters/03-orientierung.html#text-editor",
    "href": "chapters/03-orientierung.html#text-editor",
    "title": "\n4¬† Orientierung\n",
    "section": "\n4.3 Text Editor",
    "text": "4.3 Text Editor\nAlles was in der Konsole passiert ist sch√∂n und gut, aber es ist fl√ºchtig. Stellt es euch vor wie eine Timeline auf Twitter oder ein Snapchat‚Ä¶ Snapchat Dings oder was auch immer diese jungen Leute heutzutage benutzen.\nSobald ihr mehr als vier oder f√ºnf Befehle eingegeben habt, m√ºsst ihr hochscrollen, um eure alten Ergebnisse wieder zu finden. Das ist vollkommen okay um mal schnell etwas auszuprobieren, aber eher unpraktisch f√ºr eure Arbeit, die in der Regel sowas wie Reproduzierbarkeit erfordert.\nDazu gibt es Scripte. Scripte sind im Grunde nur Textdateien, in die ihr R-Befehle eingebt.\nSch√∂n brav einen Befehl pro Zeile, wie in der Konsole.\nScripte k√∂nnt ihr speichern und an andere Leute verschicken oder hochladen oder euch ausdrucken und an die Backe tackern ‚Äî der Kreativit√§t sind keine Grenzen gesetzt! Scripte schreibt und speichert ihr, um eure Befehle / Auswertung / Code sp√§ter wiederzufinden und nachvollziehen zu k√∂nnen. Ergebnisse reproduzieren k√∂nnt ihr indem ihr den Code aus dem Script nochmal ausf√ºhrt.\nUm euer erstes Script zu erstellen klickt ihr in RStudio oben links den Button, der nach ‚Äúneuer Datei‚Äù aussieht:\n\n\n\n\nLiebes Tagebuch: Heute habe ich einen Button geklickt. Es war sehr sch√∂n.\n\n\n\n\nDanach ploppt das Fenster oben links auf und begr√º√üt euch mit einem leeren Textfeld:\n\n\n\n\nNa, auch hier?\n\n\n\n\nIm Moment hei√üt euer Script noch Untitled1 ‚Äî das hei√üt, euer Script hat noch keinen Namen und ist noch nicht gespeichert. Letzteres wollt ihr umgehend √§ndern, weil all eure sch√∂nen Befehle f√ºr die Katz sind, wenn ihr euren Kram nicht speichert.\nIhr k√∂nnt zum speichern entweder den anachronistischen Diskettenbutton klicken und eurem Script einen sch√∂nen Namen geben, oder ihr dr√ºckt STRG + S oder auf dem Mac cmd + S ‚Äî der wohl wichtigste Keyboard-Shortcut der Welt. Wenn ihr Probleme habt eure Tasten zu finden oder zu benennen, dann guckt im Glossar oder googlet halt.\n\n\n\n\nDer ‚ÄúDatei speichern‚Ä¶‚Äù-Dialog\n\n\n\n\nGebt eurem Script einen aussagekr√§ftigen Namen. Ihr wollt ja auch in zwei Wochen noch wissen, was ihr da gemacht habt.\nAu√üerdem solltet ihr darauf achten, am besten ausschlie√ülich Zahlen und Buchstaben sowie - und _ zu verwenden. Leerzeichen und Umlaute (√§√∂√º) sind zwar in der Theorie kein Problem, aber glaubt mir, sobald ihr euer Script an KommilitonInnen mit anderen Betriebssystemen verschickt, kann auch jedes noch so harmlos aussehende √ú auf einmal zu einer Reihe von kleinen Problemen f√ºhren, deren Ursache ihr erst nach Stundenlanger Probiererei (oder niemals) finden w√ºrdet. Das ist im √ºbrigen kein R-Ding, sondern gilt auch f√ºr alles andere; Word- & Excel-Dateien, PDFs, Pornovideos‚Ä¶\nEtwas √§hnliches gilt auch f√ºr den Text in eurem Script:\nVermeidet nach M√∂glichkeit besondere Zeichen wie Emoji üòä (auch wenn die theoretisch korrekt angezeigt werden). Leerzeichen sind kein Problem, und sollten sogar der besseren Lesbarkeit halber gro√üz√ºgig eingesetzt werden.\nWas der Lesbarkeit auch sehr hilft: Kommentare.\nR ignoriert in Scripten sowie in der Konsole generell alles, was rechts neben einem # steht. Wir nennen dieses Zeichen √ºbrigens entweder Raute, Lattenzaun oder Octothorpe. Wer es hashtag nennt muss leider 5‚Ç¨ in die Millenial-Dose werfen.\nDamit k√∂nnen wir sowas machen:\n# Wie alt bin ich nochmal?\n2022 - 1991\n\n# Wie viele Stunden im Jahr?\n24 * 365\nDamit bekommen eure Befehle Kontext, und sowohl ihr als auch eure KommilitonInnen k√∂nnen leicht rausfinden, was zum Geier ihr euch da eigentlich gedacht habt.\nKommentare sind auch praktisch, wenn ihr ein l√§ngere Script ausf√ºhrt, aber ein Befehl Probleme bereitet. Wenn ihr einfach ein # davor setzt, ist die Zeile auskommentiert, und wird von R ignoriert.\nWenn ihr dann ein paar Zeilen Code angesammelt habt, k√∂nnt ihr euer Script ausf√ºhren.\nEin Script wird von oben nach unten (und von links nach rechts) ausgef√ºhrt, wenn ihr auf ‚ÄúSource‚Äù klickt oder Shift + STRG + Enter dr√ºckt (auf dem Mac Shift + cmd + Enter).\nWenn ihr nur die aktuelle Zeile (da wo euer Cursor gerade ist, ist ‚Äúaktuell‚Äù) ausf√ºhren wollt, reicht STRG + R (Mac: cmd + R). Auch hier kann das Glossar helfen."
  },
  {
    "objectID": "chapters/03-orientierung.html#und-das-da-rechts",
    "href": "chapters/03-orientierung.html#und-das-da-rechts",
    "title": "\n4¬† Orientierung\n",
    "section": "\n4.4 Und das da rechts?",
    "text": "4.4 Und das da rechts?\nAuf der rechten Seite in RStudio findet ihr unter Anderem die Hilfe (Help), die Dateien in eurem Projektordner (Files), eine √úbersicht der installierten packages (Packages), eine Variablen√ºbersicht (Environment) und von euch erstelle Graphiken (Plots). Wenn ihr das hier in der richtigen Reihenfolge lest, habt ihr vermutlich keine Ahnung was das alles hei√üen soll ‚Äî und genau deswegen wenden wir uns dem Ganzen auch Schritt wir Schritt in sp√§teren Abschnitten zu, wenn ihr ein bisschen mehr √úbersicht √ºber die Grundlagen habt."
  },
  {
    "objectID": "chapters/04-erste-schritte.html",
    "href": "chapters/04-erste-schritte.html",
    "title": "\n5¬† Erste Schritte\n",
    "section": "",
    "text": "Im letzten Abschnitt habt ihr R als glorifizierten Taschenrechner gesehen.\nAls n√§chstes schauen wir uns an, was wir sonst so damit anstellen k√∂nnen.\nZuerst ein bisschen Terminologie:\nOder in der Sprach-Analogie: Alles was in R existiert (Variablen, Tabellen, etc.) ist ein Nomen (Objekt) und alles, was etwas tut, ist ein Verb (Funktion)."
  },
  {
    "objectID": "chapters/04-erste-schritte.html#grundfunktionen",
    "href": "chapters/04-erste-schritte.html#grundfunktionen",
    "title": "\n5¬† Erste Schritte\n",
    "section": "\n5.1 Grundfunktionen",
    "text": "5.1 Grundfunktionen\nDie einfachsten Funktionen haben wir in Form der Rechenzeichen + - / * schon kennengelernt, aber es gibt nat√ºrlich noch mehr.\nEine Funktion in R hat sieht immer ungef√§hr so aus: sqrt(8). Der Name der Funktion, hier sqrt, (immer ohne Leerzeichen) gefolgt von Klammern, in denen ein oder mehrere Argumente stehen. Ein Argument ist das, womit die Funktion arbeiten soll. Eine g√§ngige Veranschaulichung f√ºr Funktionen sind Verben einer Sprache, denn sie tun etwas.\nEine der wichtigsten Grundfunktionen ist c(), f√ºr combine. Mit c verbindet ihr mehrere Zahlen zu einem Vektor (ja, wie in der linearen Algebra. Mathe und so. Wisstschon.). Wenn ihr mehrere Zahlen zu einem Vektor kombiniert habt, k√∂nnt ihr damit so spa√üige Dinge machen wie Mittelwerte ausrechen, sie aufsummieren oder zwei Vektoren gleicher L√§nge addieren.\nProbiert mal ein paar Beispiele aus:\n\nCode# Ein paar Zahlen\nc(1, 1, 2, 3, 5, 8, 13, 21)\n#> [1]  1  1  2  3  5  8 13 21\n\n# Was ist der Mittelwert der Zahlen?\nmean(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 6.75\n\n# Und die Summe?\nsum(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 54\n\n# Und wenn wir quadrieren?\nc(1, 1, 2, 3, 5, 8, 13, 21)^2\n#> [1]   1   1   4   9  25  64 169 441\n\n# Oder die Wurzel ziehen?\nsqrt(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 1.000000 1.000000 1.414214 1.732051 2.236068 2.828427 3.605551 4.582576\n\n\nWas wir hier sehen ist der Unterschied zwischen Funktionen, die aus mehreren Zahlen eine machen (mean, sum), und Funktionen, die auf jeder Zahl einzeln operieren (sqrt, ^).\nWas wir au√üerdem sehen: Jedes mal die Liste von Zahlen c(1, 1, 2, 3, 5, 8, 13, 21) kopieren und in eine Funktion einsetzen ist ziemlich unpraktisch. Stellt euch vor, ihr habt eine Reihe von Testergebnissen von hunderten ProbandInnen und m√ºsst da alles einzeln, also, nein, das w√§re ja albern.\nF√ºr sowas gibt es dann Abstraktionen wie Variablen und Datens√§tze, die entweder eine Liste von Werten oder auch eine Liste einer Liste von Werten handlich machen ‚Äî das sehen wir dann in den n√§chsten beiden Abschnitten.\nEine weitere praktische Funktion ist length(): Sie sagt uns, wie lang das Argument ist.\nWenn wir uns also angucken, wie der Mittelwert funktioniert‚Ä¶\n\\[\\bar{x} = \\frac{1}{n} \\sum^n_{i=1} x_i\\]\n‚Ä¶und wir das √ºbersetzen in ‚ÄúDie Summe aller Werte geteilt durch die Anzahl der Werte‚Äù, dann k√∂nnen wir statt mean also auch folgendes schreiben:\n\nCode# in lang\nsum(c(1, 1, 2, 3, 5, 8, 13, 21))/length(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 6.75\n\n# in kurz\nmean(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 6.75\n\n\nIhr seht vielleicht so langsam, wieso wir das mit den Klammern und den Leerzeichen f√ºr die Lesbarkeit erw√§hnt haben.\nAber gut, so langsam wird‚Äôs un√ºbersichtlich, es wird Zeit ein paar Variablen anzulegen.\n\n5.1.1 Funktionsbeispiele\nWenn ihr R lernt, werdet ihr erfahrungsgem√§√ü die meiste Zeit damit verbringen herauszufinden wie bestimmte Funktionen funktionieren und welche Funktion f√ºr euer Vorhaben die richtige ist.\nFunktionen sind zwar vom Schema immer gleich ‚Äî ihr steckt irgendwelche Argumente rein, und es kommt irgendein Ergebnis raus ‚Äî aber wie die Argumente aussehen unterscheidet sich von Funktion zu Funktion.sd() zum Beispiel hat zwei Argumente:\n\n\nx: Ein Vektor aus Zahlen, aus denen die Standardabweichung berechnet werden soll\n\nna.rm: F√ºr NA remove, entweder TRUE oder FALSE. Wenn x fehlende Werte (NA) enth√§lt, dann werden diese automatisch ignoriert, wenn na.rm = TRUE\n\n\n\nCodezahlen <- c(3, 6, 8, 3, 1, 2, 5, 6, 4, 3, NA, 4, 5, 7, NA, 1, 4)\n\n# Ergibt NA :(\nsd(zahlen)\n#> [1] NA\n\n# Ergibt ein Ergebnis :)\nsd(zahlen, na.rm = TRUE)\n#> [1] 2.065591\n\n\nDer default f√ºr na.rm ist bei den meisten Funktionen (z.B auch mean) FALSE, das hei√üt fehlende Werte werden nicht automatisch ignoriert. Wenn euer input aber NA enth√§lt, dann l√§sst sich daraus nicht sauber ein Mittelwert oder eine Standardabweichung berechnen, weil wir nichts √ºber NA wissen (wir widmen uns NA im Kapitel zu Datentypen).\nNicht jede Funktion hat ein Argument namens na.rm, aber ihr werdet im Laufe der Zeit lernen, bei welchen Funktionen ihr darauf achten m√ºsst, wie mit fehlenden Werten umgegangen wird.\nEinige andere Funktionen, die insbesondere zum Lernen und Ausprobieren praktisch sind, werden zur Erstellung von Sequenzen benutzt ‚Äî also Reihen von Zahlen in einem bestimmten Muster:\n\nCode# Die Zahlen von 1 bis 100\n1:100\n#>   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n#>  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n#>  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n#>  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n#>  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n#>  [91]  91  92  93  94  95  96  97  98  99 100\n\n# 10 bis 15 in 0.5er-Schritten\nseq(10, 15, 0.5)\n#>  [1] 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0\n\n# √Ñquivalent, mit explizit benannten Argumenten:\nseq(from = 10, to = 15, by = 0.5)\n#>  [1] 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0\n\n# Von 5 bis -5 in ganzen Schritten\nseq(5, -5)\n#>  [1]  5  4  3  2  1  0 -1 -2 -3 -4 -5\n\n# Sequenz von 1 mit L√§nge 5, dasselbe wie 1:5\nseq_len(5)\n#> [1] 1 2 3 4 5\nseq_len(length.out = 5)\n#> [1] 1 2 3 4 5\n\n\nDas : ist eine einfache Funktion und kann gelesen werden wie ‚ÄúVon ‚Ä¶ bis ‚Ä¶ in ganzen Schritten‚Äù. Zus√∂tzlich gibt es die Funktion seq(), die etwas flexibler ist. Au√üerdem gibt es diverse Funktionen f√ºr zufallsgenerierte Zahlen:\n\nCode# Normalverteilte Zufallszahlen (10 St√ºck, Mittelwert 5, Standardabweichung 2) \nrnorm(n = 10, mean = 5, sd = 2)\n#>  [1] 3.125531 4.290414 3.257567 6.157613 8.736960 5.762605 3.971103 3.725957\n#>  [9] 3.205225 6.926189\n\n# Gleichverteilte Zufallszahlen (sprich \"r unif\", nicht \"run if\")\nrunif(n = 10)\n#>  [1] 0.87405632 0.06917889 0.43218638 0.45629630 0.73254597 0.39701918\n#>  [7] 0.13624601 0.81409080 0.21727864 0.46286741\n\n# M√ºnzwurf (Binomialverteilte Ergebnisse), 10 St√ºck\nrbinom(n = 10, size = 1, prob = 0.5)\n#>  [1] 1 1 1 1 1 0 0 1 0 1\n\n# W√ºrfel (W6) (10 St√ºck)\nsample(x = 1:6, size = 10, replace = TRUE)\n#>  [1] 6 3 6 3 5 6 3 6 3 5"
  },
  {
    "objectID": "chapters/04-erste-schritte.html#variablen",
    "href": "chapters/04-erste-schritte.html#variablen",
    "title": "\n5¬† Erste Schritte\n",
    "section": "\n5.2 Variablen",
    "text": "5.2 Variablen\nWenn Funktionen wie Verben sind, dann sind Variablen wie Nomen. Sie haben einen Namen, und mit ihnen kann man Dinge tun. Oder sogar Sachen machen.\nVariablen werden durch eine Zuweisung (Assignment) erstellt, was in R traditionell via <- passiert.\nIn den meisten anderen Programmiersprachen benutzt man daf√ºr =, aber nun ja, R ist historisch gewachsen1, also nehmt f√ºr den Anfang einfach mal hin, dass das nunmal so ist.\nWir speichern also mal ein paar Dinge:\n\nCode# Speichern in \"fib\"\nfib <- c(1, 1, 2, 3, 5, 8, 13, 21) \n\n# Ausgeben lassen\nfib\n#> [1]  1  1  2  3  5  8 13 21\n\n# Mittelwert‚Ä¶\nmean(fib)\n#> [1] 6.75\n\n# ‚Ä¶funktioniert immer noch. Angenehm.\n# Und wenn wir‚Ä¶\nfib + fib\n#> [1]  2  2  4  6 10 16 26 42\n\n# Abgefahrener Kram.\n\n\nHier haben wir die Zahlen 1, 1, 2, 3, 5, 8, 13, 21 in die Variable fib gespeichert, weil es die ersten paar Fibonacci-Zahlen sind, und wir unsere Variablen immer so benennen sollten, dass wir sp√§ter noch wissen wof√ºr sie da sind. Viele Tutorials beginnen damit, Variablen wie x, y und z anzulegen, aber da blickt ja irgendwann kein Mensch mehr durch.\nWenn ihr jetzt mit euren Zahlen arbeiten wollt, k√∂nnt ihr einfach in jeder Funktion fib statt der Liste mit c(‚Ä¶) einsetzen, und alles funktioniert wie vorher. Das liegt daran, dass R bei jedem Befehl erstmal nachschaut, ob ihr eine Variable benutzt (alles was Text ohne Anf√ºhrungszeichen ist), und ob es die Variable findet. Wenn es die Variable gefunden hat, guckt es nach, was da drinsteht, in diesem Fall also c(1, 1, 2, 3, 5, 8, 13, 21), dann benutzt R den Inhalt der Variablen.\nAn dieser Stelle bietet es sich an, einen neuen Typ einzuf√ºhren: Den String (oder auch character). Als String bezeichnet man im Kontext von, naja, Computerkram generell eigentlich, alles was als Text durchgeht. Sobald wir etwas nicht mehr nur durch Zahlen darstellen k√∂nnen, ist es ein String.\nStrings stehen in R immer in Anf√ºhrungszeichen, entweder in \"doppelten\" oder in 'einfachen'.\nWichtig dabei ist, dass sich Anf√ºhrungszeichen √§hnlich verhalten wie Klammern. Wenn wir einen String mit ‚Äú beginnen, m√ºssen wir ihn auch wieder mit ‚Äù schlie√üen, ansonsten wartet R brav darauf, dass endlich das zweite ‚Äú kommt und verl√§uft sich.\nEin Beispiel:\n\nCode# Vollkommen okay\nnamen <- c(\"Tobi\", \"Lukas\", \"Nadja\", \"Christoph\")\n\n# Auch okay, aber inkonsistent und daher eher unsch√∂n\nnamen <- c('Tobi', \"Lukas\", 'Nadja', \"Christoph\")\n\n# Tod und Verderben (=> funktioniert nicht)\nnamen <- c(\"Tobi\", 'Lukas\", 'Nadja, Christop\")\n\n\nWir k√∂nnen auch Zahlen in \"\" setzen ‚Äî das ist kein Problem, aber dann sind es nunmal keine Zahlen in diesem Sinne mehr, es sind Strings, und mit Strings k√∂nnen wir nicht rechnen.\nProbiert folgendes aus:\n\nCode# Okay\n5 + 5\n\n# H√§?\n5 + \"5\"\n\n\nIhr sehr jetzt vermutlich die Meldung Error in 5 + \"5\" : non-numeric argument to binary operator.\nDas non-numeric argument hier ist die \"5\". Merken: 5 ist numerisch, aber \"5\" ist ein character (=> String).\nDer binary operator an dieser Stelle ist √ºbrigens das +. Ein Operator, weil es, √§h‚Ä¶ operiert? Naja, es tut Dinge, und wenn etwas in R Dinge tut, ist es meistens ein Operator in irgendeinem Sinne. Das binary hei√üt, dass es zwei (bi, bin√§r, binary, zwei halt) Argumente nimmt.\nWie schon gesagt, Argumente sind die Dinge, die wir an Funktionen √ºbergeben, und wenn wir an eine Funktion wie + oder auch mean() ein Argument √ºbergeben, mit denen sie nichts anfangen k√∂nnen, dann beschwert sich R weil es nicht wei√ü was zum Geier ihr da vorhabt.\n\nCodenamen <- c(\"Tobi\", \"Lukas\", \"Nadja\", \"Christoph\")\n\nfib <- c(1, 1, 2, 3, 5, 8, 13, 21) \n\n# Alles knorke\nmean(fib)\n#> [1] 6.75\n\n# Alles CHAOS UND UNHEIL\nmean(namen)\n#> Warning in mean.default(namen): argument is not numeric or logical:\n#> returning NA\n#> [1] NA\n\n\nWas es mit NA auf sich hat, und was es noch so f√ºr Datentypen gibt, sehen wir dann im Abschnitt zu [Datentypen].\nEine letzte Sache noch: Strings sind ‚Äúdominanter‚Äù als Zahlen, das hei√üt, wir k√∂nnen zwar Zahlen verbinden zu c(1, 2, 3), und Strings zu c(\"A\", \"B\", \"C\"), aber wenn wir c(\"A\", 2, \"C\", 4) schreiben, dann behandelt R einfach alle Elemente des Vektors (=> Das, was in c(‚Ä¶)) steht, als w√§ren es character-Werte.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: Merke: Ein Vektor in R muss immer Elemente des gleichen Typs haben, Zahlen und Buchstaben zusammen werden zu Strings konvertiert!"
  },
  {
    "objectID": "chapters/04-erste-schritte.html#tabellen",
    "href": "chapters/04-erste-schritte.html#tabellen",
    "title": "\n5¬† Erste Schritte\n",
    "section": "\n5.3 Tabellen",
    "text": "5.3 Tabellen\nJetzt haben wir schonmal das Vokabular an der Hand um Zahlen und beliebige Strings in R zu verarbeiten, aber noch ist das alles etwas unhandlich um damit richtig zu arbeiten.\nStellt euch vor, wir wollen einen kleinen Datensatz erstellen √ºber die Statistiktutorien in QM mit Variablen wie Namen, Alter, und vielleicht sowas wie Beliebtheit auf einer Skala von 1-10.\nWir k√∂nnten sowas machen:\n\nCodenamen <- c(\"Tobi\", \"Christoph\", \"Nadja\", \"Lukas\")\nalter <- c(20, 35, 30, 12) # (Nicht alle diese Werte sind korrekt)\n\nmean(alter)\n#> [1] 24.25\n\n\nSch√∂n und gut, aber das ist ja unhandlich. Was, wenn wir die Namen aller TutorInnen haben wollen, die j√ºnger als 30 sind? Alles was wir mit alter machen, passiert unabh√§ngig von namen.\nUm mehrere Variablen in Kontext zu setzen, gibt es tabellarischen Datenstrukturen, namentlich nennt sich sowas in R dann data.frame. Letztendlich ist das nichts anderes als eine Tabelle, aber f√ºr R ist eine Tabelle praktische eine Liste von Vektoren mit gleicher l√§nge:\n\nCodeleute <- data.frame(name = c(\"Tobi\", \"Christoph\", \"Nadja\", \"Lukas\"),\n                    alter = c(20, 35, 30, 12),\n                    beliebtheit = c(9, 10, 8, 3))\n\n# Anzeigen lassen\nleute\n#>        name alter beliebtheit\n#> 1      Tobi    20           9\n#> 2 Christoph    35          10\n#> 3     Nadja    30           8\n#> 4     Lukas    12           3\n\n\nWas haben wir da gemacht?\n\nWir haben einen data.frame mit der gleichnamigen Funktion erstellt\nDie Argumente der Funktion haben die Form Spaltenname = Werte der Spalte\n\nMehrere Argumente werden mit , getrennt und optional mit einem Zeilenumbruch √ºbersichtlich gehalten\n\nDas Ergebnis ist eine Variable leute, die drei Spalten mit je vier Werten hat.\nJede Spalte ist eine Variable, und jede Zeile der Tabelle kann als eine Beobachtung betrachtet werden.\nEine Beobachtung (Observation) sind alle Werte, die wir zu einem Untersuchungsobjekt haben, also in diesem Beispiel eine Person. Wenn wir uns nur die erste Zeile anschauen, sehen wir nur die Werte, die zu Tobi geh√∂ren, in der zweiten Zeile sehen wir die Werte zu Christoph etc.\nTabellen, und damit data.frames, sind f√ºr uns die wichtigsten Objekte in R, weil wir fast ausschlie√ülich mit Datens√§tzen in dieser Form arbeiten werden um unsere Statistik da draufzuwerfen.\nWie k√∂nnen wir jetzt mit einzelnen Variablen arbeiten?\n\nCode# Die Variable \"name\" ausgeben lassen\nleute$name\n#> [1] \"Tobi\"      \"Christoph\" \"Nadja\"     \"Lukas\"\n\n# Den Mittelwert von \"alter\" bestimmen\nmean(leute$alter)\n#> [1] 24.25\n\n# Die Standardabweichung von \"beliebtheit\"\nsd(leute$beliebtheit)\n#> [1] 3.109126\n\n# Was auch funktioniert:\nleute[[\"name\"]]\n#> [1] \"Tobi\"      \"Christoph\" \"Nadja\"     \"Lukas\"\nleute[[\"alter\"]]\n#> [1] 20 35 30 12\n\n\nDas mit den ‚ÄúLevels‚Äù wird im Abschnitt zu [Datentypen] erkl√§rt\nWas wir hier benutzen nennt sich Subsetting, also im Grunde nur einen Teil von etwas rausholen. Hier also einen Teil der Tabelle on Form einer einzelnen Spalte.\nSpalten k√∂nnen wir mit $ oder [[ ]] direkt aus einem data.frame ansteuern, was unser Leben gleich viel einfacher macht. Strenggenommen sidn $ und [[ auch eigene Funktionen, aber dazu vielleicht sp√§ter mehr, im Moment ist f√ºr uns nur wichtig, dass wir einzelne Spalten (Variablen) einer Tabelle (data.frame) einfach adressieren und genauso behandeln k√∂nnen wie die einzelnen Variablen name und alter, die wir weiter oben erstellt haben."
  },
  {
    "objectID": "chapters/04-erste-schritte.html#umgang-mit-datens√§tzen",
    "href": "chapters/04-erste-schritte.html#umgang-mit-datens√§tzen",
    "title": "\n5¬† Erste Schritte\n",
    "section": "\n5.4 Umgang mit Datens√§tzen",
    "text": "5.4 Umgang mit Datens√§tzen\nDa wir noch nicht an dem Punkt sind, wo wir beliebige Daten einlesen k√∂nnen, und wir nat√ºrlich zu faul sind uns eine gr√∂√üere Tabelle selber zu schreiben, greifen wir zu √úbungszwecken mal auf einen Datensatz zur√ºck, der bei R von Haus aus mitgeliefert wird: sleep.\nDieser Datensatz beinhaltet die Daten aus einer Medikamentenstudie, bei der es um Schlafgewinn bzw. -verlust ging. Die Tabelle hat drei Spalten (Variablen) zu 10 Personen:\n\n\nextra: Schlafzuwachs in Stunden, positiv oder negativ f√ºr mehr bzw. weniger Schlaf als vorher\n\ngroup: Die Versuchsgruppe, sprich welches Medikament die Person bekam, 1 oder 2\n\n\nID: Die Identifikationsnummer der Person. Es ist g√§ngig, ProbandInnen pseudonymisiert durchzunummerieren, der Zuordnung unt des Datenschutzes wegen als Zahlen.\n\n\nCode# Mit head() lassen wir uns die ersten paar Zeilen (den \"Kopf\") der Tabelle anzeigen\nhead(sleep)\n#>   extra group ID\n#> 1   0.7     1  1\n#> 2  -1.6     1  2\n#> 3  -0.2     1  3\n#> 4  -1.2     1  4\n#> 5  -0.1     1  5\n#> 6   3.4     1  6\n\n\nWie viele Zeilen hat die Tabelle?\n\nCodenrow(sleep)\n#> [1] 20\n\n\nDie number of rows bekommen wir mit nrow() ‚Äî ihr d√ºrft jetzt raten, wie wir uns die Anzahl der Spalten (columns) anzeigen lassen k√∂nnen.\n\nCodencol(sleep)\n#> [1] 3\n\n\nSurprise!\nOkay, aber was interessiert uns an diesem Datensatz jetzt? Wie w√§re es mit dem durchschnittlichen Schlafzuwachs:\n\nCodemean(sleep$extra)\n#> [1] 1.54\n\n\nSch√∂n und gut, aber wir wollen ja vermutlich die beiden Gruppen (Medikamente) vergleichen, also was tun?\nSubsetting to the rescue /o/\n\nCodegruppe1 <- sleep[sleep$group == 1, ]\ngruppe2 <- sleep[sleep$group == 2, ]\n\n# Mittelwert der ersten Gruppe\nmean(gruppe1$extra)\n#> [1] 0.75\n\n# Mittelwert der zweiten Gruppe\nmean(gruppe2$extra)\n#> [1] 2.33\n\n\nOkay, Schritt f√ºr Schritt.\nHier haben wir unseren ersten logischen vergleich benutzt, um eine Teilmenge der Tabelle zu extrahieren.\nDas klingt fancy, ist aber ziemlich simpel.\nIn Worten hei√üt die Zeile gruppe1 <- sleep[sleep$group == 1] lediglich:\n‚ÄúNimm die Tabelle sleep und filtere daraus alle Zeilen, die zu der Gruppe 1 geh√∂ren, und speichere sie in die Variable gruppe1‚Äù Das Resultat sind zwei Variablen, die einen Teil der Tabelle sleep enthalten, und zwar jeweils zu einer der beiden Gruppen.\nWieso dann eigentlich noch diese ,-Sache am Ende der eckigen Klammern?\nDas geh√∂rt zur Art, wie R Tabellen indiziert, sprich wie man einzelne Bereiche der Tabelle ansteuert:\n\nCode# Die erste Spalte\nsleep[1]\n#>    extra\n#> 1    0.7\n#> 2   -1.6\n#> 3   -0.2\n#> 4   -1.2\n#> 5   -0.1\n#> 6    3.4\n#> 7    3.7\n#> 8    0.8\n#> 9    0.0\n#> 10   2.0\n#> 11   1.9\n#> 12   0.8\n#> 13   1.1\n#> 14   0.1\n#> 15  -0.1\n#> 16   4.4\n#> 17   5.5\n#> 18   1.6\n#> 19   4.6\n#> 20   3.4\n\n# Die erste Zeile\nsleep[1, ]\n#>   extra group ID\n#> 1   0.7     1  1\n\n# Die erste Zeile und die dritte Spalte\nsleep[1, 3]\n#> [1] 1\n#> Levels: 1 2 3 4 5 6 7 8 9 10\n\n\nDie allgemeine Form ist tabelle[Zeilennummer, Spaltennumer], und jetzt fragt ihr euch vermutlich, wieso wir vorhin [[ ]] benutzt haben, und jetzt [ ] ‚Äî die kurze Antwort ist: Das ist halt was anderes. Die Details sind erstmal nicht so wichtig, was ihr euch vorerst merken solltet ist folgendes:\n\n\nsleep[1] ergibt einen data.frame mit nur einer Spalte\n\n\nsleep[1, ] ergibt einen data.frame mit nur einer Zeile\n\n\nsleep[[1]] und sleep$extra sind dasselbe (weil extra die erste Spalte ist) und ergeben die erste Spalte als Vektor\n\n\nsleep$extra[[2]] und sleep$extra[2] sind hier dasselbe: Das zweite Element im Vektor sleep$extra\n\n\nBei einer Tabelle ist es n√ºtzlich mit Zeilen und Spalten zu arbeiten, um die gew√ºnschten Werte rauszuholen, aber bei einem Vektor gibt es in diesem Sinne nur eine Dimension.\nSinn der Sache ist, dass wir Funktionen wie mean oder sd nur auf Vektoren anwenden k√∂nnen, was auch intuitiv irgendwie sinnvoll scheint, denn der Mittelwert einer ganzen Tabelle mit mehreren Variablen ist ja konzeptionell etwas‚Ä¶ schwierig.\n# Okay\nmean(sleep$extra)\n#> [1] 1.54\n\n# Das selbe Ergebnis\nmean(sleep[[1]])\n#> [1] 1.54\n\n# Auch okay!\nmean(sleep[[\"extra\"]])\n#> [1] 1.54\n\n# Das hier nicht so\nmean(sleep[1])\n#> Warning in mean.default(sleep[1]): argument is not numeric or logical:\n#> returning NA\n#> [1] NA\nsleep[1] gibt euch zwar auch die Spalte extra, aber wie schon gesagt, in data.frame-Form, und nicht als Vektor.\nVermutlich verwirrt euch das ganze Geklammere jetzt mehr oder weniger stark, aber glaubt mir, wenn wir erstmal ein Gef√ºhl daf√ºr habt ist es sehr viel Wert diese Grundlagen auf dem Schirm zu haben (oder sie zumindest nachlesen zu k√∂nnen), denn in der ersten Zeit eurer R-Nutzung werdet ihr massenhaft kleinere und gr√∂√üere Fehler in dieser Art machen, wo ihr zwar das richtige meint, aber R nicht das richtige sagt.\nDie andere Sache ist, dass ihr das mit den eckigen Klammern gar nicht so h√§ufig brauchen werdet, wenn ihr euch erstmal an das tidyverse und dplyr gew√∂hnt habt, aber dazu sp√§ter mehr.\nWir schneiden das Ganze Thema Subsetting hier auch erstmal nur an, aber wenn ihr‚Äôs jetzt schon ganz genau wissen wollt, k√∂nnt ihr die Details hier nachlesen"
  },
  {
    "objectID": "chapters/04-erste-schritte.html#logische-vergleiche",
    "href": "chapters/04-erste-schritte.html#logische-vergleiche",
    "title": "\n5¬† Erste Schritte\n",
    "section": "\n5.5 Logische Vergleiche",
    "text": "5.5 Logische Vergleiche\nLogik! Eine Welt des Spa√ües, der internen Konsistenz[^Naja, fast. Aber G√∂del lassen wir mal aus.] und der unendlichen Anwendbarkeit in allen Bereichen.\nWas ihr intuitiv als Logik kennt ist alleridngs etwas anderes als formale Logik, also das, was Computer verstehen.\nWir brauchen zum Gl√ºck nicht all zu viel davon, nur den Standardkram und nichtmal das volle Spekrum Bool‚Äôscher Algebra.\nWir brauchen Logik in R in erster Linie zum indizieren von Objekten. Das hei√üt, wenn wir alle Zeilen einer Tabelle haben wollen, f√ºr die eine bestimmte Variable einen bestimmten Wert hat oder eine Bedingung erf√ºllt, dann dr√ºcken wir das durch Logik aus. Dasselbe funktioniert nat√ºrlich auch bei Vektoren (und strenggenommen funktioniert Tabellenindizierung sowieso √ºber Vektorindizierung). Man nehme folgendes Beispiel:\n\nCodesleep[sleep$extra > 3, ]\n#>    extra group ID\n#> 6    3.4     1  6\n#> 7    3.7     1  7\n#> 16   4.4     2  6\n#> 17   5.5     2  7\n#> 19   4.6     2  9\n#> 20   3.4     2 10\n\n\nDas hei√üt: ‚ÄúNimm die Tabelle sleep und gib mir alle Zeilen (das mit den eckigen Klammen), f√ºr die die Variable sleep$extra gr√∂√üer als 3 ist‚Äù.\nDas Ergebnis eines logischen Vergleichs ist immer entweder TRUE oder FALSE f√ºr wahr oder falsch.\nWenn wir in R indizieren wollen, k√∂nnen wir daf√ºr auch direkt TRUE und FALSE statt eines Vergleichs benutzen:\n\nCodefib <- c(1, 1, 2, 3, 5, 8, 13, 21) \n\nfib[c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)]\n#> [1] 1 1\n\n\nHier haben wir uns effektiv nur die ersten beiden Werte des Vektors fib ausgeben lassen, weil R alles ausgibt, was mit TRUE indiziert ist und alles wegl√§sst, was mit FALSE indiziert ist.c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE) ist hier ein logischer Vektor, also ein Vektor mit, naja, logischen Werten, der praktisch der Reihe nach jedes Element im Vektor fib entweder an oder aus schaltet, wie Lichtschalter. Wir m√ºssen daf√ºr nicht unbedingt einen logischen Vektor der gleichen L√§nge (Anzahl der Elemente) wie unser Zielvektor (der, den wir indizieren/filtern wollen) benutzen, aber es bietet sich f√ºr den Einstieg an so genau wie m√∂glich zu sein.\nWir k√∂nnten aber auch sowas machen:\n\nCode# Immer abwechselnd TRUE und FALSE, also jedes zweite Element\nfib[c(TRUE, FALSE)]\n#> [1]  1  2  5 13\n\n# Schema TRUE TRUE FALSE FALSE ginge auch\nfib[c(TRUE, TRUE, FALSE, FALSE)]\n#> [1] 1 1 5 8\n\n\nWichtig hierbei ist, dass der logische Vektor ein ganzer Faktor des Zielvektors ist, das hei√üt, dass die Anzahl der Element im Zielvektor ganz durch die Anzahl der Elemente im logischen Vektor teilbar sein muss (also ohne Rest), ansonsten bekommen wir potenziell schwer vorhersagbare Ergebnisse.\nWas R hier macht nennt sich Recycling: In der ersten Zeile im letzten Beispiel wird der Vektor c(TRUE, FALSE) solange recyclet, also wiederverwendet, bis der ganze Zeilvektor ‚Äúabgedeckt‚Äù ist. Wenn der logische Vektor nicht sauber in den Zielvektor passt (in Bezug auf die Anzahl der Elemente), dann bleibt entweder was √ºbrig oder es reicht nicht. Das w√§re schade.\n\n5.5.1 Operatoren\nEs gibt eine Reihe logischer Operatoren wie hier > f√ºr ‚Äúist gr√∂√üer als‚Äù, die wichtigsten in √úbersicht:\n\n\n== (doppeltes Gleichheitszeichen ohne Leerzeichen dazwischen)\n\n‚ÄúIst gleich‚Äù\n\n1 == 2 ‚Äì> FALSE\n\n\n3 == 3 ‚Äì> TRUE\n\n\n3 == \"Hallo\" ‚Äì> FALSE\n\n\n\n\n!=\n\n‚Äúist ungleich‚Äù\nDie Negation von ==, also immer da wo == euch TRUE zeigt, gibt != euch FALSE und andersherum.\n\npi != 3 ‚Äì> TRUE\n\n\"Psychologiestudium\" != \"Voll gute Idee\"\n\n\n\n! (ja, ein einfaches Ausrufezeichen)\n\n‚ÄúNegation‚Äù\nDreht ein FALSE zu einem TRUE um und andersherum. Wichtig: Klammern!\n!(2 == 3)\nTRUE == !FALSE\n\n\n\n> und < (spitze Klammern)\n\n‚Äúist gr√∂√üer/kleiner als‚Äù\nDa wo die Klamer spitz ist, soll das kleinere sein\n\n5 > 4 ‚Äì> TRUE\n\n\n2^10 < 1000 ‚Äì> FALSE\n\n\n2 < 5 < 4 ‚Äì> Funktioniert nicht!\n\n\n\n\n>=, <=\n\n‚ÄúGr√∂√üer gleich bzw. kleiner gleich‚Äù\nIst Entweder a > b oder a == b?\n5 >= 4\n16 <= 2^4\n\n\n\nDiese Ausdr√ºcke k√∂nnen wir auch auf bestimmte Arten verkn√ºpfen:\n\n\n& (oder auch &&)\n\n‚ÄúUnd‚Äù\nIst TRUE, wenn beide Seiten TRUE sind\n\n(1 < 3) & (5 < 10) ‚Äì> TRUE\n\n\n(5 < 2) & (2 < 10) ‚Äì> FALSE\n\n1 und 0 werden zu TRUE bzw. FALSE √ºbersetzt:\n\n\n1 & (2 == 2) ‚Äì> TRUE\n\n\n!(0 & FALSE) ‚Äì> TRUE\n\n\n\n\n\n\n| (oder auch ||)\n\n‚ÄúOder‚Äù\nIst entweder A oder B oder beides TRUE?\nDa | auch wahr ist, wenn nur eine Seite wahr ist, ist es auch Grundlage etlicher Mathe-/Logikwitze\n\n(1 < 3) | (5 < 10) ‚Äì> TRUE\n\n\n(5 < 2) | (2 < 10) ‚Äì> TRUE\n\n\n\n\nxor()\n\n‚ÄúEntweder ‚Ä¶ oder ‚Ä¶‚Äù (ausschlie√üend!)\nWenn euch | zu unspezifisch ist\nIst nur war, wenn eins von beidem wahr ist, aber nicht, wenn beides wahr ist\n\nKein bin√§rer Operator wie die anderen, sondern eine R-Funktion mit Klammern und so\n\nxor(TRUE, FALSE) ‚Äì> TRUE\n\n\nxor(TRUE, TRUE) ‚Äì> FALSE\n\n\nxor((1 < 3), (5 < 10)) ‚Äì> FALSE\n\n\nxor((5 < 2), (2 < 10)) ‚Äì> TRUE\n\n\n\n\n5.5.2 Spezielle Tests\nDie obigen Operatoren k√∂nnen wir f√ºr getrost f√ºr Vektorvergleiche benutzen, aber es gibt noch ein paar Sonderf√§lle. Was zum Beispiel, wenn wir nur generell wissen wollen, ob ein Element wie eine Zahl oder ein String in einem Vektor enthalten ist? Oder was, wenn wir wir auf spezielle Typen oder Klassen testen wollen? Was das im Detail hei√üt sehen wir in den entsprechenden Abschnitten zu [Datentypen] noch einmal, aber hier schonmal eine Kurzreferenz:\n\n\n%in% (auch hier, ohne Leerzeichen dazwischen!)\n\n‚ÄúIst in‚Äù\nMengentheoretisch ist das \\(x \\in X\\)\n\nIst Element a in Menge b?\n\n5 %in% c(1, 4, 5, 3) ‚Äì> TRUE\n\n\n\"B\" %in% c(\"a\", \"b\", \"c\") ‚Äì> FALSE\n\n\n\"B\" %in% c(\"a\", \"B\", \"c\") ‚Äì> TRUE\n\n\nc(1, 2) %in% 1:5 ‚Äì> TRUE\n\n\n\n\nis.na(): Testet auf fehlende Werte (missing values, NA)\n\nis.null(): Testet auf leere Werte (NULL)\n\nis.nan(): Testet auf NaN (Not a Number)\n\n5.5.3 Indexing: Beispiele\nDas war jetzt relativ viel Information, und ihr m√ºsst euch das auch nicht alles sofort merken, sondern nur wissen, wo ihr‚Äôs bei Bedarf nachschlagen k√∂nnt.\nDie Motivation hinter dem Logikram ist wie erw√§hnt prim√§r das Filtern von Tabellen und Vektoren, was wir nunmal relativ h√§ufig brauchen um zum Beispiel bestimmte Untergruppen in unseren Datens√§tze zu analysieren, zum Beispiel Personen √§lter als 35 (z.B. age > 35) oder Menschen, die sowohl weiblich sind als auch Medikament B bekommen haben (z.B. geschlecht == \"weiblich\" & drug == \"B\").\n\n5.5.3.1 Vektoren\nVektoren werden immer elementweise verglichen, das hei√üt, dass das Ergebnis von c(1, 2) == 1 nicht FALSE oder TRUE ist, sondern der logische Vektor TRUE FALSE. Dadurch entsteht durch den logischen Vergleich eines Vektors ein Vektor aus TRUE und FALSE, den wir zum indizieren benutzen k√∂nnen, wie wir weiter oben schon gesehen haben.\n\nCode# Irgendwelche Zahlen\nx <- c(4, 7, 2, 1, 7, 9, 6, 5, 4, 3, 3, 2, 2, 5, 8, 9, 31)\n\n# Alle Zahlen gr√∂√üer 4: \"Gib mir x, wo x > 4\"\nx[x > 4]\n#> [1]  7  7  9  6  5  5  8  9 31\n\n# Die Logik dahinter\nx > 4\n#>  [1] FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n#> [13] FALSE  TRUE  TRUE  TRUE  TRUE\n\n# Alle Zahlen gr√∂√üer 5 und kleiner 20\nx[x > 5 & x < 20]\n#> [1] 7 7 9 6 8 9\n\n\nDas Ganze l√§sst sich nat√ºrlich beliebig komplex aussehen lassen, weshalb zu viele Bedingungen in Kombination etwas verwirrend aussehen k√∂nnen.\nWeiterhin k√∂nnen wir einen Vektor nat√ºrlich auch durch einen Vergleich eines anderen Vektors indizieren.\n\nCodex <- c(4, 7, 2, 1, 7, 9, 6, 5, 4, 3)\ny <- c(6, 7, 10, 1, 9, 3, 6, 5, 6, 3)\n\n# x, wo x gr√∂√üer gleich 4 ist *und* y kleiner 6\nx[x >= 4 & (y < 6)]\n#> [1] 9 5\n\n# x, wo x und y identisch sind\nx[x == y]\n#> [1] 7 1 6 5 3\n\n# x, wo x kleiner y ist\nx[x < y]\n#> [1] 4 2 7 4\n\n\n\n5.5.3.2 Tabellen data.frame\n\nTabellenindexing ist nichts anderes als Vektorindexing mit einer anderen Struktur. Alle Regeln zum Vektorindexing, die wir bisher gesehen haben, gelten auch so f√ºr data.frames, nur dass wir hier jetzt auf einmal in Spalten und Zeilen denken m√ºssen, anstatt in Vektoren."
  },
  {
    "objectID": "chapters/05-datentypen.html",
    "href": "chapters/05-datentypen.html",
    "title": "\n6¬† Datentypen\n",
    "section": "",
    "text": "Es gibt eine Reihe von Unterscheidungsm√∂glichkeiten zwischen verschiedenen Arten von Daten.\nNeben der naheliegenden Unterscheidung zwischen ‚ÄúZahlen‚Äù und ‚ÄúBuchstaben‚Äù gibt es diverse andere Typen, die R verwendet.\nTechnisch gesehen m√ºssten wir hier noch zwischen Typen und Klassen unterscheiden, aber f√ºr die meisten unserer normalen Anwendungszwecke ist es nicht unbedingt notwendig Typen und Klassen auseinanderhalten zu k√∂nnen, weshalb wir hier auch mehr oder weniger beides gleichzeitig abhandeln.\n‚ÄúUnd wieso sollte uns interessieren, wie R da unterscheidet?‚Äù\nR ist verwirrt, wenn wir Buchstaben in eine Funktion stecken, die Zahlen erwartet. Genauso ist R verwirrt, wenn wir den Mittelwert aus einer Tabelle berechnen wollen. Mittelwerte sind nur dann sinnvoll, wenn wir sie aus einem Vektor aus numerischen Werten berechnen. Da eure Daten in verschiedenen Formaten ankommen, und unterschiedliche Repr√§sentationen unterschiedliche Vor- und Nachteile haben, ist es wichtig, dass ihr im Zweifelsfall herausfinden k√∂nnt was ihr da vor der Nase habt und wie ihr damit arbeiten k√∂nnt.\nWas eine R-Funktion mit einem Objekt anstellt h√§ngt von der Klasse des Objekts ab, das ganze f√§llt vermutlich irgendwo unter ‚Äúobject oriented programming‚Äù, und wenn ihr InformatikerInnen kennt und die euch Fragen, ob R eine funktionale oder objektorientierte Frage ist, k√∂nnt ihr getrost ‚Äúja‚Äù sagen1.\nDie wichtigste Funktion f√ºr diesen Abschnitt ist class(), was euch sagt was R unter einem bestimmten Objekt versteht (die Klasse des Objekts):\n(Was es mit factor auf sich hat sehen wir ein paar Abschnitte weiter)\nZus√§tzlich gibt es typeof(), eine Funktion, die so speziell ist, dass ich sie in meinen ~4 Jahren R erst neulich entdeckt habe, weil der exakte Typ eines Objekts meistens weniger relevant ist als die Klasse:"
  },
  {
    "objectID": "chapters/05-datentypen.html#numeric-zahlen-und-so",
    "href": "chapters/05-datentypen.html#numeric-zahlen-und-so",
    "title": "\n6¬† Datentypen\n",
    "section": "\n6.1 Numeric (Zahlen und so)\n",
    "text": "6.1 Numeric (Zahlen und so)\n\nZahlen in R (und in den meisten anderen Programmiersprachen, beziehungsweise generell irgendwo, wo Maschinen rechnen) kommen in zwei Geschmacksrichtungen: Integer (ganze Zahlen) und double (Dezimalzahlen, Flie√ükommazahlen, floating point numbers).\nDer Grund daf√ºr hat damit zu tun, wie Computer intern Zahlen abbilden, bin√§res Zahlensystem, Bits, ihr wisst schon ‚Äî komplizierter Kram wo sich kluge Menschen Dinge ausdachten, mit denen wir arbeiten k√∂nnen, wir aber nicht im Detail verstehen m√ºssen.\nFlie√ükommazahlen sind so g√§ngig, dass R sogar eine einfache ganze Zahl wie 2 erstmal als double, also praktisch als 2.0 interpretiert, und wir explizit 2L schreiben m√ºssen, wenn wir ‚Äú2, aber als integer‚Äù meinen. Wieso wir daf√ºr L brauchen sei dahingestellt, aber nun ja, der Unterschied ist da:\n\nCode# Beides \"numeric\"\nclass(2)\n#> [1] \"numeric\"\nclass(2.5)\n#> [1] \"numeric\"\n\n# Aber‚Ä¶\ntypeof(2L)\n#> [1] \"integer\"\n\n# ‚Ä¶und\ntypeof(2.5)\n#> [1] \"double\"\n\n\nIntegers sind ziemlich unproblematisch, werden aber in der Praxis nicht h√§ufig explizit genutzt.\nFlie√ükommazahlen (double) hingegen tauchen h√§ufiger auf, weil Computer in den letzten Jahrzehnten echt verdammt gut darin geworden sind, mit Flie√ükommazhalen zu rechnen. Arithmetik mit integers ist auch okay, aber wenn eure Datens√§tze riesig und eure Statistik komplex ist, dann ist Geschwindigkeit von Rechenoperationen auf ein mal ein wichtiger Faktor.\nDas Problem an der Sache ist nur leider, dass Flie√ükommazahlen seltsam sind. Nicht nur vom initialen Verst√§ndnis her, dazu empfehle ich euch herzlichst dieses sch√∂ne Video von Tom Scott, sondern auch f√ºr ganz reale Konsequenzen, √ºber die wir stolpern k√∂nnen, wenn wir nicht aufpassen:\n\nCode# Wurzel aus 2, ganz harmlos\nsqrt(2)\n#> [1] 1.414214\n\n# Quadrierte Wurzel aus 2 ergibt 2, ja, kommt hin\nsqrt(2)^2\n#> [1] 2\n\n# Das sollte ja dann‚Ä¶\nsqrt(2)^2 == 2\n#> [1] FALSE\n\n\nWait, what?\nUnd das ist der Grund warum Flie√ükommazahlen (double) seltsam sind.\nDie kurze Version: \\(\\sqrt{2}\\) ist eine irrationale Zahl, das hei√üt sie hat unendlich viele Nachkommastellen. Computer k√∂nnen nur eine begrenzte Anzahl an Nachkommastellen speichern, weshalb das Resultat von einer Berechnung wie \\(\\left(\\sqrt{2}\\right)^2\\) zwar f√ºr alle praktischen Zwecke immer noch 2 ist, aber irgendwie auch nicht. Wenn wir mit Datens√§tzen arbeiten und darin rumrechnen dann sind solche kleinen Rundungsfehler egal, aber wenn wir uns auf Operatoren wie == verlassen, um berechnete Werte zu vergleichen, dann m√ºssen wir vorsichtig sein.\nAn dieser Stelle ein kurzer Exkurs in die Numerik:\nDie absolut kleinste Toleranz, die euer Computer f√ºr Flie√ükommazahlen ber√ºcksichtigt, k√∂nnt ihr euch mit .Machine$double.eps anzeigen lassen2. .Machine ist ein besonderes Objekt in R, dass Informationen zu eurem Computer (sprich eurer Maschine) sammelt.\n\nCode# Wie gro√ü ist die Abweichung vom erwarteten Ergebnis?\nsqrt(2)^2 - 2\n#> [1] 4.440892e-16\n\n\n4.4408920985e-16 ist Computer f√ºr \\(4.4408920985 \\cdot 10^{-16}\\), also ungef√§hr‚Ä¶\n\\[\\frac{4.4408920985}{10000000000000000} \\approx 0.00000000000000044\\]\nDas ist‚Ä¶ ziemlich wenig, und im Alltag auch ziemlich egal, aber wie gesagt: F√ºr R ist das ein Unterschied.\n\nCode# Wie gro√ü ist die Toleranz?\n.Machine$double.eps\n#> [1] 2.220446e-16\n\n# Moment mal‚Ä¶\n.Machine$double.eps * 2\n#> [1] 4.440892e-16\n\n# Wenn jetzt‚Ä¶\n(.Machine$double.eps * 2) == (sqrt(2)^2 - 2)\n#> [1] TRUE\n\n\nTatsache.\nWir k√∂nnten noch weiter damit rumspielen, aber als Lektion sollte eigentlich nur h√§ngenbleiben, dass Zahlen in R gerne mal mehr sind, als euch in der Konsole angezeigt wird.\n\n\n\n\n\n\nNote\n\n\n\n\nOne does not simply round floating point numbers ‚Äî Programmer Boromir\n\n\n\nWenn ihr mal auf sowas sto√üen solltet, dann verwendet am besten einfach die Funktion round() um eure Werte auf eine sinnvolle Anzahl Nachkommastellen zu runden:\n\nCode# Auf 5 Stellen gerundete Wurzel 2\nround(sqrt(2), digits = 5)\n#> [1] 1.41421\n\n# Gerundetes Ergebnis von \"Wurzel 2 hoch 2\"\nround(sqrt(2)^2, digits = 5)\n#> [1] 2\n\n# Literally close enough.\nround(sqrt(2)^2, digits = 5) == 2\n#> [1] TRUE\n\n\n\n\n\n\n\n\nNote\n\n\n\nIm Zweifelsfall einfach Genauigkeit opfern um den Verstand zu behalten\n\n\nTheoretisch ist ‚Äúnumeric‚Äù f√ºr Zahlen eine Klasse, und integer und double sind die beiden Typen, aus denen die Klasse besteht."
  },
  {
    "objectID": "chapters/05-datentypen.html#character-buchstabenzeugs",
    "href": "chapters/05-datentypen.html#character-buchstabenzeugs",
    "title": "\n6¬† Datentypen\n",
    "section": "\n6.2 Character (Buchstabenzeugs)\n",
    "text": "6.2 Character (Buchstabenzeugs)\n\nCharacters sind Strings sind irgendwas was aus mehr als nur Zahlen besteht (zumindest meistens). Die Unterscheidung zwischen numeric und character ist intuitiv ziemlich einfach, und in eurer statistischen Praxis werdet ihr vermutlich meistens auf numerics treffen, wobei characters dann meistens nur f√ºr nominale Variablen (Gruppenzugeh√∂rigkeiten, Entscheidungen f√ºr A, B, C) gebraucht werden. Tats√§chlich werden eure nominalen Variablen sogar eher als factor daherkommen, dazu dann der n√§chste Abschnitt.\nCharacters verhalten sich im Grunde wie Worte. Wir k√∂nnen sie aneinanderh√§ngen, wir k√∂nnen sie vergleichen, aber wir k√∂nnen zum Beispiel keine Berechnungen damit durchf√ºhren:\nnamen <- c(\"Lukas\", \"Tobias\", \"Christoph\")\nmean(namen)\n#> Warning in mean.default(namen): argument is not numeric or logical:\n#> returning NA\n#> [1] NA\n\n# Zahlen != Buchstaben\n5 == \"5\"\n#> [1] TRUE\n\n# Gro√ü- / Kleinschreibung ist wichtig!\n\"Lukas\" == \"Lukas\"\n#> [1] TRUE\n\"Lukas\" == \"LUKAS\"\n#> [1] FALSE\n\n# Strings aneinanderh√§ngen\npaste(\"Lukas\", \"hat\", \"Spass\", sep = \"_\")\n#> [1] \"Lukas_hat_Spass\"\nDie Funktionen paste und paste0 sind ziemlich praktisch wenn ihr mit Strings arbeitet, die werdet ihr fr√ºher oder sp√§ter mal brauchen.\nAnsonsten d√ºrfte euch aufgefallen sein, dass man Spa√ü mit √ü schreibt. Das ist korrekt. Allerdings z√§hlt √ü als Sonderzeichen, genauso wie Umlaute (√º√∂√§). R kann damit zwar prinzipiell umgehen, solange ihr das richtige Encoding verwendet, aber dennoch bietet es sich an auf Sonderzeichen in R-Code zu verzichten, um Inkompatibilit√§t mit anderen vorzubeugen.\nUm eure Einstellungen anzupassen und auf Nummer sicher zu gehen, √∂ffnet die Einstellungen von RStudio und setzt die folgende Einstellung auf UTF-8 (Unicode):\n\n\n\n\nRStudio > Optionen > Code > Saving: UTF-8\n\n\n\n\nEncoding ist so der einfachste Grund aus dem eure Scripte und Dokumente auf einmal kaputt aussehen, wenn ihr sie von einem Windows-Rechner an einen Mac oder eine Linux-Kiste schickt. Mac und Linux k√∂nnen sich wenigstens meistens auf Unix-Standards und Unicode eignen, aber Windows‚Ä¶ Windows ist seltsam.\n\n\n\n\n\n\nNote\n\n\n\nEncoding ist kodifizierter Selbsthass, aber Unicode ist gro√üer Spa√ü"
  },
  {
    "objectID": "chapters/05-datentypen.html#factor-here-be-dragons",
    "href": "chapters/05-datentypen.html#factor-here-be-dragons",
    "title": "\n6¬† Datentypen\n",
    "section": "\n6.3 Factor (Here be dragons)\n",
    "text": "6.3 Factor (Here be dragons)\n\nOkay, der haarige Teil.\nDie factor-Klasse in R ist unheimlich praktisch, aber auch ziemlich unintuitiv bei der ersten Verwendung. Das liegt nicht zuletzt daran, dass ein factor von aussehen meistens einfach aussieht wie ein character, aber nunmal kein character ist.Factors haben zwei Bestandteile:\n\n\nlevel: Die Merkmalsauspr√§gung, so wie R den factor sieht. Meistens numeric.\n\nlabel: (Optional) Die Bezeichnung der Merkmalsauspr√§gungen, meistens character, f√ºr die bessere Lesbarkeit.\n\nEin Beispiel aus dem sleep-Datensatz:\n\nCode# Die Vairable \"group\"\nsleep$group\n#>  [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2\n#> Levels: 1 2\n\n# ‚Ä¶hat die Klasse \"factor\"\nclass(sleep$group)\n#> [1] \"factor\"\n\n# Und die levels‚Ä¶\nlevels(sleep$group)\n#> [1] \"1\" \"2\"\n\n\nWir sehen, dass group die Merkmalsauspr√§gungen (levels) 1 und 2 hat, aber das ist f√ºr uns m√∂glicherweise nicht wirklich aussagekr√§ftig. Wir k√∂nnen die Variable modifizieren, und einen sch√∂neren factor daraus machen:\n\nCode# Wir modifizieren nur die labels, nicht die level\nsleep$group <- factor(sleep$group, levels = c(1, 2), labels = c(\"Medikament A\", \"Medikament B\"))\n\n# Jetzt werden uns unsere Labels angezeigt\nsleep$group\n#>  [1] Medikament A Medikament A Medikament A Medikament A Medikament A\n#>  [6] Medikament A Medikament A Medikament A Medikament A Medikament A\n#> [11] Medikament B Medikament B Medikament B Medikament B Medikament B\n#> [16] Medikament B Medikament B Medikament B Medikament B Medikament B\n#> Levels: Medikament A Medikament B\n\n# Und unsere unver√§nderten Levels\nlevels(sleep$group)\n#> [1] \"Medikament A\" \"Medikament B\"\n\n# Aber wir k√∂nnen den factor immer noch wie Zahlen behandeln\nas.numeric(sleep$group)\n#>  [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2\n\n\nMit factor k√∂nnen wir praktisch zwei Lagen an Informationen in nur einer Variable speichern, einmal numerische levels und einmal character labels. Die Levels sind die eigentlich wichtige Information und die Labels sind praktisch nur f√ºr uns zur besseren Lesbarkeit da, zum Beispiel bei Tabellen oder Grafiken."
  },
  {
    "objectID": "chapters/05-datentypen.html#besondere-typen",
    "href": "chapters/05-datentypen.html#besondere-typen",
    "title": "\n6¬† Datentypen\n",
    "section": "\n6.4 Besondere Typen",
    "text": "6.4 Besondere Typen\nEure Daten kommen meistens von anderen, zumindest in den ersten Semestern eures Studiums.\nMeistens kommen eure Daten auch mit Fehlenden oder irgendwie kaputten Werten, mit denen ihr ohne Weiteres nichts anfangen k√∂nnt.\n\n6.4.1 Fehlende Werte: NA\n\nVermutlich der wichtigste Datentyp, der euch begegnen wird. NA steht f√ºr Not Available und hei√üt, dass es an dieser Stelle einfach keinen Wert gibt. In einem Fragebogen w√§re das zum Beispiel eine nicht ausgef√ºllte Frage, und das hei√üt f√ºr euch, dass ihr ohne Weiteres keine Annahme √ºber diese Wert machen k√∂nnt. NA hei√üt nicht ‚Äúda ist nichts‚Äù, sondern eher ‚Äúda k√∂nnte was sein, aber ich wei√ü nicht‚Äù.\nDas ist auch der Grund, warum der Mittelwert nicht funktioniert, wenn da NA drinstecken:\n\nCodemean(c(1, 2, NA, 4, 5, NA, 7))\n#> [1] NA\n\n\nKlar k√∂nnten wir einfach annehmen, dass die fehlenden Werte 3 und 6 sind, aber das wissen wir nunmal nicht, und da R in der Regel nicht r√§t, sagt es halt auch ‚Äúwei√ü nicht‚Äù in Form von NA.\nIn solchen F√§llen m√ºsst ihr explizit NA ignorieren:\n\nCodemean(c(1, 2, NA, 4, 5, NA, 7), na.rm = TRUE)\n#> [1] 3.8\n\n\nIhr k√∂nnt auch mit der Funktion is.na pr√ºfen, ob ihr fehlende Werte habt. Beachtet, dass == zum vergleichen nicht funktioniert!\n\nCodezahlen <- c(1, 2, NA, 4, 5, NA, 7)\n\nis.na(zahlen)\n#> [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE\n\n# Alle 'zahlen', f√ºr die is.na() _nicht_ TRUE ist\nzahlen[!is.na(zahlen)]\n#> [1] 1 2 4 5 7\n\n# An welcher Position sind die NAs?\nwhich(is.na(zahlen))\n#> [1] 3 6\n\n\n\n6.4.2 Leere Werte: NULL\n\nWenn NA fehlende Werte sind, was soll dann NULL sein?\nNaja, ich merke mir das immer ungef√§hr so:\n\n\nNULL: Da ist nichts, also so wirlich nichts, und ich wei√ü das auch!\n\nNA: Da ist zwar nichts, aber ich hab keine Ahnung ob da nicht doch was sein sollte ¬Ø\\_(„ÉÑ)_/¬Ø\n\nNULL wird euch vermutlich weniger h√§ufig begegnen als NA, zumindest in Datens√§tzen.\nAnsonsten taucht NULL eher bei R-Funktionen als default argument auf, also ein Argument einer Funktion, das nicht gesetzt ist, au√üer ihr setzt es explizit. Das klingt jetzt etwas abstrakt, aber wir werden im Laufe dieser Einf√ºhrung vermutlich noch Beispiele daf√ºr sehen.\n\n\n\n\n\n\nNote\n\n\n\nNULL ist leer, und zwar mir SicherheitNA ist leer, aber man wei√ü es nicht so recht\n\n\n\n6.4.3 To Inf and BeyoNaNd!\nHabt ihr schonmal durch 0 geteilt? Oder √ºberlegt was \\(0^0\\) ist?\nDas ist die Ecke, in der Inf und NaN auftauchen.\nInf und -Inf stehen erstmal nur f√ºr \\(\\infty\\) und \\(-\\infty\\) und sind Rs Weg euch zu sagen, dass ihr da gerade den Bereich der alltagstauglichen Zahlen √ºberschritten habt.\nNehmt mal folgendes Beispiel:\n\nCode# 2 hoch 10‚Ä¶ geht noch\n10^10\n#> [1] 1e+10\n\n# Auch das‚Ä¶\n10^100\n#> [1] 1e+100\n\n# Okay, aber jetzt‚Ä¶\n10^1000\n#> [1] Inf\n\n\nDas ist R einfach zu viel, bzw. es ist eurem Computer generell zu viel.\nKurzer reminder: 1e10 ist Computer f√ºr \\(1 \\cdot 10^{10}\\), also eine 1 mit 10 Nullen, also‚Ä¶\n\\[1e10 = 1 \\cdot 10^{10} = 10000000000\\]\nDementsprechend k√∂nnt ihr euch vorstellen, wie gro√ü \\(10^{1000}\\) w√§re, und R macht solche Sp√§√üe nicht mit und sagt einfach Inf.\nWenn ihr Inf oder -Inf in euren Ergebnissen seht, dann solltet ihr nur wissen, dass es da ein entweder viel zu gro√ües oder viel zu kleines Ergebnis gab.\nUnd dann ist da noch die Sache mit NaN.NaN steht f√ºr not a number und passiert dann, wenn ihr irgendwas mathematisch fragw√ºrdiges macht, wie zum Beispiel 0 durch 0 teilen:\n\nCode0 / 0\n#> [1] NaN\n\n\nDas ist mathematisch nicht definiert, und wieso das so ist und mehr dazu findet ihr zum Beispiel bei Numberphile gut erkl√§rt.\nHier solltet ihr auch nur wissen, dass es das gibt und dass ihr es im Zweifelsfall vermeiden wollt, wenn es in euren Ergebnissen auftaucht."
  },
  {
    "objectID": "chapters/05-datentypen.html#tabellen-data.frame",
    "href": "chapters/05-datentypen.html#tabellen-data.frame",
    "title": "\n6¬† Datentypen\n",
    "section": "\n6.5 Tabellen: data.frame\n",
    "text": "6.5 Tabellen: data.frame\n\nAll eure Datens√§tze im Studium kommen in Tabellenform.\nTabellen in R sind im Grunde nichts anderes als Listen von Vektoren mit gleiche L√§nge: Der sleep-Datensatz zum Beispiel besteht aus drei Vektoren der L√§nge 20, und jede Spalte verh√§lt sich wie ein Vektor mit bestimmten Typen.\nUm sich einen √úberblick √ºber einen Datensatz zu verschaffen empfiehlt sich die Funktion str (lies structure), oder auch head:\n\nCode# Die ersten paar Zeilen\nhead(sleep)\n#>   extra        group ID\n#> 1   0.7 Medikament A  1\n#> 2  -1.6 Medikament A  2\n#> 3  -0.2 Medikament A  3\n#> 4  -1.2 Medikament A  4\n#> 5  -0.1 Medikament A  5\n#> 6   3.4 Medikament A  6\n\n# Nur die ersten 2 Zeilen\nhead(sleep, n = 2)\n#>   extra        group ID\n#> 1   0.7 Medikament A  1\n#> 2  -1.6 Medikament A  2\n\n# Struktur des Datensatzes\nstr(sleep)\n#> 'data.frame':    20 obs. of  3 variables:\n#>  $ extra: num  0.7 -1.6 -0.2 -1.2 -0.1 3.4 3.7 0.8 0 2 ...\n#>  $ group: Factor w/ 2 levels \"Medikament A\",..: 1 1 1 1 1 1 1 1 1 1 ...\n#>  $ ID   : Factor w/ 10 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10 ...\n\n\nDas Output von str sagt euch alles, was ihr braucht:\n\nDie Klasse des Objekts, hier ein data.frame, das Tabellenformat\n\nDie Anzahl der Zeilen (20 obs.), und Spalten (3 variables)\n\n\nDie Spalten der Tabelle mit den ersten Werten\n\n\nextra: Numerisch (num)\n\ngroup: factor mit 2 Merkmalsauspr√§gungen (w/ 2 levels), die Labels und die Levels\n\n\nID: factor mit 10 Labels (\"1\", \"2\", \"3\" ‚Ä¶) und Levels (1 2 3 4 ‚Ä¶)\n\n\n\nSp√§ter werden wir noch andere Klassen f√ºr Tabellen sehen, die data.frame erweitern bzw. etwas aufh√ºbschen, namentlich wird das tbl_df bzw. tibble sein, aber dazu m√ºssen wir uns erst Packages ansehen."
  },
  {
    "objectID": "chapters/05-datentypen.html#convert",
    "href": "chapters/05-datentypen.html#convert",
    "title": "\n6¬† Datentypen\n",
    "section": "\n6.6 Pr√ºfen & Konvertieren",
    "text": "6.6 Pr√ºfen & Konvertieren\nWas wir im Abschnitt zu factor am Ende mit as.numeric gemacht haben f√§llt unter Coercion, und hei√üt, dass Werte eines Typs in einen anderen Typ konvertiert werden sollen. Das Gegenst√ºck dazu w√§re is.numeric, was nachsieht, ob eine Variable bereits numeric ist.\n\nCodeas.numeric(\"5\")\n#> [1] 5\nas.numeric(5)\n#> [1] 5\n\nis.numeric(\"5\")\n#> [1] FALSE\nis.character(10)\n#> [1] FALSE\n\nas.character(c(2, 5, 4, 3))\n#> [1] \"2\" \"5\" \"4\" \"3\"\n\n\nEs gibt etliche solcher Konvertierungsfunktionen in R, manche mehr oder weniger n√ºtzlich, aber nun gut, sie sind da:\n\nCode# R√∂mische Zahlen\nas.roman(2017)\n#> [1] MMXVII\n\n# Hexadezimal\nas.hexmode(255)\n#> [1] \"ff\"\n\n# Logische Werte\nas.logical(0)\n#> [1] FALSE\nas.logical(1)\n#> [1] TRUE"
  },
  {
    "objectID": "chapters/06-packages.html",
    "href": "chapters/06-packages.html",
    "title": "\n7¬† Packages\n",
    "section": "",
    "text": "Fast jede Software hat Erweiterungen irgendeiner Art. Manche haben extensions, andere plug-ins, wieder andere haben add-ons. Unterschiedliche Terminologie f√ºr dasselbe Prinzip: Mehr Features durch Erweiterungen anderer Leute.\nBei Programmiersprachen hei√üt sowas meistens library oder package1.\nR hat sowas nat√ºrlich auch, als popul√§re open-source Software. Hier hei√üt sowas packages und besteht aus Funktionen, die andere Leute f√ºr bestimmte Anwendungsf√§lle geschrieben haben, und durch ein Verteilungssystem verf√ºgbar machen, sodass wir alle sie benutzen k√∂nnen.\nDer Kern von R wird auch base genannt und umfasst die wichtigstens Grundfunktionen ‚Äî mit denen kommen wir auch schon relativ weit, wir k√∂nnen zum Beispiel problemlos diverse Statistiken berechnen und sogar Visualisierungen machen, aber wir wollen nat√ºrlich mehr, einfacher, schneller und besser."
  },
  {
    "objectID": "chapters/06-packages.html#installieren-laden-updaten",
    "href": "chapters/06-packages.html#installieren-laden-updaten",
    "title": "\n7¬† Packages\n",
    "section": "\n7.1 Installieren, Laden, Updaten",
    "text": "7.1 Installieren, Laden, Updaten\nPackages ladet ihr aus dem Internet runter, woraufhin sie ggf. kompiliert und in eure R-library eingepflegt werden m√ºssen.\nDas klingt kompliziert, und deshalb passiert das auch alles automatisch!\nWir installieren ein package mit einem einfachen Befehl in der Konsole:\ninstall.packages(\"ggplot2\")\n\n\n\n\n\n\nNote\n\n\n\nWindows-BenutzerInnen: Wenn ihr Antivirus-Software benutzt (Norton, Kaspersky, whatever) kann es sein dass diese euch beim installieren st√∂rt. Ihr bekommt dann wenig aussagekr√§ftige Fehler. Schaltet eure Antivirus-Software aus wenn ihr Probleme bei der Installation habt.\n\n\nAchtet darauf, dass ihr Gro√ü- und Kleinschreibung beachtet habt, und dass der Name des packages in \" \" steht (wie ein character).\nWenn ihr Enter gedr√ºckt habt sollte R anfangen loszur√∂deln, vielelicht gehen auch einige Fenster mit Fortschrittsbalken auf, wenn ihr Windows benutzt.\nDas sch√∂ne an diesem Befehl ist, dass es auch direkt alle packages installiert, die wir in unserem package benutzen: Sogenannte dependencies. Eine dependency (Abh√§ngigkeit) ist in diesem Kontext ein package, das von einem anderen package gebraucht wird um zu funktionieren. Wir benutzen im package tadaatoolbox zum Beispiel auch die packages dplyr, pixiedust und sjlabelled, deswegen sollte der Befehl diese packages auch gleich mitinstallieren.\nAlternativ k√∂nnt ihr rechts in RStudio im ‚ÄúPackages‚Äù-Tab den ‚ÄúInstall‚Äù-Button dr√ºcken, den namen des packages (tadaatoolbox) eingeben, und dann macht RStudio im Hintergrund genau dasselbe Spielchen mit install.packages().\nIn diesem Fenster ist auch von Repositories die Rede. Damit ist der Web-Adresse gemeint, von der die packages geladen werden sollen. RStudio sollte da automatisch die schnellste Quelle ausw√§hlen, aber wenn ihr mal in die Verlegenheit kommt euch entscheiden zu m√ºssen, versucht am besten folgende Adresse:\nhttps://cloud.r-project.org\nUnd da packages auch nur Software sind, und Software auf dem aktuellen Stand gehalten werden will, bietet es sich an sporadisch (sp√§testens alle paar Monate) mal den Update-Button zu dr√ºcken und einfach alles zu aktualisieren, was aktualisiert werden kann.\nDas k√∂nnt ihr auch aus der Konsole heraus machen indem ihr den Befehl update.packages(ask = FALSE) ausf√ºhrt. R fragt euch dann, ob ihr sicherheitshalber R neustarten wollt, das k√∂nnt ihr tun oder auch nicht, aber wenn ihr es nicht tut, dann solltet ihr auf jeden Fall die R-Session neu starten nachdem ihr alle Updates gemacht habt (RStudio -> Session -> Restart R).\nWieso? Nun ja, packages werden von R geladen, das hei√üt verf√ºgbar gemacht, und wenn ihr ein package ersetzt (was beim Update passiert), dann zieht ihr damit R praktisch den Boden unter den F√º√üen weg und es ist sauer weil Dinge anders sind, als sie eben noch waren.\nDieses ‚Äúverf√ºgbar machen‚Äù sieht √ºbrigens so aus:\nlibrary(ggplot2)\nWenn ihr diesen Befehl ausgef√ºhrt hat, dann l√§d R f√ºr die aktuelle Session das package und ihr k√∂nnt die Funktionen darin benutzen.\nNormalerweise beginnen eure R-Scripte mit einer Reihe von library()-Befehlen um eure Analyse vorzubereiten und alle ben√∂tigten packages zu laden, da ihr diesen Schritt jedes mal wiederholen m√ºsst, wenn ihr eine neue R-Session starten (z.B. beim Neustart von RStudio, Computerneustart etc.).\nAu√üerdem gebt ihr so euren KommilitonInnen eine gute Gelegenheit abzusch√§tzen, was in eurem Script so passiert, wenn sie direkt erkennen k√∂nnen, welche packages ihr daf√ºr benutzt habt.\nEs gibt tausende R-packages, und die meisten davon sind f√ºr euch vollkommen uninteressant, aber einige wiederum sind so derma√üen praktisch, dass wir sie uns hier im Detail anschauen.\n\n7.1.1 Quellen\nDie wichtigste Quelle f√ºr R-packages ist das erw√§hnte CRAN, kurz f√ºr ‚ÄúComprehensive R Archive Network‚Äù. Packages m√ºssen diverse Anforderungen erf√ºllen, um auf CRAN publiziert zu werden, was eine gewisse H√ºrde darstellt. Deswegen gibt es diverse packages, die gerade in fr√ºhen, potenziell noch nicht ausgereiften Versionen an anderen Stellen verf√ºgbar gemacht werden.\nDie wohl popul√§rster dieser Sekund√§rquellen ist GitHub.\nOptional k√∂nnt ihr packages auch direkt von GitHub installieren, was insbesondere dann interessant ist, wenn das package noch jung und experimentell ist.\nIn euren normalen Projekten solltet ihr euch nicht auf GitHub-packages verlassen, sondern nach M√∂glichkeit ausschlie√ülich packages von CRAN benutzen, aber wenn euch nach Abenteuer ist, dann f√ºhlt euch frei:\n# Wir brauchen das devtools package\ninstall.packages(\"remotes\")\n\n# remotes package laden\nlibrary(remotes)\n\n# install_github ist eine Funktion aus dem remotes package\ninstall_github(\"tadaadata/tadaatoolbox\")\n\n7.1.2 Maintenance\nPackages installieren ist einfach, aber wie jede Software wollen auch R-packages auf dem neusten Stand gehalten werden. Oder zumindest auf einem ‚Äúnicht total veraltet‚Äù-Stand.\nUpdaten ist ziemlich einfach:\nEntweder ihr klickt im ‚ÄúPackages‚Äù-Tab von RStudio auf den ‚ÄúUpdate‚Äù-Button, w√§hlt alle Packages aus und installiert die Updates so, oder ihr gebt in der Konsole folgendes ein:\nupdate.packages(ask = FALSE)\n‚Ä¶dann r√∂delt R die Updates durch. RStudio wird euch an dieser Stelle fragen, ob ihr die R-Session vorher neustarten wollt ‚Äì das k√∂nnt ihr tun, aber er k√∂nnt damit auch warten bis ihr alle Updates installiert habt anstatt f√ºr jedes einzelne Update die Session neuzustarten.\nWichtig ist auf jeden Fall, dass ihr die R-Session neustartet bevor ihr weiter arbeitet.\n\n\n\n\n\n\nNote\n\n\n\nWenn ein package geladen (library()) ist w√§hrend ihr Updates durchf√ºhrt, muss die R-Session danach neugestartet werden! Wenn ein package aktualisiert wird w√§hrend es geladen ist macht das R sehr traurig und Fehler treten auf.\nRStudio ‚Äì> Session ‚Äì> Restart R\n\n\nSolltet ihr mal ein package l√∂schen wollen, aus welchem Grund auch immer, dann geht das entweder auch √ºber den Package-Tab in RStudio (das Kreuzchen rechts neben dem Namen des packages), oder ihr gebt folgendes in der Konsole ein:\nremove.packages(\"ggplot2\")\n‚Ä¶um das package ggplot2 zu deinstallieren.\nAber wieso solltet ihr das tun wollen.\nWieso nur.\nIhr Monster.\n\n7.1.2.1 Tabellen\nF√ºr Kreuztabellen, wie wir sie relativ h√§ufig in QM1 brauchen f√ºr unsere nominal- und ordinalskalierten Statistiken:\n\n\n\nOder einfache H√§ufigkeitstabellen:\nUnd f√ºr lineare Modelle, in deutlich sch√∂ner als summary():\n\nCodemodel <- lm(zufrieden ~ alter * berufsvorstellung, data = qmsurvey)\n\n\n\n7.1.2.2 Plots\nKlassiker: Histogramm mit Normalverteilungskurve:"
  },
  {
    "objectID": "chapters/06-packages.html#das-tidyverse",
    "href": "chapters/06-packages.html#das-tidyverse",
    "title": "\n7¬† Packages\n",
    "section": "\n7.2 Das tidyverse\n",
    "text": "7.2 Das tidyverse\n\nDas tidyverse ist eine Ansammlung von packages, die alle mehr oder weniger gut miteinander auskommen und auf √§hnliche Art zu benutzen sind.\nEine √úbersicht und ganz viel Dokumentation und Beispiele findet ihr auf https://tidyverse.org.\nEs gibt ein catchall R-package, das die wichtigstens packages f√ºr euch installiert:\ninstall.packages(\"tidyverse\")\nIhr k√∂nnt danach entweder das package laden und habt damit die wichtigsten Funktionen parat, oder ihr ladet die packages nach Bedarf einzeln.\nIch w√ºrde zu letzterem raten, weil ihr so eher ein Gef√ºhl daf√ºr bekommt welches package f√ºr welche Funktionen zust√§ndig ist, und nebenbei geht es auch ein bisschen schneller.\nHier eine kurze √úbersicht √ºber die wichtigsten tidyverse-packages/Funktionen f√ºr allt√§gliche Aufgaben:\n\n\n%>%: Der pipe-Operator aus magrittr, der von den meisten der packages re-exportiert wird\n\nggplot2: F√ºr Visualisierungen\n\ndplyr: Datenmanipulation\n\n\nmutate: Neue Variablen erstellen/ bestehende Ver√§ndern\n\nselect: Variablen ausw√§hlen\n\nfilter: Datens√§tze filtern\n\ngroup_by: Gruppieren‚Ä¶\n\nsummarize: Und zusammenfassen\n\n\n\ntidyr: Datenmanipulation\n\n\ngather: Konvertiert von wide in long format (mehrere Spalten zu zwei zusammenfassen)\n\nspread: Gegenst√ºck, konvertiert von long in wide format"
  },
  {
    "objectID": "chapters/06-packages.html#die-tadaatoolbox",
    "href": "chapters/06-packages.html#die-tadaatoolbox",
    "title": "\n7¬† Packages\n",
    "section": "\n7.3 Die tadaatoolbox\n",
    "text": "7.3 Die tadaatoolbox\n\nDie tadaatoolbox ist das Produkt von Lukas‚Äô und Tobis Frustration mit diversem Kleinkram in R, wie etwa der Optik von statistischen Testoutput.\nIm Fokus steht in erster Linie schnelles, einfaches Output mit m√∂glichst wenig Aufwand. Zus√§tzlich bietet die Toolbox einige Sammelfunktionen um beispielsweise diverse nominal- oder ordinalskalierte Statistiken auf einen Rutsch anzuzeigen, optimiert auf Output in RMarkdown-Dokumenten (Siehe [Berichte])."
  },
  {
    "objectID": "chapters/06-packages.html#addendum-installier-mal-alles",
    "href": "chapters/06-packages.html#addendum-installier-mal-alles",
    "title": "\n7¬† Packages\n",
    "section": "\n7.4 Addendum: ‚ÄúInstallier mal alles‚Äù",
    "text": "7.4 Addendum: ‚ÄúInstallier mal alles‚Äù\nHier ein St√ºck Code, das ihr im Zweifelsfall einfach copypasten k√∂nnt.\nEs sollte euch so ziemlich alles oder zumindest das meiste an (vorerst) relevanten packages installieren, und dient mehr so der Vollst√§ndigkeit.\ninstall.packages(\"magrittr\")\ninstall.packages(\"ggplot2\")\ninstall.packages(\"dplyr\")\ninstall.packages(\"tidyr\")\ninstall.packages(\"stringr\")\ninstall.packages(\"devtools\")\ninstall.packages(\"forcats\")\ninstall.packages(\"readr\")\ninstall.packages(\"lubridate\")\ninstall.packages(\"purrr\")\ninstall.packages(\"readxl\")\ninstall.packages(\"haven\")\ninstall.packages(\"rvest\")\ninstall.packages(\"scales\")\n\ninstall.packages(\"cowplot\")\ninstall.packages(\"ggrepel\")\ninstall.packages(\"psych\")\ninstall.packages(\"DescTools\")\ninstall.packages(\"ggthemes\")\ninstall.packages(\"hrbrthemes\")\ninstall.packages(\"rmarkdown\")\ninstall.packages(\"viridis\")\ninstall.packages(\"RColorBrewer\")\ninstall.packages(\"nortest\")\ninstall.packages(\"plotly\")\ninstall.packages(\"car\")\ninstall.packages(\"afex\")"
  },
  {
    "objectID": "chapters/07-die-hilfe.html",
    "href": "chapters/07-die-hilfe.html",
    "title": "\n8¬† Die Hilfe\n",
    "section": "",
    "text": "Wir haben bereits Seiten wie rdrr.io erw√§hnt, wo ihr euch Dokumentation anschauen k√∂nnt. Unter Dokumentation verbirgt sich √ºbrigens nichts weltbewegendes, in der Regel geht es nur darum wie einzelne Funktionen zu benutzen sind. Diese Seiten sind im Wesentlichen aufgebohrte Versionen der Hilfe, die R von Haus aus mitbringt ‚Äî allerdings mit bells & whistles in Form von sch√∂nerer Optik, erweiterter Suchfunktion, Verlinkungen etc.\nDiie Hilfe findet ihr auf der rechten Seite in RStudio, unter dem \"Help\"-Tab:\nIn die Suchleiste oben rechts k√∂nnt ihr Suchbegriffe eingeben. Denkt daran, dass die Hilfe in erster Linie auf englisch verf√ºgbar ist."
  },
  {
    "objectID": "chapters/07-die-hilfe.html#format",
    "href": "chapters/07-die-hilfe.html#format",
    "title": "\n8¬† Die Hilfe\n",
    "section": "\n8.1 Format",
    "text": "8.1 Format\nDie Dokumentation von Funktionen hat immer das gleiche Format mit bestimmtem Pflichtbereichen und mehreren optionalen Abschnitten.\n\n\nDescription: Was macht die Funktion?\n\nUsage: Wie benutzt man die Funktion?\n\nValue: Was kommt dabei raus?\n\nSee Also: Welche anderen Funktionen sind verwandt?\n\nExamples: Anwendungsbeispiele"
  },
  {
    "objectID": "chapters/07-die-hilfe.html#sprache",
    "href": "chapters/07-die-hilfe.html#sprache",
    "title": "\n8¬† Die Hilfe\n",
    "section": "\n8.2 Sprache",
    "text": "8.2 Sprache\nDie R-Hilfe ist prim√§r auf englisch verf√ºgbar.\nWenn euch das √ºberrascht, dann geht mal vor die T√ºr.\nZus√§tzlich ist die Hilfe meistens von den AutorInnen der jeweiligen Packages/Funktionen geschrieben, was zwar den Vorteil hat, dass sie in der Regel zumindest inhaltlich korrekt ist, aber f√ºr Laien manchmal nur so m√§√üig verst√§ndlich ist, was da jetzt eigentlich genau gesagt wird.\nH√§ufig werden Begriffe verwendet, die f√ºr euch wom√∂glich eher fremd erscheinen, weil ihr vermutlich keinen Hintergrund in der Programmierung / Numerik / whatever habt, aber keine Angst. Fr√ºher oder sp√§ter lernt ihr die Begriffe, die relevant sind, und wenn ihr mal was so gar nicht versteht, dann fragt ihr eben einfach bei TutorInnen nach, googlet den Quatsch, oder ignoriert es einfach und versucht halt so weiter zu kommen."
  },
  {
    "objectID": "chapters/08-datenimport.html",
    "href": "chapters/08-datenimport.html",
    "title": "\n9¬† Datenimport\n",
    "section": "",
    "text": "Im Laufe eures Studiums (und vermutlich dar√ºberhinaus) werdet ihr sehr viel Zeit damit verbringen Daten aus verschiedenen Quellen in die Statistiksoftware eurer Wahl (oder auch nicht eurer Wahl, aber der eurer Arbeitstselle) zu quetschen.\nDas funktioniert mal mehr und mal weniger einfach, denn je nachdem wie die Originaldaten aussehen, kann das mitunter anstrengend bis deprimierend werden.\nSaubere (tidy) Daten sehen immer gleich aus, aber unsaubere Daten sind alle auf ihre eigene Art unsauber. Mal fehlen Variablenbeschriftungen, mal sind da Umlaute durch Encoding kaputtgegangen, manchmal werden numerische Werte als character interpretiert und manchmal sind fehlende Werte mit irgendwelchen willk√ºrlichen Werten kodiert (z.B. -99 anstatt NA).\nVielleicht wundert ihr euch auch, wieso dieses Kapitel erst so sp√§t in dieser Einf√ºhrung auftaucht. Das liegt prim√§r daran, dass ihr unter Umst√§nden ein ausreichend gro√ües Repertoire an Grundlagen braucht, um Daten auf alle F√§lle sauber eingelesen zu bekommen.\nIn vielen F√§llen, und besonders in QM, ist das Ganze noch relativ √ºberschaubar und eure TutorInnen k√∂nnen entsprechende Hilfestellung bieten, aber irgendwann seid ihr auf euch allein gestellt, und dann macht ein bisschen Bonus-Wissen hier und da den Unterschied zwischen einem anstrengenden Nachmittag voller Leid und Schmerz oder 10 Minuten Probiererei und schnellem Erfolg.\nWenn ihr Daten von eurer Festplatte einlesen wollt, und ihr keine Ahnung habt wie Dateipfade funktionieren, was euer Home Ordner ist, was beispielsweise ~/Documents sein soll oder wie ihr rausfindet, wo ihr gerade auf euren Computern seid, dann lest euch das bitte selber an.\nAuch hier liefert RStudio jedenfalls im ‚ÄúFiles‚Äù-Tab entsprechende Orientierungshilfe:\nDas rot umrandete ist der Pfad zum Projektordner, in R w√ºrde ich den also so eingeben m√ºssen:\nWobei die Tilde ~ eine Abk√ºrzung f√ºr das Home-Verzeichnis ist."
  },
  {
    "objectID": "chapters/08-datenimport.html#quellen",
    "href": "chapters/08-datenimport.html#quellen",
    "title": "\n9¬† Datenimport\n",
    "section": "\n9.1 Quellen",
    "text": "9.1 Quellen\nDa in QM nur SPSS und R benutzt werden, werdet ihr vermutlich meistens auf Datens√§tze aus SPSS (.sav) sto√üen. R kann zwar SPSS-Daten einlesen, aber SPSS kann mit R-Daten nichts anfangen. Au√üerdem beinhalten SPSS-Datens√§tze auch ein bisschen Metadaten, wie zum Beispiel Labels f√ºr eure Variablen oder nominalskalierte Variablen, die wir in R dann f√ºr bessere Optik benutzen k√∂nnen ‚Äî andere Formate wie Textdateien (.csv, .txt, plain text) sind spartanischer und haben sowas nicht.\nDie einfachste Option ist meistens die RStudio-Funktio zum Datenimport, aber auch hier solltet ihr erstmal wissen, wo eure Daten herkommen und ggf. √ºber die ein oder andere Eigenart bescheid wissen.\n\n\n\n\nRStudio Import-Tool\n\n\n\n\nBei den Textdateien sind mit base und readr die beiden unterschiedlichen M√∂glichkeiten gemeint, mit denen wir Daten einlesen k√∂nnen, aber mehr dazu im entsprechenden Abschnitt.\nEine Sache noch zum Encoding: Um kaputte Umlaute und andere Kr√§mpfe zu vermeiden bietet es sich an, √ºberall alles immer auf Unicode bzw. UTF-8 zu stellen wenn ihr irgendwo nach Encoding gefragt werdet.\n\n9.1.1 Roher Text (.csv, .txt)\n\nBen√∂tigte packages: readr\n\nAnstrengend? Entweder alles super oder Riesenkrampf\n\nEinfacher Text (plain text) ist die einfachste M√∂glichkeit Datens√§tze zu speichern bzw. zu √ºbertragen, da Text so ziemlich der kleinste gemeinsame Nenner jeder g√§ngigen Software ist. CSV hei√üt auch nur ‚Äúcomma separated values‚Äù, und wird euch vermutlich noch h√§ufiger begegnen. Eine CSV-Datei k√∂nnt ihr mit jedem beliebigen Texteditor √∂ffnen (ihr m√ºsst daf√ºr kein Office rauskramen, auf Windows tut es auch das Notepad), und ihr seht dann vermutlich sowas in der Art:\n\"extra\",\"group\",\"ID\"\n0.7,\"1\",\"1\"\n-1.6,\"1\",\"2\"\n-0.2,\"1\",\"3\"\n-1.2,\"1\",\"4\"\n-0.1,\"1\",\"5\"\n3.4,\"1\",\"6\"\nDas Prinzip ist ziemlich einfach: In der ersten Zeile stehen die Variablennamen, und in jeder folgenden Zeile steht jeweils der Wert der zugeh√∂rigen Variable, getrennt durch ein Komma.\nDie Schwierigkeit kommt dann, wenn die Werte zum Beispiel Text enthalten, der wiederum ein Komma enthalten kann, und der Wert nicht richtig in Anf√ºhrsungszeichen gesetzt ist. Es gibt auch noch Varianten mit Tabs statt Kommata als Trennzeichen, das w√§re dann strenggenommen TSV (ihr d√ºrft raten wof√ºr das T steht).\nTextformate sind also ziemlich einfach um eure Daten zu speichern oder zu verschicken, aber es ist auch sehr fragil, sobald mal irgendwo ein \" fehlt oder zu viel ist, wird‚Äôs kompliziert.\nZum lesen und schreiben empfehle ich herzlichst das readr-package mit den Funktionen read_csv, write_csv etc. zu benutzen, die sind weniger anf√§llig f√ºr Murks als die base-Standardfunktionen mit gleichem Namen aber . statt _ (read.csv, write.csv).\nAls Beispiel laden wir mal diesen sch√∂nen Game of Thrones-Datensatz:\n\nCodelibrary(readr)\ngotdeaths <- read_csv(\"data/got_deaths.csv\")\n\nhead(gotdeaths)\n\n\nHier habe ich col_types = cols() nur benutzt, um das Output zu unterdr√ºcken. Ihr k√∂nnt √ºber dieses Argument aber auch manuell spezifizieren, welchen Typ jede Spalte haben soll, damit eure Daten explizit so eingelesen werden, wie ihr sie erwartet.\nDie schmutzigen Details gibt‚Äôs nat√ºrlich in der Hilfe: ?read_csv und online.\n\n9.1.2 SPSS (.sav)\n\nBen√∂tigte packages: haven.\nAnstrengend? Manchmal.\n\nlibrary(haven)\n\nngo <- read_spss(\"data/NGO.SAV\")\nDie Funktionen read_sav und read_spss sind identisch.\n\n9.1.3 R (.rds, .rda & .RData)\n\nBen√∂tigte packages: Keins (Base R reicht, optional readr als Alternative)\nAnstrengend? Nope, alles tutti.\n\nDer wohl einfachste und dankbarste Anwendungsfall: Von R zu R.\nHier habt ihr zwei M√∂glichkeiten: .rds und .rda (auch .RData): Generell scheint .rds die pr√§ferierte Option zu sein.\n\n9.1.3.1 .rds\n\nDaten einlesen ist simpel:\n\nCodeqmsurvey <- readRDS(\"data/qm_survey_ss2017.rds\")\n\ntibble::as_tibble(qmsurvey)\n\n\nWir benutzen hier das tibble package nur, damit der Datensatz kompakter angezeigt wird. Das ist f√ºr euch keine Notwendigkeit, aber ich empfehle es in der Regel gerne, weil euch so nicht die Konsole vollgeklatscht wird, wenn ihr euch euren Datensatz mal schnell anschauen wollt.\nDaten speichern auch:\nsaveRDS(datensatz, \"pfad/zur/datei.rds\")\nHier zum Beispiel der Datensatz zur Tutoriumsteilnahme, den ihr von https://public.tadaa-data.de/data/participation.rds runterladen k√∂nnt:\nparticipation <- readRDS(\"~/Downloads/participation.rds\")\nAlternativ k√∂nnt ihr das readr-package benutzen. Die Funktion daraus sieht fast gleich aus, und macht auch exakt das gleiche wie readRDS. Der einzige Grund f√ºr read_rds ist die Konsistenz der Funktionsnamen.\nlibrary(readr)\n\nparticipation <- read_rds(\"~/Downloads/participation.rds\")\n\n9.1.3.2 .rda, .RData\n\nNein, ihr benutzt nicht save und load f√ºr einzelne Datens√§tze.\nBei .rda bzw. .RData-Dateien ist zu beachten, dass diese den Namen des Objekts gleich mitspeichern, das hei√üt ihr m√ºsst den eingelesenen Datensatz keinen Namen geben ‚Äî der kommt schon mit der Datei.\nTheoretisch kann so eine Datei auch mehrere Variablen enthalten, und wenn ihr zum Beispiel RStudio schlie√üt und wieder √∂ffnet, dann werden in der Zwischenzeit auch eure Variablen der aktuellen Session in Form einer .RData-Datei im Projektordner abgelegt und beim n√§chsten Start wieder eingelesen.\nload(\"pfad/zur/datei.rda\")\n\n# Oder‚Ä¶\nload(\"pfad/zur/datei.RData\")\nSpeichern:\nsave(datensatz, file = \"pfad/zur/Datei.rda\")\n\n9.1.4 Excel (.xlsx)\n\nBen√∂tigte packages: readxl\n\nAnstrengend? Manchmal. Aber wenn, dann richtig.\n\nWenn ihr ein sauberes (i.e.¬†ohne Schnickschnak) Spreadsheet habt in dem auch wirklich nur eure Werte drinstehen, dann ist das Ganze recht simpel und ihr seid mit readxl auch gut bedient.\nWenn ihr einen dreckigen Haufen dampfender Menschenverachtung vor euch habt, dann‚Ä¶ viel Spa√ü.\nEs gibt da das ein oder andere Projekt f√ºr die komplexeren F√§lle, aber wenn ihr die M√∂glichkeit habt, macht es euch so einfach (und rechteckig) wie m√∂glich.\n\n9.1.5 Google Sheets\n\nBen√∂tigte packages: googlesheets\n\nAnstrengend? Meistens geht‚Äôs ganz gut.\n\nWenn euch Excel zu unpraktisch ist, dann bietet sich Google Sheets an. Es ist kostenlos, einfach und ausreichend m√§chtig f√ºr alles, was ihr so vorhaben k√∂nntet ‚Äî mitunter weil ihr f√ºr alle komplexeren Sachen sowieso R benutzen wollt. Sheets ist praktisch wie Excel, nur halt in der CloudTM und von Google, aber f√ºr √ºberschaubare Datensammlungen reicht‚Äôs auf alle F√§lle. Die Tutoriumsteilnahmedaten haben wir da auch gesammelt, und da das Sheet immer an der selben Stelle ist muss man einfach nur den Code zum einlesen und auswerten erneut ausf√ºhren und schon hat man eine mehr oder weniger selbstupdatende Analyse. Nett.\nIn besagtem Projekt sieht das zum Beispiel so aus:\nparticipation_1 <- gs_title(\"Tutoriumsteilnehmer\") %>%\n  gs_read(ws = \"WS1516\", range = cellranger::cell_cols(1:7))\nZuerst m√ºsst ihr aber die Authentifizierung mit eurem Google-Account abhandeln:\nlibrary(googlesheets)\n\ngs_ls()\nMit diesem Befehl zeigt euch das package all eure Google Sheets an nachdem es euch nach einem Login gefragt hat, von da aus k√∂nnt ihr dann weiterarbeiten. Mehr Informationen und Beispiele gibt‚Äôs in der Vignette."
  },
  {
    "objectID": "chapters/08-datenimport.html#daten-angucken-sauber-machen",
    "href": "chapters/08-datenimport.html#daten-angucken-sauber-machen",
    "title": "\n9¬† Datenimport\n",
    "section": "\n9.2 Daten angucken & sauber machen",
    "text": "9.2 Daten angucken & sauber machen\n\nHappy families are all alike; every unhappy family is unhappy in its own way.\n‚Äî Leo Tolstoy\n\n\nand every messy data is messy in its own way - it‚Äôs easy to define the characteristics of a clean dataset (rows are observations, columns are variables, columns contain values of consistent types). If you start to look at real life data you‚Äôll see every way you can imagine data being messy (and many that you can‚Äôt)!\n‚Äî Hadley Wickham (answering ‚Äòin what way messy data sets are messy‚Äô) R-help (January 2008)\n\nUm festzustellen, ob eure frisch eingelesenen Daten auch brauchbar sind, empfiehlt sich ein Blick in die Daten via View(daten) bzw. √úber einen Klick auf den Datensatz im Environment-Tab von RStudio (das da oben rechts).\nZus√§tzlich ist auch hier nat√ºrlich str() praktisch, um zum Beispiel schnell zu √ºberpr√ºfen, ob eure Variablen auch alle die Klasse haben, die ihr erwartet (alle Zahlen sind numeric und Nominaldaten sind factor oder wenigstens character).\nEs gibt da kein one-size-fits-all Rezept zur Datenbereinigung, denn jeder Datensatz ist auf seine eigene Art dreckig. Ihr k√∂nnt nur darauf hoffen, dass euer konkreter Anwendungsfall gut googlebar ist, oder ihr sowas √§hnliches schonmal gemacht habt.\nDie g√§ngigsten Probleme sind recoding, umbenennen oder zusammenfassen, und das meiste l√§sst sich entweder mit dplyr, sjmisc oder ggf. tidyr erledigen. Versucht es erstmal innerhalb des tidyverse, das ist vermutlich angenehmer als zusammengehackte Google-L√∂sungen. Aber auch hier, wie gesagt: Je nachdem was ihr vorhabt. Mehr dazu findet sich in [Data Munging].\nDatenbereinigung ist entweder sehr einfach oder sehr komplex, oder irgendwo dazwischen. In diesem Sinne: Learning by example und so."
  },
  {
    "objectID": "chapters/10-berichte.html",
    "href": "chapters/10-berichte.html",
    "title": "\n10¬† Berichte\n",
    "section": "",
    "text": "Scripte schreiben ist sch√∂n und gut, aber das was dabei rauskommt ist in erster Linie ein Haufen Konsolen-Output, gespickt mit Plots, die ihr ggf. manuell speichern m√ºsst, und dann wollt ihr das in eure krummen Word-Dokumente stecken und das will doch niemand. In SPSS ist das einfach. Ihr dr√ºckt den gro√üen bunten Knopf wo ‚ÄúMach mal Statistik‚Äù draufsteht und dann fallen da PDFs raus. In R ist das anders. Habt ihr vermutlich gemerkt. Das erste Output, das ihr mit R erzeugt wird wahrscheinlich nicht besonders h√ºbsch aussehen ‚Äî das ist schade, aber es ist nunmal auch die einfachste Art. Was in der Konsole passiert, kann auch problemlos auf gro√üen Servern in der CloudTM passieren und ferngesteuert werden ‚Äî bei SPSS bleibt euch nur Remotedesktop-Kram. Aber ich schweife ab. Das sch√∂ne an R ist jedenfalls die Flexibilit√§t, die wir beim Output haben. Vielleicht habt ihr den Abschnitt zu sjPlot im Kapitel zu [Packages] schon gelesen, und wie die sjt.*-Funktionen h√ºbsche Tabellen produzieren. Diese Tabellen sind HTML ‚Äî dasselbe Zeug, aus dem Webseiten zusammengesteckt werden, und auch dasselbe Zeug, das so grob auch in Word-Dokumenten steckt. Wir k√∂nnen auch gleich eine ganze Analyse in HTML produzieren, mit Plots an den richtigen stellen und Tabellen in sch√∂n!\nWie das funktioniert soll in diesem Kapitel erkl√§rt werden. Als Vorraussetzung bzw. further reading k√∂nnt ihr euch bei diesen RStudio-Ressourcen umschauen:"
  },
  {
    "objectID": "chapters/10-berichte.html#markdown",
    "href": "chapters/10-berichte.html#markdown",
    "title": "\n10¬† Berichte\n",
    "section": "\n10.1 Markdown",
    "text": "10.1 Markdown\nHabt ihr schonmal HTML gesehen? So mit <html><body><p>Hallo Welt</p></body></html>?\nDen Schei√ü will kein Mensch per Hand schreiben, wenn‚Äôs nur um Text und vielleicht mal Bilder geht.\nDaf√ºr gibt es Markdown.\nMarkdown zu lernen wird euch ungef√§hr 5 Minuten kosten, wenn ihr euch Zeit lasst und zwischendurch nochmal auf Klo geht.\nDer obige Paragraph sieht im Markdown-Rohtext √ºbrigens so aus:\nHabt ihr schonmal HTML gesehen? So mit `<html><body><p>Hallo Welt</p></body></html>`?  \nDen Schei√ü will *kein Mensch* per Hand schreiben, wenn's nur um Text und vielleicht mal Bilder geht.  \nDaf√ºr gibt es [Markdown](https://rmarkdown.rstudio.com/authoring_basics.html).  \nMarkdown zu lernen wird euch **ungef√§hr 5 Minuten** kosten, _wenn_ ihr euch Zeit lasst und zwischendurch nochmal auf Klo geht.\nNicht so schwer, oder?\nDas wird √ºbersetzt in folgendes HTML:\n<p>Habt ihr schonmal HTML gesehen? So mit <code>&lt;html&gt;&lt;body&gt;&lt;p&gt;Hallo Welt&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code>?<br />\nDen Schei√ü will <em>kein Mensch</em> per Hand schreiben, wenn‚Äôs nur um Text und vielleicht mal Bilder geht.<br />\nDaf√ºr gibt es <a href=\"https://rmarkdown.rstudio.com/authoring_basics.html\">Markdown</a>.<br />\nMarkdown zu lernen wird euch <strong>ungef√§hr 5 Minuten</strong> kosten, <em>wenn</em> ihr euch Zeit lasst und zwischendurch nochmal auf Klo geht.</p>\nAnstrengend.\nWas RStudio euch mittels RMarkdown erlaubt ist ein Bericht in Markdown geschrieben, zwischendurch mit R Code Chunks, die von R einfach ausgef√ºhrt werden, und am Ende f√§llt eine HTML-Datei raus, die ihr einfach im Browser √∂ffnen k√∂nnt.\nOptional k√∂nnt ihr da auch ein PDF rausfallen lassen, aber das erfordert m√∂glicherweise rudiment√§re LaTeX-Kenntnisse, und das will ja niemand."
  },
  {
    "objectID": "chapters/10-berichte.html#rmarkdown",
    "href": "chapters/10-berichte.html#rmarkdown",
    "title": "\n10¬† Berichte\n",
    "section": "\n10.2 RMarkdown",
    "text": "10.2 RMarkdown\nRMarkdown ist R + Markdown. Jip.\nIhr schreibt ganz normales Markdown, und wenn ihr R Code einf√ºgen wollt, setzt ihr da so einen Block rein:\n```{r}\nnrow(sleep)\n```\nUnd in eurem fertigen Dokument landet dann euer Text und der R Code und das Output des R-Codes.\nDiese ganze Einf√ºhrung ist in RMarkdown geschrieben, inklusive allen Code-Beispiele, Bildern und sowieso, und wenn ihr euch erstmal ein bisschen durch die oben verlinkte Einf√ºhrung geklickt habt und gesehen habt, dass das gar nicht so schwer ist, werdet auch ihr irgendwann vermutlich lieber RMarkdown benutzen als Word.\nIhr k√∂nnt damit loslegen, sobald ihr RMarkdown installiert habt:\n# F√ºr die Grundfunktion\ninstall.packages(\"rmarkdown\")\n\n# Sch√∂ne HTML Output-Formate (optional)\ninstall.packages(\"rmdformats\")\n\n# Sch√∂ne Pr√§sentationen (Optional)\ninstall.packages(\"revealjs\")\nAlso los, macht mal ein neues RMarkdown-Dokument auf:\n\n\n\n\nNeues Dokument f√ºr RMarkdown\n\n\n\n\nSoweit alle mitgekommen? Gut.\nAls n√§chstes d√ºrft ihr euch was w√ºnschen: Einen Dateinamen und einen AutorInnennamen.\n\n\n\n\nBeliebig ausf√ºllen und ‚ÄúHTML‚Äù ausgew√§hlt lassen\n\n\n\n\nUnd sieheda, ein RMarkdown default document:\n---\ntitle: \"Untitled\"\nauthor: \"Lukas\"\ndate: \"8/15/2017\"\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n## R Markdown\n\nThis is an R Markdown document. Markdown is a simple formatting  \nsyntax for authoring HTML, PDF, and MS Word documents. For more  \ndetails on using R Markdown see <https://rmarkdown.rstudio.com>.\n\nWhen you click the **Knit** button a document will be generated \n that includes both content as well as the output of any embedded  \n R code chunks within the document. You can embed an R code chunk like this:\n\n```{r cars}\nsummary(cars)\n```\n\n## Including Plots\n\nYou can also embed plots, for example:\n\n```{r pressure, echo=FALSE}\nplot(pressure)\n```\n\nNote that the `echo = FALSE` parameter was added to the code  \nchunk to prevent printing of the R code that generated the plot.\nDas k√∂nnt ihr jetzt erstmal speichern, vielleicht testhalber etwas reinschreiben und sobald ihr den ‚ÄúKnit‚Äù-Button dr√ºckt, r√∂delt RMarkdown im Hintergrund los und spuckt euch ein HTML aus.\nSo einfach.\nJetzt k√∂nnt ihr damit beliebig experimentieren, den Text anpassen, eigenen Code reinschreiben und wenn ihr Fragen habt, googlet ihr die einfach solange, bis ihr jemanden findet, der/die die gleiche Frage auch schon hatte und rausgefunden hat wie‚Äôs geht.\nOder es steht in der oben verlinkten Dokumentation von RStudio.\nVermutlich letzteres.\n\n10.2.1 Der YAML-Header\nAls n√§chstes k√∂nnt ihr ein bisschen an den Optionen rumspielen:\n\n\n\n\nOutput Optionen f√ºr diversen Kram\n\n\n\n\nSo Dinge wie die Dimensionen der ausgegebenen Plots (‚Äúfigure height/width‚Äù), Inhaltsverzeichnis (‚ÄúTable of Contents‚Äù) etc. sind einfach √ºber dieses Men√º machbar, alles was irgendwie dar√ºberhinausgeht muss √ºber die Optionen am Anfang des Dokuments gesetzt werden.\nDas oben ist der YAML header. YAML ist auch eine Markup-Sprache wie HTML, und weil es so viele dieser Markup-Sprachen gibt, hei√üt YAML lang ‚ÄúYet Another Markup Language‚Äù1. Es gibt auch noch HAML und TOML\nIhr erkennt das Muster.\nDer Standard-Header definiert nur die wichtigstens Elemente, aber wir k√∂nnen den unter Anderem durch die Optionen im Men√º erweitern. Ein umfangreicheres Beispiel aus einem alten QM-Aufgabenzettel sieht zum Beispiel so aus:\n---\ntitle: \"Aufgabenblatt 5\"\nauthor: \"Lukas\"\ndate: \"Rendered `r format(Sys.time(), '%F %H:%M')`\"\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n    toc_depth: 4\n    highlight: tango\n    fig_width: 9\n    fig_retina: 2\n    theme: yeti\n    code_folding: show\n    df_print: paged\n---\nWas euch da komisch vorkommen k√∂nnte ist der Teil mit dem date:. Das rechts daneben ist ein String mit einem inline code chunk, und alles was in RMarkdown zwischen `r und ` steht wird wie R-Code behandelt und ausgef√ºhrt, das hei√üt das Datum des Dokuments wird in diesem Fall automatisch auf format(Sys.time(), '%F %H:%M') gesetzt, was folgendes ergibt:\n\nCodeformat(Sys.time(), \"%F %H:%M\")\n#> [1] \"2022-05-08 17:48\"\n\n\nBoom, Dokument zeigt immer automatisch an, wann es zuletzt generiert (rendered, bzw. knitted) wurde.\nSpitzfindigen Lesenden wird etwas aufgefallen sein: ‚ÄúAber seltsamer Nerd Mensch‚Äù, werden sie sagen, ‚Äúwenn dieses Dokument hier in RMarkdon geschrieben wurde, und diese inline Code chunks automatisch ausgef√ºhrt werden‚Äù werden sie feststellen, woraufhin sie sich fragen werden: ‚Äúwie ist es dann m√∂glich den rohen Code daf√ºr hier reinzuschreiben ohne, dass er ausgef√ºhrt wird?‚Äù ‚Äî und dazu, liebe hypothetische Lesende, habe ich eine Antwort: Zero-width non-joiners everywhere, vielleicht ASCII escape characters, und extra `. Ihr werdet dieses Wissen vermutlich nie brauchen, aber ich habe ~30 Minuten damit verbracht herauszufinden wie ich das anstelle, also will ich daf√ºr auch mindestens ein bisschen street cred."
  },
  {
    "objectID": "chapters/a01-ressourcen.html",
    "href": "chapters/a01-ressourcen.html",
    "title": "Appendix A ‚Äî Ressourcen",
    "section": "",
    "text": "Es gibt viele freie Quellen f√ºr sch√∂ne Datens√§tze zum √úben oder rumspielen, und einige packages bringen auch entsprechende Datens√§tze mit, die geeignet sind um bestimmte Funktionen auszuprobieren.\n\n\n\nG√§ngige Standarddatens√§tze:\n\nmtcars\nsleep\nattitude\n\npalmerpenguins::penguins: Pinguine!\ndplyr::starwars: Star Wars-stuff mit list-columns\nbabynames::babynames: Naja, baby names.\ntadaatoolbox::ngo: NGO-Datensatz aus QM (bzw. aus dem K√§hler)\n\n\n\n\n\ndata.world: Hier kommt z.B. der Game of Thrones deaths-Datensatz her\n\n\n\n\nHier liegen diverse Datens√§tze aus unseren Projekten, wie z.B. die QM-Surveys und die Tutorienteilnahme.\n\ndata.tadaa-data.de"
  },
  {
    "objectID": "chapters/a01-ressourcen.html#b√ºcher",
    "href": "chapters/a01-ressourcen.html#b√ºcher",
    "title": "Appendix A ‚Äî Ressourcen",
    "section": "A.2 B√ºcher",
    "text": "A.2 B√ºcher\n\n‚ÄúR for Data Science‚Äù ‚Äì Hadley Wickham\n‚ÄúAdvanced R‚Äù ‚Äì Hadley Wickham\nggplot2 ‚Äì Hadley Wickham\n‚ÄúTidyverse Cookbook‚Äù\n‚ÄúR Programming for Data Science‚Äù ‚Äì Roger Peng\n‚ÄúExploratory Data Analysis with R‚Äù ‚Äì Roger Peng\n‚ÄúTop 50 ggplot2 Visualizations‚Äù\n‚ÄúR Cookbook‚Äù\nMehr B√ºcher\n\n\nA.2.1 Kollaboration und Organisation\n\nA.2.1.1 Git & GitHub\n\nhappygitwithr.com ‚Äì Jenny Bryan\nohshitgit"
  },
  {
    "objectID": "chapters/a01-ressourcen.html#kurse-workshops",
    "href": "chapters/a01-ressourcen.html#kurse-workshops",
    "title": "Appendix A ‚Äî Ressourcen",
    "section": "A.3 Kurse & Workshops",
    "text": "A.3 Kurse & Workshops\n\nA.3.1 Kostenlose Tutorials/Videos\n\nRStudio Webinars\nStat545\nLOTR Data"
  },
  {
    "objectID": "chapters/a01-ressourcen.html#blogs",
    "href": "chapters/a01-ressourcen.html#blogs",
    "title": "Appendix A ‚Äî Ressourcen",
    "section": "A.4 Blogs",
    "text": "A.4 Blogs\n\nAggregator: R-Bloggers\n\nSiehe auch: Blogs in blogdown"
  },
  {
    "objectID": "chapters/a01-ressourcen.html#community",
    "href": "chapters/a01-ressourcen.html#community",
    "title": "Appendix A ‚Äî Ressourcen",
    "section": "A.5 Community",
    "text": "A.5 Community\n\nStackoverflow\nTwitter: #rstats"
  },
  {
    "objectID": "chapters/a01-ressourcen.html#dokumentation",
    "href": "chapters/a01-ressourcen.html#dokumentation",
    "title": "Appendix A ‚Äî Ressourcen",
    "section": "A.6 Dokumentation",
    "text": "A.6 Dokumentation\n\nR help (inoffizielle bookdown-Version)\nrdrr.io\nPackage-specific\n\ntidyverse.org"
  }
]