{
  "hash": "947397736a0d665f6edfaf1d9583af8f",
  "result": {
    "markdown": "# Erste Schritte\n\nIm letzten Abschnitt habt ihr R als glorifizierten Taschenrechner gesehen.  \nAls nächstes schauen wir uns an, was wir sonst so damit anstellen können.\n\nZuerst ein bisschen Terminologie:\n\n> “To understand computations in R, two slogans are helpful:\n>\n> - Everything that exists is an object.\n> - Everything that happens is a function call.\"  \n> \n> -- John Chambers\n\nOder in der Sprach-Analogie: Alles was in R existiert (Variablen, Tabellen, etc.) ist ein *Nomen* (Objekt) und alles, was etwas tut, ist ein *Verb* (Funktion).\n\n## Grundfunktionen\n\nDie einfachsten Funktionen haben wir in Form der Rechenzeichen `+ - / *` schon kennengelernt, aber es gibt natürlich noch mehr.  \nEine Funktion in R hat sieht immer ungefähr so aus: `sqrt(8)`. Der Name der Funktion, hier `sqrt`, (**immer** ohne Leerzeichen) gefolgt von Klammern, in denen ein oder mehrere *Argumente* stehen. Ein Argument ist das, womit die Funktion arbeiten soll. Eine gängige Veranschaulichung für Funktionen sind **Verben** einer Sprache, denn sie *tun* etwas.  \n\nEine der wichtigsten Grundfunktionen ist `c()`, für *combine*. Mit `c` verbindet ihr mehrere Zahlen zu einem **Vektor** (ja, wie in der linearen Algebra. Mathe und so. Wisstschon.). Wenn ihr mehrere Zahlen zu einem Vektor kombiniert habt, könnt ihr damit so spaßige Dinge machen wie Mittelwerte ausrechen, sie aufsummieren oder zwei Vektoren gleicher Länge addieren.  \nProbiert mal ein paar Beispiele aus:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-1_d3c72c4fc71f9ecb0c57836e60a18116'}\n\n```{.r .cell-code}\n# Ein paar Zahlen\nc(1, 1, 2, 3, 5, 8, 13, 21)\n#> [1]  1  1  2  3  5  8 13 21\n\n# Was ist der Mittelwert der Zahlen?\nmean(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 6.75\n\n# Und die Summe?\nsum(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 54\n\n# Und wenn wir quadrieren?\nc(1, 1, 2, 3, 5, 8, 13, 21)^2\n#> [1]   1   1   4   9  25  64 169 441\n\n# Oder die Wurzel ziehen?\nsqrt(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 1.000000 1.000000 1.414214 1.732051 2.236068 2.828427 3.605551 4.582576\n```\n:::\n\n\nWas wir hier sehen ist der Unterschied zwischen Funktionen, die aus mehreren Zahlen eine machen (`mean`, `sum`), und Funktionen, die auf jeder Zahl einzeln operieren (`sqrt`, `^`).  \nWas wir außerdem sehen: Jedes mal die Liste von Zahlen `c(1, 1, 2, 3, 5, 8, 13, 21)` kopieren und in eine Funktion einsetzen ist ziemlich unpraktisch. Stellt euch vor, ihr habt eine Reihe von Testergebnissen von hunderten ProbandInnen und müsst da alles einzeln, also, nein, das wäre ja albern.  \nFür sowas gibt es dann Abstraktionen wie **Variablen** und **Datensätze**, die entweder eine Liste von Werten oder auch eine Liste einer Liste von Werten handlich machen — das sehen wir dann in den nächsten beiden Abschnitten. \n\nEine weitere praktische Funktion ist `length()`: Sie sagt uns, wie *lang* das Argument ist.  \nWenn wir uns also angucken, wie der Mittelwert funktioniert…\n\n\n$$\\bar{x} = \\frac{1}{n} \\sum^n_{i=1} x_i$$\n\n\n…und wir das übersetzen in *\"Die Summe aller Werte geteilt durch die Anzahl der Werte\"*, dann können wir statt `mean` also auch folgendes schreiben:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-2_078ac0f4ddbf699aae5e954b73856b1f'}\n\n```{.r .cell-code}\n# in lang\nsum(c(1, 1, 2, 3, 5, 8, 13, 21))/length(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 6.75\n\n# in kurz\nmean(c(1, 1, 2, 3, 5, 8, 13, 21))\n#> [1] 6.75\n```\n:::\n\n\nIhr seht vielleicht so langsam, wieso wir das mit den Klammern und den Leerzeichen für die Lesbarkeit erwähnt haben.  \nAber gut, so langsam wird's unübersichtlich, es wird Zeit ein paar Variablen anzulegen.\n\n### Funktionsbeispiele\n\nWenn ihr R lernt, werdet ihr erfahrungsgemäß die meiste Zeit damit verbringen herauszufinden wie bestimmte Funktionen funktionieren und welche Funktion für euer Vorhaben die richtige ist.  \n\nFunktionen sind zwar vom Schema immer gleich — ihr steckt irgendwelche Argumente rein, und es kommt irgendein Ergebnis raus — aber wie die Argumente aussehen unterscheidet sich von Funktion zu Funktion.  \n`sd()` zum Beispiel hat zwei Argumente:  \n\n  - `x`: Ein Vektor aus Zahlen, aus denen die Standardabweichung berechnet werden soll\n  - `na.rm`: Für `NA remove`, entweder `TRUE` oder `FALSE`. Wenn `x` fehlende Werte (`NA`) enthält, dann werden diese automatisch ignoriert, wenn `na.rm = TRUE`\n  \n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-3_3dd052cddfa0e8357b8d91270cce448d'}\n\n```{.r .cell-code}\nzahlen <- c(3, 6, 8, 3, 1, 2, 5, 6, 4, 3, NA, 4, 5, 7, NA, 1, 4)\n\n# Ergibt NA :(\nsd(zahlen)\n#> [1] NA\n\n# Ergibt ein Ergebnis :)\nsd(zahlen, na.rm = TRUE)\n#> [1] 2.065591\n```\n:::\n\n\nDer *default* für `na.rm` ist bei den meisten Funktionen (z.B auch `mean`) `FALSE`, das heißt fehlende Werte werden nicht automatisch ignoriert. Wenn euer *input* aber `NA` enthält, dann lässt sich daraus nicht sauber ein Mittelwert oder eine Standardabweichung berechnen, weil wir nichts über `NA` wissen (wir widmen uns `NA` im Kapitel zu Datentypen).  \nNicht jede Funktion hat ein Argument namens `na.rm`, aber ihr werdet im Laufe der Zeit lernen, bei welchen Funktionen ihr darauf achten müsst, wie mit fehlenden Werten umgegangen wird.\n\nEinige andere Funktionen, die insbesondere zum Lernen und Ausprobieren praktisch sind, werden zur Erstellung von **Sequenzen** benutzt — also Reihen von Zahlen in einem bestimmten Muster:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-4_6fe80866393a68f941dd4a4be26157a5'}\n\n```{.r .cell-code}\n# Die Zahlen von 1 bis 100\n1:100\n#>   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n#>  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n#>  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n#>  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n#>  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n#>  [91]  91  92  93  94  95  96  97  98  99 100\n\n# 10 bis 15 in 0.5er-Schritten\nseq(10, 15, 0.5)\n#>  [1] 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0\n\n# Äquivalent, mit explizit benannten Argumenten:\nseq(from = 10, to = 15, by = 0.5)\n#>  [1] 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0\n\n# Von 5 bis -5 in ganzen Schritten\nseq(5, -5)\n#>  [1]  5  4  3  2  1  0 -1 -2 -3 -4 -5\n\n# Sequenz von 1 mit Länge 5, dasselbe wie 1:5\nseq_len(5)\n#> [1] 1 2 3 4 5\nseq_len(length.out = 5)\n#> [1] 1 2 3 4 5\n```\n:::\n\n\nDas `:` ist eine einfache Funktion und kann gelesen werden wie \"Von … bis … in ganzen Schritten\". Zusötzlich gibt es die Funktion `seq()`, die etwas flexibler ist. Außerdem gibt es diverse Funktionen für zufallsgenerierte Zahlen:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-5_55151093c607ac5a15fe3c63e4dcb5ed'}\n\n```{.r .cell-code}\n# Normalverteilte Zufallszahlen (10 Stück, Mittelwert 5, Standardabweichung 2) \nrnorm(n = 10, mean = 5, sd = 2)\n#>  [1] 4.728914 5.596968 9.348978 2.405188 4.323383 7.174800 9.236142 3.084294\n#>  [9] 7.044620 4.997392\n\n# Gleichverteilte Zufallszahlen (sprich \"r unif\", nicht \"run if\")\nrunif(n = 10)\n#>  [1] 0.006253856 0.206609888 0.123650394 0.829648214 0.447253925 0.719047463\n#>  [7] 0.730167684 0.497380002 0.734657794 0.675635529\n\n# Münzwurf (Binomialverteilte Ergebnisse), 10 Stück\nrbinom(n = 10, size = 1, prob = 0.5)\n#>  [1] 0 0 0 0 0 0 1 0 1 1\n\n# Würfel (W6) (10 Stück)\nsample(x = 1:6, size = 10, replace = TRUE)\n#>  [1] 3 5 1 6 2 4 6 2 5 5\n```\n:::\n\n\n\n## Variablen\n\nWenn Funktionen wie Verben sind, dann sind Variablen wie **Nomen**. Sie haben einen Namen, und mit ihnen kann man Dinge tun. Oder sogar Sachen machen.  \nVariablen werden durch eine *Zuweisung* (*Assignment*) erstellt, was in R traditionell via `<-` passiert.  \nIn den meisten anderen Programmiersprachen benutzt man dafür `=`, aber nun ja, R ist [historisch gewachsen](https://ironholds.org/projects/rbitrary/#why-do-we-use---for-assignment)^[Money quote: \"[…] the reason we use `<-` for assignment is it made sense in a programming language written before the incorporation of Apple Computers, because it made sense in a programming language written before the moon landings.\"], also nehmt für den Anfang einfach mal hin, dass das nunmal so ist.  \nWir speichern also mal ein paar Dinge:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-6_07948ae8fe35d25fac057111264733e6'}\n\n```{.r .cell-code}\n# Speichern in \"fib\"\nfib <- c(1, 1, 2, 3, 5, 8, 13, 21) \n\n# Ausgeben lassen\nfib\n#> [1]  1  1  2  3  5  8 13 21\n\n# Mittelwert…\nmean(fib)\n#> [1] 6.75\n\n# …funktioniert immer noch. Angenehm.\n# Und wenn wir…\nfib + fib\n#> [1]  2  2  4  6 10 16 26 42\n\n# Abgefahrener Kram.\n```\n:::\n\n\nHier haben wir die Zahlen `1, 1, 2, 3, 5, 8, 13, 21` in die Variable `fib` gespeichert, weil es die ersten paar [Fibonacci-Zahlen](https://de.wikipedia.org/wiki/Fibonacci-Folge) sind, und wir unsere Variablen immer so benennen sollten, dass wir später noch wissen wofür sie da sind. Viele Tutorials beginnen damit, Variablen wie `x`, `y` und `z` anzulegen, aber da blickt ja irgendwann kein Mensch mehr durch.  \nWenn ihr jetzt mit euren Zahlen arbeiten wollt, könnt ihr einfach in jeder Funktion `fib` statt der Liste mit `c(…)` einsetzen, und alles funktioniert wie vorher. Das liegt daran, dass R bei jedem Befehl erstmal nachschaut, ob ihr eine Variable benutzt (alles was Text ohne Anführungszeichen ist), und ob es die Variable findet. Wenn es die Variable gefunden hat, guckt es nach, was da drinsteht, in diesem Fall also `c(1, 1, 2, 3, 5, 8, 13, 21)`, dann benutzt R den Inhalt der Variablen.\n\nAn dieser Stelle bietet es sich an, einen neuen Typ einzuführen: Den String (oder auch `character`). Als String bezeichnet man im Kontext von, naja, Computerkram generell eigentlich, alles was als Text durchgeht. Sobald wir etwas nicht mehr nur durch Zahlen darstellen können, ist es ein String.  \nStrings stehen in R immer in Anführungszeichen, entweder in \\\"doppelten\\\" oder in \\'einfachen\\'.\n\nWichtig dabei ist, dass sich Anführungszeichen ähnlich verhalten wie Klammern. Wenn wir einen String mit <code>\"</code> beginnen, müssen wir ihn auch wieder mit <code>\"</code> schließen, ansonsten wartet R brav darauf, dass endlich das zweite <code>\"</code> kommt und verläuft sich.  \nEin Beispiel:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-7_51c6ee4c69efb45b205a1a4355a8b25e'}\n\n```{.r .cell-code}\n# Vollkommen okay\nnamen <- c(\"Tobi\", \"Lukas\", \"Nadja\", \"Christoph\")\n\n# Auch okay, aber inkonsistent und daher eher unschön\nnamen <- c('Tobi', \"Lukas\", 'Nadja', \"Christoph\")\n\n# Tod und Verderben (=> funktioniert nicht)\nnamen <- c(\"Tobi\", 'Lukas\", 'Nadja, Christop\")\n```\n:::\n\n\nWir können auch Zahlen in `\"\"` setzen — das ist kein Problem, aber dann sind es nunmal keine Zahlen in diesem Sinne mehr, es sind *Strings*, und mit Strings können wir nicht rechnen.  \nProbiert folgendes aus:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-8_ff5b4e1f3c0497e5474ba0ea41b2bf9d'}\n\n```{.r .cell-code}\n# Okay\n5 + 5\n\n# Hä?\n5 + \"5\"\n```\n:::\n\n\nIhr sehr jetzt vermutlich die Meldung `Error in 5 + \"5\" : non-numeric argument to binary operator`.  \nDas *non-numeric argument* hier ist die `\"5\"`. Merken: `5` ist **numerisch**, aber `\"5\"` ist ein **character** (=> **String**).  \nDer *binary operator* an dieser Stelle ist übrigens das `+`. Ein **Operator**, weil es, äh… operiert? Naja, es tut Dinge, und wenn etwas in R Dinge tut, ist es meistens ein Operator in irgendeinem Sinne. Das *binary* heißt, dass es **zwei** (bi, binär, binary, zwei halt) Argumente nimmt.  \nWie schon gesagt, Argumente sind die Dinge, die wir an Funktionen übergeben, und wenn wir an eine Funktion wie `+` oder auch `mean()` ein Argument übergeben, mit denen sie nichts anfangen können, dann beschwert sich R weil es nicht weiß was zum Geier ihr da vorhabt.  \n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-9_f3427c76183f2d7dd5e4f6e0bd300453'}\n\n```{.r .cell-code}\nnamen <- c(\"Tobi\", \"Lukas\", \"Nadja\", \"Christoph\")\n\nfib <- c(1, 1, 2, 3, 5, 8, 13, 21) \n\n# Alles knorke\nmean(fib)\n#> [1] 6.75\n\n# Alles CHAOS UND UNHEIL\nmean(namen)\n#> Warning in mean.default(namen): argument is not numeric or logical:\n#> returning NA\n#> [1] NA\n```\n:::\n\n\nWas es mit `NA` auf sich hat, und was es noch so für Datentypen gibt, sehen wir dann im Abschnitt zu [Datentypen].\n\nEine letzte Sache noch: Strings sind \"dominanter\" als Zahlen, das heißt, wir können zwar Zahlen verbinden zu `c(1, 2, 3)`, und Strings zu `c(\"A\", \"B\", \"C\")`, aber wenn wir `c(\"A\", 2, \"C\", 4)` schreiben, dann behandelt R einfach alle Elemente des Vektors (=> Das, was in `c(…)`) steht, als wären es `character`-Werte.  \n\n::: {.cell type='rmdimportant' hash='04-Erste-Schritte_cache/html/vector-types_023a86f171508a0a3fb567d139b273e6'}\n\\BeginKnitrBlock{rmdimportant}<div class=\"rmdimportant\">Merke: Ein Vektor in R muss immer Elemente des gleichen Typs haben, Zahlen und Buchstaben zusammen werden zu Strings konvertiert!</div>\\EndKnitrBlock{rmdimportant}\n:::\n\n\n## Tabellen\n\nJetzt haben wir schonmal das Vokuabular an der Hand um Zahlen und beliebige Strings in R zu verarbeiten, aber noch ist das alles etwas unahndlich um damit *richtig* zu arbeiten.  \n\nStellt euch vor, wir wollen einen kleinen Datensatz erstellen über die Statistiktutorien in QM mit Variablen wie *Namen*, *Alter*, und vielleicht sowas wie *Beliebtheit* auf einer Skala von 1-10.  \nWir könnten sowas machen:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-10_75dfcc155dc1bce168117f5926f3ffa5'}\n\n```{.r .cell-code}\nnamen <- c(\"Tobi\", \"Christoph\", \"Nadja\", \"Lukas\")\nalter <- c(20, 35, 30, 12) # (Nicht alle diese Werte sind korrekt)\n\nmean(alter)\n#> [1] 24.25\n```\n:::\n\n\nSchön und gut, aber das ist ja unhandlich. Was, wenn wir die Namen aller TutorInnen haben wollen, die jünger als 30 sind? Alles was wir mit `alter` machen, passiert unabhängig von `namen`.  \n\nUm mehrere Variablen in Kontext zu setzen, gibt es tabellarischen Datenstrukturen, namentlich nennt sich sowas in R dann `data.frame`. Letztendlich ist das nichts anderes als eine Tabelle, aber für R ist eine Tabelle praktische eine Liste von Vektoren mit gleicher länge:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-11_2f6475d40ee4991f3198d42188cf5cd1'}\n\n```{.r .cell-code}\nleute <- data.frame(name = c(\"Tobi\", \"Christoph\", \"Nadja\", \"Lukas\"),\n                    alter = c(20, 35, 30, 12),\n                    beliebtheit = c(9, 10, 8, 3))\n\n# Anzeigen lassen\nleute\n#>        name alter beliebtheit\n#> 1      Tobi    20           9\n#> 2 Christoph    35          10\n#> 3     Nadja    30           8\n#> 4     Lukas    12           3\n```\n:::\n\n\nWas haben wir da gemacht? \n\n- Wir haben einen `data.frame` mit der gleichnamigen Funktion erstellt\n- Die **Argumente** der Funktion haben die Form `Spaltenname = Werte der Spalte`\n- Mehrere Argumente werden mit `,` getrennt und optional mit einem Zeilenumbruch übersichtlich gehalten\n\nDas Ergebnis ist eine Variable `leute`, die drei Spalten mit je vier Werten hat.  \nJede Spalte ist eine Variable, und jede Zeile der Tabelle kann als eine *Beobachtung* betrachtet werden.  \nEine Beobachtung (*Observation*) sind alle Werte, die wir zu einem Untersuchungsobjekt haben, also in diesem Beispiel eine Person. Wenn wir uns nur die erste Zeile anschauen, sehen wir nur die Werte, die zu Tobi gehören, in der zweiten Zeile sehen wir die Werte zu Christoph etc.\n\nTabellen, und damit `data.frames`, sind für uns die wichtigsten Objekte in R, weil wir fast ausschließlich mit Datensätzen in dieser Form arbeiten werden um unsere Statistik da draufzuwerfen.  \nWie können wir jetzt mit einzelnen Variablen arbeiten? \n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-12_1e5e70e61556884a53f3a13543eb5be6'}\n\n```{.r .cell-code}\n# Die Variable \"name\" ausgeben lassen\nleute$name\n#> [1] \"Tobi\"      \"Christoph\" \"Nadja\"     \"Lukas\"\n\n# Den Mittelwert von \"alter\" bestimmen\nmean(leute$alter)\n#> [1] 24.25\n\n# Die Standardabweichung von \"beliebtheit\"\nsd(leute$beliebtheit)\n#> [1] 3.109126\n\n# Was auch funktioniert:\nleute[[\"name\"]]\n#> [1] \"Tobi\"      \"Christoph\" \"Nadja\"     \"Lukas\"\nleute[[\"alter\"]]\n#> [1] 20 35 30 12\n```\n:::\n\n\n<small>Das mit den \"Levels\" wird im Abschnitt zu [Datentypen] erklärt</small>\n\nWas wir hier benutzen nennt sich *Subsetting*, also im Grunde nur einen Teil von etwas rausholen. Hier also einen Teil der Tabelle on Form einer einzelnen Spalte.  \nSpalten können wir mit `$` oder `[[ ]]` direkt aus einem `data.frame` ansteuern, was unser Leben gleich viel einfacher macht. Strenggenommen sidn `$` und `[[` auch eigene Funktionen, aber dazu vielleicht später mehr, im Moment ist für uns nur wichtig, dass wir einzelne Spalten (Variablen) einer Tabelle (`data.frame`) einfach adressieren und genauso behandeln können wie die einzelnen Variablen `name` und `alter`, die wir weiter oben erstellt haben.\n\n## Umgang mit Datensätzen\n\nDa wir noch nicht an dem Punkt sind, wo wir beliebige Daten einlesen können, und wir natürlich zu faul sind uns eine größere Tabelle selber zu schreiben, greifen wir zu Übungszwecken mal auf einen Datensatz zurück, der bei R von Haus aus mitgeliefert wird: `sleep`.\n\nDieser Datensatz beinhaltet die Daten aus einer Medikamentenstudie, bei der es um Schlafgewinn bzw. -verlust ging. Die Tabelle hat drei Spalten (Variablen) zu 10 Personen:\n\n- `extra`: Schlafzuwachs in Stunden, positiv oder negativ für mehr bzw. weniger Schlaf als vorher\n- `group`: Die Versuchsgruppe, sprich welches Medikament die Person bekam, `1` oder `2`\n- `ID`: Die Identifikationsnummer der Person. Es ist gängig, ProbandInnen pseudonymisiert durchzunummerieren, der Zuordnung unt des Datenschutzes wegen als Zahlen.\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-13_10794e00863eb075522441b48b392767'}\n\n```{.r .cell-code}\n# Mit head() lassen wir uns die ersten paar Zeilen (den \"Kopf\") der Tabelle anzeigen\nhead(sleep)\n#>   extra group ID\n#> 1   0.7     1  1\n#> 2  -1.6     1  2\n#> 3  -0.2     1  3\n#> 4  -1.2     1  4\n#> 5  -0.1     1  5\n#> 6   3.4     1  6\n```\n:::\n\n\nWie viele Zeilen hat die Tabelle?\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-14_fd985f59de0ca9f1c491e7c244a8f3b3'}\n\n```{.r .cell-code}\nnrow(sleep)\n#> [1] 20\n```\n:::\n\n\nDie *number of rows* bekommen wir mit `nrow()` — ihr dürft jetzt raten, wie wir uns die Anzahl der Spalten (*columns*) anzeigen lassen können.\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-15_3067adb48bab1b1e11d5df9ddd210a6e'}\n\n```{.r .cell-code}\nncol(sleep)\n#> [1] 3\n```\n:::\n\n\nSurprise!\n\nOkay, aber was interessiert uns an diesem Datensatz jetzt? Wie wäre es mit dem durchschnittlichen Schlafzuwachs:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-16_6572244976f8bb4396c60c3078957919'}\n\n```{.r .cell-code}\nmean(sleep$extra)\n#> [1] 1.54\n```\n:::\n\n\nSchön und gut, aber wir wollen ja vermutlich die beiden Gruppen (Medikamente) vergleichen, also was tun?  \nSubsetting to the rescue /o/\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-17_96b25b1747c5374c161ad73924fd4ce5'}\n\n```{.r .cell-code}\ngruppe1 <- sleep[sleep$group == 1, ]\ngruppe2 <- sleep[sleep$group == 2, ]\n\n# Mittelwert der ersten Gruppe\nmean(gruppe1$extra)\n#> [1] 0.75\n\n# Mittelwert der zweiten Gruppe\nmean(gruppe2$extra)\n#> [1] 2.33\n```\n:::\n\n\nOkay, Schritt für Schritt.  \nHier haben wir unseren ersten logischen vergleich benutzt, um eine Teilmenge der Tabelle zu extrahieren.  \nDas klingt fancy, ist aber ziemlich simpel.  \nIn Worten heißt die Zeile `gruppe1 <- sleep[sleep$group == 1]` lediglich:  \n\"*Nimm die Tabelle `sleep` und filtere daraus alle Zeilen, die zu der Gruppe `1` gehören, und speichere sie in die Variable `gruppe1`*\"\nDas Resultat sind zwei Variablen, die einen Teil der Tabelle `sleep` enthalten, und zwar jeweils zu einer der beiden Gruppen.\n\nWieso dann eigentlich noch diese `, `-Sache am Ende der eckigen Klammern?  \nDas gehört zur Art, wie R Tabellen *indiziert*, sprich wie man einzelne Bereiche der Tabelle ansteuert:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-18_bff6f87c79e2cce4db7513c7398c3a44'}\n\n```{.r .cell-code}\n# Die erste Spalte\nsleep[1]\n#>    extra\n#> 1    0.7\n#> 2   -1.6\n#> 3   -0.2\n#> 4   -1.2\n#> 5   -0.1\n#> 6    3.4\n#> 7    3.7\n#> 8    0.8\n#> 9    0.0\n#> 10   2.0\n#> 11   1.9\n#> 12   0.8\n#> 13   1.1\n#> 14   0.1\n#> 15  -0.1\n#> 16   4.4\n#> 17   5.5\n#> 18   1.6\n#> 19   4.6\n#> 20   3.4\n\n# Die erste Zeile\nsleep[1, ]\n#>   extra group ID\n#> 1   0.7     1  1\n\n# Die erste Zeile und die dritte Spalte\nsleep[1, 3]\n#> [1] 1\n#> Levels: 1 2 3 4 5 6 7 8 9 10\n```\n:::\n\n\nDie allgemeine Form ist `tabelle[Zeilennummer, Spaltennumer]`, und jetzt fragt ihr euch vermutlich, wieso wir vorhin `[[ ]]` benutzt haben, und jetzt `[ ]` — die kurze Antwort ist: Das ist halt was anderes. Die Details sind erstmal nicht so wichtig, was ihr euch vorerst merken solltet ist folgendes:\n\n- `sleep[1]` ergibt einen `data.frame` mit **nur einer Spalte**\n- `sleep[1, ]` ergibt einen `data.frame` mit **nur einer Zeile**\n- `sleep[[1]]` und `sleep$extra` sind **dasselbe** (weil `extra` die erste Spalte ist) und ergeben die erste Spalte als **Vektor**\n- `sleep$extra[[2]]` und `sleep$extra[2]` sind hier **dasselbe**: Das zweite Element im Vektor `sleep$extra`\n\nBei einer Tabelle ist es nützlich mit Zeilen und Spalten zu arbeiten, um die gewünschten Werte rauszuholen, aber bei einem Vektor gibt es in diesem Sinne nur eine Dimension.  \nSinn der Sache ist, dass wir Funktionen wie `mean` oder `sd` nur auf Vektoren anwenden können, was auch intuitiv irgendwie sinnvoll scheint, denn der Mittelwert einer ganzen Tabelle mit mehreren Variablen ist ja konzeptionell etwas… schwierig.\n\n``` r\n# Okay\nmean(sleep$extra)\n#> [1] 1.54\n\n# Das selbe Ergebnis\nmean(sleep[[1]])\n#> [1] 1.54\n\n# Auch okay!\nmean(sleep[[\"extra\"]])\n#> [1] 1.54\n\n# Das hier nicht so\nmean(sleep[1])\n#> Warning in mean.default(sleep[1]): argument is not numeric or logical:\n#> returning NA\n#> [1] NA\n```\n\n`sleep[1]` gibt euch zwar auch die Spalte `extra`, aber wie schon gesagt, in `data.frame`-Form, und nicht als Vektor.\n\nVermutlich verwirrt euch das ganze Geklammere jetzt mehr oder weniger stark, aber glaubt mir, wenn wir erstmal ein Gefühl dafür habt ist es sehr viel Wert diese Grundlagen auf dem Schirm zu haben (oder sie zumindest nachlesen zu können), denn in der ersten Zeit eurer R-Nutzung werdet ihr massenhaft kleinere und größere Fehler in dieser Art machen, wo ihr zwar das richtige *meint*, aber R nicht das richtige *sagt*.  \nDie andere Sache ist, dass ihr das mit den eckigen Klammern gar nicht so häufig brauchen werdet, wenn ihr euch erstmal an das *tidyverse* und *dplyr* gewöhnt habt, aber dazu später mehr.\n\nWir schneiden das Ganze Thema *Subsetting* hier auch erstmal nur an, aber wenn ihr's jetzt schon ganz genau wissen wollt, könnt ihr die Details [hier nachlesen](https://adv-r.hadley.nz/subsetting.html#subsetting-operators)\n\n## Logische Vergleiche\n\nLogik! Eine Welt des Spaßes, der internen Konsistenz[^Naja, fast. Aber Gödel lassen wir mal aus.] und der unendlichen Anwendbarkeit in allen Bereichen.  \nWas ihr intuitiv als Logik kennt ist alleridngs etwas anderes als *formale Logik*, also das, was Computer verstehen.  \nWir brauchen zum Glück nicht all zu viel davon, nur den Standardkram und nichtmal das [volle Spekrum Bool'scher Algebra](https://de.wikipedia.org/wiki/Boolesche_Algebra).\n\nWir brauchen Logik in R in erster Linie zum *indizieren* von Objekten. Das heißt, wenn wir alle Zeilen einer Tabelle haben wollen, für die eine bestimmte Variable einen bestimmten Wert hat oder eine *Bedingung* erfüllt, dann drücken wir das durch Logik aus. Dasselbe funktioniert natürlich auch bei Vektoren (und strenggenommen funktioniert Tabellenindizierung sowieso über Vektorindizierung).\nMan nehme folgendes Beispiel:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-19_189801595fd4ae679724df75c6845165'}\n\n```{.r .cell-code}\nsleep[sleep$extra > 3, ]\n#>    extra group ID\n#> 6    3.4     1  6\n#> 7    3.7     1  7\n#> 16   4.4     2  6\n#> 17   5.5     2  7\n#> 19   4.6     2  9\n#> 20   3.4     2 10\n```\n:::\n\n\nDas heißt: *\"Nimm die Tabelle `sleep` und gib mir alle Zeilen (das mit den eckigen Klammen), für die die Variable `sleep$extra` _größer als 3_ ist\"*.\n\nDas Ergebnis eines logischen Vergleichs ist immer entweder `TRUE` oder `FALSE` für wahr oder falsch.  \nWenn wir in R indizieren wollen, können wir dafür auch direkt `TRUE` und `FALSE` statt eines Vergleichs benutzen:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-20_28124ba72f2cdad0d00cef0ff333ac10'}\n\n```{.r .cell-code}\nfib <- c(1, 1, 2, 3, 5, 8, 13, 21) \n\nfib[c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)]\n#> [1] 1 1\n```\n:::\n\n\nHier haben wir uns effektiv nur die ersten beiden Werte des Vektors `fib` ausgeben lassen, weil R alles ausgibt, was mit `TRUE` indiziert ist und alles weglässt, was mit `FALSE` indiziert ist.  \n`c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)` ist hier ein *logischer Vektor*, also ein Vektor mit, naja, logischen Werten, der praktisch der Reihe nach jedes Element im Vektor `fib` entweder *an* oder *aus* schaltet, wie Lichtschalter. Wir müssen dafür nicht unbedingt einen logischen Vektor der gleichen Länge (Anzahl der Elemente) wie unser Zielvektor (der, den wir indizieren/filtern wollen) benutzen, aber es bietet sich für den Einstieg an so genau wie möglich zu sein.  \nWir könnten aber auch sowas machen:\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-21_04693fc223ad541437c5e9eda4e19470'}\n\n```{.r .cell-code}\n# Immer abwechselnd TRUE und FALSE, also jedes zweite Element\nfib[c(TRUE, FALSE)]\n#> [1]  1  2  5 13\n\n# Schema TRUE TRUE FALSE FALSE ginge auch\nfib[c(TRUE, TRUE, FALSE, FALSE)]\n#> [1] 1 1 5 8\n```\n:::\n\n\nWichtig hierbei ist, dass der logische Vektor ein *ganzer Faktor* des Zielvektors ist, das heißt, dass die Anzahl der Element im Zielvektor *ganz* durch die Anzahl der Elemente im logischen Vektor teilbar sein muss (also ohne Rest), ansonsten bekommen wir potenziell schwer vorhersagbare Ergebnisse.  \nWas R hier macht nennt sich *Recycling*: In der ersten Zeile im letzten Beispiel wird der Vektor `c(TRUE, FALSE)` solange *recyclet*, also wiederverwendet, bis der ganze Zeilvektor \"abgedeckt\" ist. Wenn der logische Vektor nicht sauber in den Zielvektor passt (in Bezug auf die Anzahl der Elemente), dann bleibt entweder was übrig oder es reicht nicht. Das wäre schade.\n\n### Operatoren \n\nEs gibt eine Reihe *logischer Operatoren* wie hier `>` für *\"ist größer als\"*, die wichtigsten in Übersicht:  \n\n- `==` (doppeltes Gleichheitszeichen **ohne Leerzeichen dazwischen**)\n    - \"Ist gleich\"\n    - `1 == 2` --> `FALSE`\n    - `3 == 3` --> `TRUE`\n    - `3 == \"Hallo\"` --> `FALSE`\n- `!=`\n    - \"ist ungleich\"\n    - Die *Negation* von `==`, also immer da wo `==` euch `TRUE` zeigt, gibt `!=` euch `FALSE` und andersherum.\n    - `pi != 3` --> `TRUE`\n    - `\"Psychologiestudium\" != \"Voll gute Idee\"`\n- `!` (ja, ein einfaches Ausrufezeichen)\n    - \"Negation\"\n    - Dreht ein `FALSE` zu einem `TRUE` um und andersherum. Wichtig: Klammern!\n    - `!(2 == 3)`\n    - `TRUE == !FALSE`\n- `>` und `<` (spitze Klammern)\n    - \"ist größer/kleiner als\"\n    - Da wo die Klamer spitz ist, soll das *kleinere* sein\n    - `5 > 4` --> `TRUE`\n    - `2^10 < 1000` --> `FALSE`\n    - `2 < 5 < 4` --> *Funktioniert nicht!*\n- `>=`, `<=`\n    - \"Größer gleich bzw. kleiner gleich\"\n    - Ist *Entweder* `a > b` *oder* `a == b`?\n    - `5 >= 4`\n    - `16 <= 2^4`\n\nDiese Ausdrücke können wir auch auf bestimmte Arten *verknüpfen*:\n\n- `&` (oder auch `&&`)\n    - \"Und\"\n    - Ist `TRUE`, wenn beide Seiten `TRUE` sind\n    - `(1 < 3) & (5 < 10)` --> `TRUE`\n    - `(5 < 2) & (2 < 10)` --> `FALSE`\n    - 1 und 0 werden zu `TRUE` bzw. `FALSE` übersetzt:\n        - `1 & (2 == 2)` --> `TRUE`\n        - `!(0 & FALSE)` --> `TRUE`\n- `|` (oder auch `||`)\n    - \"Oder\"\n    - Ist *entweder* A *oder* B *oder* beides `TRUE`?\n    - Da `|` auch wahr ist, wenn nur eine Seite wahr ist, ist es auch Grundlage etlicher Mathe-/Logikwitze\n    - `(1 < 3) | (5 < 10)` --> `TRUE`\n    - `(5 < 2) | (2 < 10)` --> `TRUE`\n- `xor()`\n    - \"Entweder … oder …\" (*ausschließend*!)\n    - Wenn euch `|` zu unspezifisch ist\n    - Ist *nur* war, wenn *eins von beidem* wahr ist, aber nicht, wenn beides wahr ist\n    - **Kein** *binärer Operator* wie die anderen, sondern eine R-Funktion mit Klammern und so\n    - `xor(TRUE, FALSE)` --> `TRUE`\n    - `xor(TRUE, TRUE)` --> `FALSE`\n    - `xor((1 < 3), (5 < 10))` --> `FALSE`\n    - `xor((5 < 2), (2 < 10))` --> `TRUE`\n    \n### Spezielle Tests\n\nDie obigen Operatoren können wir für getrost für Vektorvergleiche benutzen, aber es gibt noch ein paar Sonderfälle. Was zum Beispiel, wenn wir nur generell wissen wollen, ob ein Element wie eine Zahl oder ein String in einem Vektor enthalten ist? Oder was, wenn wir wir auf spezielle Typen oder Klassen testen wollen? Was das im Detail heißt sehen wir in den entsprechenden Abschnitten zu [Datentypen] noch einmal, aber hier schonmal eine Kurzreferenz:\n\n- `%in%` (auch hier, *ohne Leerzeichen* dazwischen!)\n    - \"Ist in\"\n    - Mengentheoretisch ist das $x \\in X$\n    - Ist Element `a` in Menge `b`?\n    - `5 %in% c(1, 4, 5, 3)` --> `TRUE`\n    - `\"B\" %in% c(\"a\", \"b\", \"c\")` --> `FALSE`\n    - `\"B\" %in% c(\"a\", \"B\", \"c\")` --> `TRUE`\n    - `c(1, 2) %in% 1:5` --> `TRUE`\n- `is.na()`: Testet auf fehlende Werte (*missing values*, `NA`)\n- `is.null()`: Testet auf leere Werte (`NULL`)\n- `is.nan()`: Testet auf `NaN` (*Not a Number*)\n\n### Indexing: Beispiele\n\nDas war jetzt relativ viel Information, und ihr müsst euch das auch nicht alles sofort merken, sondern nur wissen, wo ihr's bei Bedarf nachschlagen könnt.  \nDie Motivation hinter dem Logikram ist wie erwähnt primär das Filtern von Tabellen und Vektoren, was wir nunmal relativ häufig brauchen um zum Beispiel bestimmte Untergruppen in unseren Datensätze zu analysieren, zum Beispiel Personen älter als 35 (z.B. `age > 35`) oder Menschen, die sowohl weiblich sind als auch Medikament B bekommen haben (z.B. `geschlecht == \"weiblich\" & drug == \"B\"`).  \n\n#### Vektoren\n\nVektoren werden immer *elementweise* verglichen, das heißt, dass das Ergebnis von `c(1, 2) == 1` nicht `FALSE` oder `TRUE` ist, sondern der *logische Vektor* `TRUE FALSE`. Dadurch entsteht durch den logischen Vergleich eines Vektors ein Vektor aus `TRUE` und `FALSE`, den wir zum indizieren benutzen können, wie wir weiter oben schon gesehen haben.\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-22_143b825e44f67a220e898a048e57c54d'}\n\n```{.r .cell-code}\n# Irgendwelche Zahlen\nx <- c(4, 7, 2, 1, 7, 9, 6, 5, 4, 3, 3, 2, 2, 5, 8, 9, 31)\n\n# Alle Zahlen größer 4: \"Gib mir x, wo x > 4\"\nx[x > 4]\n#> [1]  7  7  9  6  5  5  8  9 31\n\n# Die Logik dahinter\nx > 4\n#>  [1] FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n#> [13] FALSE  TRUE  TRUE  TRUE  TRUE\n\n# Alle Zahlen größer 5 und kleiner 20\nx[x > 5 & x < 20]\n#> [1] 7 7 9 6 8 9\n```\n:::\n\n\nDas Ganze lässt sich natürlich beliebig komplex aussehen lassen, weshalb zu viele Bedingungen in Kombination etwas verwirrend aussehen können.  \nWeiterhin können wir einen Vektor natürlich auch durch einen Vergleich eines anderen Vektors indizieren.\n\n\n::: {.cell hash='04-Erste-Schritte_cache/html/unnamed-chunk-23_1729ca7bbe59266aabb6cbe4f95f968e'}\n\n```{.r .cell-code}\nx <- c(4, 7, 2, 1, 7, 9, 6, 5, 4, 3)\ny <- c(6, 7, 10, 1, 9, 3, 6, 5, 6, 3)\n\n# x, wo x größer gleich 4 ist *und* y kleiner 6\nx[x >= 4 & (y < 6)]\n#> [1] 9 5\n\n# x, wo x und y identisch sind\nx[x == y]\n#> [1] 7 1 6 5 3\n\n# x, wo x kleiner y ist\nx[x < y]\n#> [1] 4 2 7 4\n```\n:::\n\n\n#### Tabellen <small><code>data.frame</code></small>\n\nTabellenindexing ist nichts anderes als Vektorindexing mit einer anderen Struktur. \nAlle Regeln zum Vektorindexing, die wir bisher gesehen haben, gelten auch so für `data.frames`, nur dass wir hier jetzt auf einmal in Spalten und Zeilen denken müssen, anstatt in Vektoren.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}