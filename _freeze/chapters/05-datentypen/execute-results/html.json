{
  "hash": "637b5787f1828a906542eb7879bffdd7",
  "result": {
    "markdown": "# Datentypen\n\n\n\n\n\nEs gibt eine Reihe von Unterscheidungsmöglichkeiten zwischen verschiedenen Arten von Daten.  \nNeben der naheliegenden Unterscheidung zwischen \"Zahlen\" und \"Buchstaben\" gibt es diverse andere Typen, die R verwendet.  \nTechnisch gesehen müssten wir hier noch zwischen Typen und Klassen unterscheiden, aber für die meisten unserer normalen Anwendungszwecke ist es nicht unbedingt notwendig Typen und Klassen auseinanderhalten zu können, weshalb wir hier auch mehr oder weniger beides gleichzeitig abhandeln.\n\n*\"Und wieso sollte uns interessieren, wie R da unterscheidet?\"*  \nR ist verwirrt, wenn wir Buchstaben in eine Funktion stecken, die Zahlen erwartet. Genauso ist R verwirrt, wenn wir den Mittelwert aus einer Tabelle berechnen wollen. Mittelwerte sind nur dann sinnvoll, wenn wir sie aus einem Vektor aus numerischen Werten berechnen. Da eure Daten in verschiedenen Formaten ankommen, und unterschiedliche Repräsentationen unterschiedliche Vor- und Nachteile haben, ist es wichtig, dass ihr im Zweifelsfall herausfinden könnt was ihr da vor der Nase habt und wie ihr damit arbeiten könnt.  \nWas eine R-Funktion mit einem Objekt anstellt hängt von der *Klasse* des Objekts ab, das ganze fällt vermutlich irgendwo unter *\"object oriented programming\"*, und wenn ihr InformatikerInnen kennt und die euch Fragen, ob R eine funktionale oder objektorientierte Frage ist, könnt ihr getrost \"ja\" sagen[^logic].\n\nDie wichtigste Funktion für diesen Abschnitt ist `class()`, was euch sagt was R unter einem bestimmten Objekt versteht (die *Klasse* des Objekts):\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-2_8937f651100cc3fd0eaed9912c108802'}\n\n```{.r .cell-code}\nclass(4)\n#> [1] \"numeric\"\nclass(c(1, 2, 3))\n#> [1] \"numeric\"\nclass(c(\"hallo\", \"welt\"))\n#> [1] \"character\"\nclass(sleep)\n#> [1] \"data.frame\"\nclass(sleep$extra)\n#> [1] \"numeric\"\nclass(sleep$group)\n#> [1] \"factor\"\n```\n:::\n\n\n<small>(Was es mit `factor` auf sich hat sehen wir ein paar Abschnitte weiter)</small>\n\nZusätzlich gibt es `typeof()`, eine Funktion, die so speziell ist, dass ich sie in meinen ~4 Jahren R erst neulich entdeckt habe, weil der exakte *Typ* eines Objekts meistens weniger relevant ist als die *Klasse*:\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-3_8bec388265835e036c13cccf6e8a4635'}\n\n```{.r .cell-code}\ntypeof(4)\n#> [1] \"double\"\ntypeof(c(1, 2, 3))\n#> [1] \"double\"\ntypeof(c(\"hallo\", \"welt\"))\n#> [1] \"character\"\ntypeof(sleep)\n#> [1] \"list\"\ntypeof(sleep$extra)\n#> [1] \"double\"\ntypeof(sleep$group)\n#> [1] \"integer\"\n```\n:::\n\n\n## Numeric <small class=\"subtitle\">(Zahlen und so)</small>\n\nZahlen in R (und in den meisten anderen Programmiersprachen, beziehungsweise generell irgendwo, wo Maschinen rechnen) kommen in zwei Geschmacksrichtungen: **Integer** (ganze Zahlen) und **double** (Dezimalzahlen, Fließkommazahlen, *floating point numbers*).  \nDer Grund dafür hat damit zu tun, wie Computer intern Zahlen abbilden, binäres Zahlensystem, Bits, ihr wisst schon — komplizierter Kram wo sich kluge Menschen Dinge ausdachten, mit denen wir arbeiten können, wir aber nicht im Detail verstehen müssen.  \nFließkommazahlen sind so gängig, dass R sogar eine einfache ganze Zahl wie `2` erstmal als *double*, also praktisch als `2.0` interpretiert, und wir explizit `2L` schreiben müssen, wenn wir *\"2, aber als integer\"* meinen. Wieso wir dafür `L` brauchen sei dahingestellt, aber nun ja, der Unterschied ist da:\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-4_c69a30c615ad0acadf86edcb1f9c5564'}\n\n```{.r .cell-code}\n# Beides \"numeric\"\nclass(2)\n#> [1] \"numeric\"\nclass(2.5)\n#> [1] \"numeric\"\n\n# Aber…\ntypeof(2L)\n#> [1] \"integer\"\n\n# …und\ntypeof(2.5)\n#> [1] \"double\"\n```\n:::\n\n\n\nIntegers sind ziemlich unproblematisch, werden aber in der Praxis nicht häufig explizit genutzt.  \nFließkommazahlen (*double*) hingegen tauchen häufiger auf, weil Computer in den letzten Jahrzehnten *echt verdammt gut* darin geworden sind, mit Fließkommazhalen zu rechnen. Arithmetik mit integers ist auch okay, aber wenn eure Datensätze riesig und eure Statistik komplex ist, dann ist Geschwindigkeit von Rechenoperationen auf ein mal ein wichtiger Faktor.  \nDas Problem an der Sache ist nur leider, dass Fließkommazahlen seltsam sind. Nicht nur vom initialen Verständnis her, dazu empfehle ich euch herzlichst [dieses schöne Video von Tom Scott](https://www.youtube.com/watch?v=PZRI1IfStY0), sondern auch für ganz reale Konsequenzen, über die wir stolpern können, wenn wir nicht aufpassen:\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-5_484004b295ee27e83e59ba5eca588865'}\n\n```{.r .cell-code}\n# Wurzel aus 2, ganz harmlos\nsqrt(2)\n#> [1] 1.414214\n\n# Quadrierte Wurzel aus 2 ergibt 2, ja, kommt hin\nsqrt(2)^2\n#> [1] 2\n\n# Das sollte ja dann…\nsqrt(2)^2 == 2\n#> [1] FALSE\n```\n:::\n\n\n<small>Wait, what?</small> \n\nUnd das ist der Grund warum Fließkommazahlen (*double*) seltsam sind.  \nDie kurze Version: $\\sqrt{2}$ ist eine *irrationale Zahl*, das heißt sie hat *unendlich viele Nachkommastellen*. Computer können nur eine begrenzte Anzahl an Nachkommastellen speichern, weshalb das Resultat von einer Berechnung wie $\\left(\\sqrt{2}\\right)^2$ zwar für alle praktischen Zwecke immer noch 2 ist, aber *irgendwie auch nicht*. Wenn wir mit Datensätzen arbeiten und darin rumrechnen dann sind solche kleinen Rundungsfehler egal, aber wenn wir uns auf Operatoren wie `==` verlassen, um berechnete Werte zu vergleichen, dann müssen wir vorsichtig sein.  \n\nAn dieser Stelle ein kurzer Exkurs in die Numerik:  \nDie absolut kleinste Toleranz, die euer Computer für Fließkommazahlen berücksichtigt, könnt ihr euch mit `.Machine$double.eps` anzeigen lassen[^bits]. `.Machine` ist ein besonderes Objekt in R, dass Informationen zu eurem Computer (sprich eurer *Maschine*) sammelt.  \n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-6_452ca5bf78bf8612bd804cecc77693c1'}\n\n```{.r .cell-code}\n# Wie groß ist die Abweichung vom erwarteten Ergebnis?\nsqrt(2)^2 - 2\n#> [1] 4.440892e-16\n```\n:::\n\n\n`4.4408920985e-16` ist Computer für $4.4408920985 \\cdot 10^{-16}$, also ungefähr…\n\n\n$$\\frac{4.4408920985}{10000000000000000} \\approx 0.00000000000000044$$\n\n\nDas ist… ziemlich wenig, und im Alltag auch ziemlich egal, aber wie gesagt: Für R ist das ein Unterschied.\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-7_157bcffa6809319de626a2b9783a7b06'}\n\n```{.r .cell-code}\n# Wie groß ist die Toleranz?\n.Machine$double.eps\n#> [1] 2.220446e-16\n\n# Moment mal…\n.Machine$double.eps * 2\n#> [1] 4.440892e-16\n\n# Wenn jetzt…\n(.Machine$double.eps * 2) == (sqrt(2)^2 - 2)\n#> [1] TRUE\n```\n:::\n\n\nTatsache.  \nWir könnten noch weiter damit rumspielen, aber als Lektion sollte eigentlich nur hängenbleiben, dass Zahlen in R gerne mal mehr sind, als euch in der Konsole angezeigt wird.\n\n::: {.cell type='rmdimportant' hash='05-datentypen_cache/html/float-rounding_84e5724341ac4c11ae67ad8d0a15c4fc'}\n\\BeginKnitrBlock{rmdimportant}<div class=\"rmdimportant\">> One does not simply *round* floating point numbers\n> --- [Programmer Boromir](https://ironholds.org/projects/rbitrary/#why-doesnt-round-work-like-you-think-it-should)\n</div>\\EndKnitrBlock{rmdimportant}\n:::\n\nWenn ihr mal auf sowas stoßen solltet, dann verwendet am besten einfach die Funktion `round()` um eure Werte auf eine sinnvolle Anzahl Nachkommastellen zu runden:\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-8_6276473c6c627122b8b6e34598993596'}\n\n```{.r .cell-code}\n# Auf 5 Stellen gerundete Wurzel 2\nround(sqrt(2), digits = 5)\n#> [1] 1.41421\n\n# Gerundetes Ergebnis von \"Wurzel 2 hoch 2\"\nround(sqrt(2)^2, digits = 5)\n#> [1] 2\n\n# Literally close enough.\nround(sqrt(2)^2, digits = 5) == 2\n#> [1] TRUE\n```\n:::\n\n\n::: {.cell type='rmdtip' hash='05-datentypen_cache/html/float-rounding_tip_55ac4eff806c0fc212a1a6e3bcbe1748'}\n\\BeginKnitrBlock{rmdtip}<div class=\"rmdtip\">Im Zweifelsfall einfach Genauigkeit opfern um den Verstand zu behalten</div>\\EndKnitrBlock{rmdtip}\n:::\n\nTheoretisch ist \"numeric\" für Zahlen eine *Klasse*, und *integer* und *double* sind die beiden *Typen*, aus denen die Klasse besteht.\n\n## Character <small class=\"subtitle\">(Buchstabenzeugs)</small>\n\n*Characters* sind *Strings* sind *irgendwas was aus mehr als nur Zahlen besteht* (zumindest meistens). Die Unterscheidung zwischen *numeric* und *character* ist intuitiv ziemlich einfach, und in eurer statistischen Praxis werdet ihr vermutlich meistens auf *numerics* treffen, wobei *characters* dann meistens nur für nominale Variablen (Gruppenzugehörigkeiten, Entscheidungen für *A*, *B*, *C*) gebraucht werden. Tatsächlich werden eure nominalen Variablen sogar eher als `factor` daherkommen, dazu dann der nächste Abschnitt.\n\nCharacters verhalten sich im Grunde wie Worte. Wir können sie aneinanderhängen, wir können sie vergleichen, aber wir können zum Beispiel keine Berechnungen damit durchführen:\n\n``` r\nnamen <- c(\"Lukas\", \"Tobias\", \"Christoph\")\nmean(namen)\n#> Warning in mean.default(namen): argument is not numeric or logical:\n#> returning NA\n#> [1] NA\n\n# Zahlen != Buchstaben\n5 == \"5\"\n#> [1] TRUE\n\n# Groß- / Kleinschreibung ist wichtig!\n\"Lukas\" == \"Lukas\"\n#> [1] TRUE\n\"Lukas\" == \"LUKAS\"\n#> [1] FALSE\n\n# Strings aneinanderhängen\npaste(\"Lukas\", \"hat\", \"Spass\", sep = \"_\")\n#> [1] \"Lukas_hat_Spass\"\n```\n\nDie Funktionen `paste` und `paste0` sind ziemlich praktisch wenn ihr mit Strings arbeitet, die werdet ihr früher oder später mal brauchen.  \nAnsonsten dürfte euch aufgefallen sein, dass man *Spaß* mit *ß* schreibt. Das ist korrekt. Allerdings zählt *ß* als Sonderzeichen, genauso wie Umlaute (*üöä*). R kann damit zwar prinzipiell umgehen, solange ihr das richtige *Encoding* verwendet, aber dennoch bietet es sich an auf Sonderzeichen in R-Code zu verzichten, um Inkompatibilität mit anderen vorzubeugen.\n\nUm eure Einstellungen anzupassen und auf Nummer sicher zu gehen, öffnet die Einstellungen von RStudio und setzt die folgende Einstellung auf **UTF-8** (Unicode):\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-9_e4b6b8b5db2114f7727e911cb8854694'}\n::: {.cell-output-display}\n![RStudio > Optionen > Code > Saving: UTF-8](../images/character_encoding_settings.png){width=296}\n:::\n:::\n\n\nEncoding ist so der einfachste Grund aus dem eure Scripte und Dokumente auf einmal kaputt aussehen, wenn ihr sie von einem Windows-Rechner an einen Mac oder eine Linux-Kiste schickt. Mac und Linux können sich wenigstens meistens auf Unix-Standards und Unicode eignen, aber Windows… Windows ist seltsam.\n\n::: {.cell type='rmdimportant' hash='05-datentypen_cache/html/encoding_f1afc75e5a5a7f147ab520dbcf75f94d'}\n\\BeginKnitrBlock{rmdimportant}<div class=\"rmdimportant\">Encoding ist kodifizierter Selbsthass, aber [Unicode ist großer Spaß](https://romain.rbind.io/blog/2017/08/03/unicode-utf-8-strings-and-emojis/)</div>\\EndKnitrBlock{rmdimportant}\n:::\n\n## Factor <small class=\"subtitle\">(Here be dragons)</small>\n\nOkay, der haarige Teil.  \nDie `factor`-Klasse in R ist unheimlich praktisch, aber auch ziemlich unintuitiv bei der ersten Verwendung. Das liegt nicht zuletzt daran, dass ein `factor` von aussehen meistens einfach aussieht wie ein `character`, aber nunmal kein `character` ist.  \n*Factors* haben zwei Bestandteile:\n\n- `level`: Die *Merkmalsausprägung*, so wie R den `factor` sieht. Meistens *numeric*.\n- `label`: (*Optional*) Die *Bezeichnung der Merkmalsausprägungen*, meistens `character`, für die bessere Lesbarkeit.\n\nEin Beispiel aus dem `sleep`-Datensatz:\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-10_ba78a3b3cf7f110abb413d63ad5693e9'}\n\n```{.r .cell-code}\n# Die Vairable \"group\"\nsleep$group\n#>  [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2\n#> Levels: 1 2\n\n# …hat die Klasse \"factor\"\nclass(sleep$group)\n#> [1] \"factor\"\n\n# Und die levels…\nlevels(sleep$group)\n#> [1] \"1\" \"2\"\n```\n:::\n\n\nWir sehen, dass `group` die Merkmalsausprägungen (*levels*) `1` und `2` hat, aber das ist für uns möglicherweise nicht wirklich aussagekräftig. Wir können die Variable modifizieren, und einen schöneren `factor` daraus machen:\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-11_c8baf8d8935501889b679878ca475b4f'}\n\n```{.r .cell-code}\n# Wir modifizieren nur die labels, nicht die level\nsleep$group <- factor(sleep$group, levels = c(1, 2), labels = c(\"Medikament A\", \"Medikament B\"))\n\n# Jetzt werden uns unsere Labels angezeigt\nsleep$group\n#>  [1] Medikament A Medikament A Medikament A Medikament A Medikament A\n#>  [6] Medikament A Medikament A Medikament A Medikament A Medikament A\n#> [11] Medikament B Medikament B Medikament B Medikament B Medikament B\n#> [16] Medikament B Medikament B Medikament B Medikament B Medikament B\n#> Levels: Medikament A Medikament B\n\n# Und unsere unveränderten Levels\nlevels(sleep$group)\n#> [1] \"Medikament A\" \"Medikament B\"\n\n# Aber wir können den factor immer noch wie Zahlen behandeln\nas.numeric(sleep$group)\n#>  [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2\n```\n:::\n\n\nMit `factor` können wir praktisch zwei Lagen an Informationen in nur einer Variable speichern, einmal numerische *levels* und einmal character *labels*. Die Levels sind die eigentlich wichtige Information und die Labels sind praktisch nur für uns zur besseren Lesbarkeit da, zum Beispiel bei Tabellen oder Grafiken.  \n\n## Besondere Typen\n\nEure Daten kommen meistens von anderen, zumindest in den ersten Semestern eures Studiums.  \nMeistens kommen eure Daten auch mit Fehlenden oder irgendwie kaputten Werten, mit denen ihr ohne Weiteres nichts anfangen könnt.  \n\n### Fehlende Werte: `NA`\n\nVermutlich der wichtigste Datentyp, der euch begegnen wird. `NA` steht für *Not Available* und heißt, dass es an dieser Stelle einfach keinen Wert gibt. In einem Fragebogen wäre das zum Beispiel eine nicht ausgefüllte Frage, und das heißt für euch, dass ihr ohne Weiteres keine Annahme über diese Wert machen könnt. `NA` heißt nicht \"da ist nichts\", sondern eher \"da könnte was sein, aber ich weiß nicht\".  \nDas ist auch der Grund, warum der Mittelwert nicht funktioniert, wenn da `NA` drinstecken:\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-12_996f886ab0ada49e57e54e208237c926'}\n\n```{.r .cell-code}\nmean(c(1, 2, NA, 4, 5, NA, 7))\n#> [1] NA\n```\n:::\n\n\nKlar könnten wir einfach annehmen, dass die fehlenden Werte `3` und `6` sind, aber das wissen wir nunmal nicht, und da R in der Regel nicht rät, sagt es halt auch \"weiß nicht\" in Form von `NA`.  \nIn solchen Fällen müsst ihr explizit `NA` ignorieren:\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-13_1be9d4fc1278031a1dd7f59567859038'}\n\n```{.r .cell-code}\nmean(c(1, 2, NA, 4, 5, NA, 7), na.rm = TRUE)\n#> [1] 3.8\n```\n:::\n\n\nIhr könnt auch mit der Funktion `is.na` prüfen, ob ihr fehlende Werte habt. Beachtet, dass `==` zum vergleichen nicht funktioniert!\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-14_83dbaa0497f6bdb48ef866f5fd6e3c51'}\n\n```{.r .cell-code}\nzahlen <- c(1, 2, NA, 4, 5, NA, 7)\n\nis.na(zahlen)\n#> [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE\n\n# Alle 'zahlen', für die is.na() _nicht_ TRUE ist\nzahlen[!is.na(zahlen)]\n#> [1] 1 2 4 5 7\n\n# An welcher Position sind die NAs?\nwhich(is.na(zahlen))\n#> [1] 3 6\n```\n:::\n\n\n\n### Leere Werte: `NULL`\n\nWenn `NA` fehlende Werte sind, was soll dann `NULL` sein?  \nNaja, ich merke mir das immer ungefähr so:\n\n- `NULL`: Da ist *nichts*, also so wirlich _*nichts*_, und ich weiß das auch!\n- `NA`: Da ist zwar *nichts*, aber ich hab _*keine Ahnung*_ ob da nicht doch was sein sollte ¯\\\\\\_(ツ)_/¯\n\n`NULL` wird euch vermutlich weniger häufig begegnen als `NA`, zumindest in Datensätzen.  \nAnsonsten taucht `NULL` eher bei R-Funktionen als *default argument* auf, also ein Argument einer Funktion, das nicht gesetzt ist, außer ihr setzt es explizit. Das klingt jetzt etwas abstrakt, aber wir werden im Laufe dieser Einführung vermutlich noch Beispiele dafür sehen.\n\n::: {.cell type='rmdnote' hash='05-datentypen_cache/html/null_na_e540ffd792f8c0e312e31a5f198ab246'}\n\\BeginKnitrBlock{rmdnote}<div class=\"rmdnote\">`NULL` ist leer, und zwar mir Sicherheit  \n`NA` ist leer, aber man weiß es nicht so recht</div>\\EndKnitrBlock{rmdnote}\n:::\n\n### To `Inf` and Beyo`NaN`d!\n\nHabt ihr schonmal durch 0 geteilt? Oder überlegt was $0^0$ ist?  \nDas ist die Ecke, in der `Inf` und `NaN` auftauchen.  \n\n`Inf` und `-Inf` stehen erstmal nur für $\\infty$ und $-\\infty$ und sind Rs Weg euch zu sagen, dass ihr da gerade den Bereich der alltagstauglichen Zahlen überschritten habt.  \nNehmt mal folgendes Beispiel:\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-15_98bcfb646c4f88f7b29c6437644c11df'}\n\n```{.r .cell-code}\n# 2 hoch 10… geht noch\n10^10\n#> [1] 1e+10\n\n# Auch das…\n10^100\n#> [1] 1e+100\n\n# Okay, aber jetzt…\n10^1000\n#> [1] Inf\n```\n:::\n\n\nDas ist R einfach zu viel, bzw. es ist eurem Computer generell zu viel.  \nKurzer reminder: `1e10` ist Computer für $1 \\cdot 10^{10}$, also eine 1 mit 10 Nullen, also…\n\n\n$$1e10 = 1 \\cdot 10^{10} = 10000000000$$\n\n\nDementsprechend könnt ihr euch vorstellen, wie groß $10^{1000}$ wäre, und R macht solche Späße nicht mit und sagt einfach `Inf`.  \nWenn ihr `Inf` oder `-Inf` in euren Ergebnissen seht, dann solltet ihr nur wissen, dass es da ein entweder *viel zu großes* oder *viel zu kleines* Ergebnis gab. \n\nUnd dann ist da noch die Sache mit `NaN`.  \n`NaN` steht für *not a number* und passiert dann, wenn ihr irgendwas mathematisch fragwürdiges macht, wie zum Beispiel 0 durch 0 teilen:\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-16_cd01872ab2d16125e420079531f44f1c'}\n\n```{.r .cell-code}\n0 / 0\n#> [1] NaN\n```\n:::\n\n\nDas ist mathematisch nicht definiert, und wieso das so ist und mehr dazu findet ihr zum Beispiel bei [Numberphile](https://www.youtube.com/watch?v=BRRolKTlF6Q) gut erklärt.  \nHier solltet ihr auch nur wissen, dass es das gibt und dass ihr es im Zweifelsfall vermeiden wollt, wenn es in euren Ergebnissen auftaucht.\n\n## Tabellen: `data.frame`\n\nAll eure Datensätze im Studium kommen in Tabellenform.  \nTabellen in R sind im Grunde nichts anderes als Listen von Vektoren mit gleiche Länge: Der `sleep`-Datensatz zum Beispiel besteht aus drei Vektoren der Länge 20, und jede Spalte verhält sich wie ein Vektor mit bestimmten Typen.  \nUm sich einen Überblick über einen Datensatz zu verschaffen empfiehlt sich die Funktion `str` (lies *structure*), oder auch `head`:\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-17_7e8ebfada93d51348aeb64c6af3ccee7'}\n\n```{.r .cell-code}\n# Die ersten paar Zeilen\nhead(sleep)\n#>   extra        group ID\n#> 1   0.7 Medikament A  1\n#> 2  -1.6 Medikament A  2\n#> 3  -0.2 Medikament A  3\n#> 4  -1.2 Medikament A  4\n#> 5  -0.1 Medikament A  5\n#> 6   3.4 Medikament A  6\n\n# Nur die ersten 2 Zeilen\nhead(sleep, n = 2)\n#>   extra        group ID\n#> 1   0.7 Medikament A  1\n#> 2  -1.6 Medikament A  2\n\n# Struktur des Datensatzes\nstr(sleep)\n#> 'data.frame':\t20 obs. of  3 variables:\n#>  $ extra: num  0.7 -1.6 -0.2 -1.2 -0.1 3.4 3.7 0.8 0 2 ...\n#>  $ group: Factor w/ 2 levels \"Medikament A\",..: 1 1 1 1 1 1 1 1 1 1 ...\n#>  $ ID   : Factor w/ 10 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10 ...\n```\n:::\n\n\nDas Output von `str` sagt euch alles, was ihr braucht:\n\n- Die *Klasse* des Objekts, hier ein `data.frame`, das Tabellenformat\n    - Die Anzahl der Zeilen (`20 obs.`), und Spalten (`3 variables`)\n- Die Spalten der Tabelle mit den ersten Werten\n    - `extra`: Numerisch (`num`)\n    - `group`: `factor` mit 2 Merkmalsausprägungen (`w/ 2 levels`), die *Labels* und die *Levels*\n    - `ID`: `factor` mit 10 *Labels* (`\"1\", \"2\", \"3\" …`) und *Levels* (`1 2 3 4 …`)\n    \nSpäter werden wir noch andere Klassen für Tabellen sehen, die `data.frame` erweitern bzw. etwas aufhübschen, namentlich wird das [`tbl_df` bzw. `tibble`](https://tibble.tidyverse.org/) sein, aber dazu müssen wir uns erst *Packages* ansehen.  \n\n## Prüfen & Konvertieren {#convert}\n\nWas wir im Abschnitt zu `factor` am Ende mit `as.numeric` gemacht haben fällt unter *Coercion*, und heißt, dass Werte eines Typs in einen anderen Typ konvertiert werden sollen. Das Gegenstück dazu wäre `is.numeric`, was nachsieht, ob eine Variable bereits *numeric* ist.\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-18_dfad4c9dc6967c167ba5de60338c5b45'}\n\n```{.r .cell-code}\nas.numeric(\"5\")\n#> [1] 5\nas.numeric(5)\n#> [1] 5\n\nas.character(c(2, 5, 4, 3))\n#> [1] \"2\" \"5\" \"4\" \"3\"\n```\n:::\n\n\nEs gibt etliche solcher Konvertierungsfunktionen in R, manche mehr oder weniger nützlich, aber nun gut, sie sind da:\n\n\n::: {.cell hash='05-datentypen_cache/html/unnamed-chunk-19_0a232a44b01f23cae880c12bff384819'}\n\n```{.r .cell-code}\n# Römische Zahlen\nas.roman(2017)\n#> [1] MMXVII\n\n# Hexadezimal\nas.hexmode(255)\n#> [1] \"ff\"\n\n# Logische Werte\nas.logical(0)\n#> [1] FALSE\nas.logical(1)\n#> [1] TRUE\n```\n:::\n\n\n\n<!-- Footnotes -->\n\n[^bits]: Habt ihr mal im Kontext von Computern oder Betriebssystemen/Software von \"32bit\" und \"64bit\" gehört? Da geht's tatsächlich genau um dieses Ding mit den Fließkommazahlen. 64 bit kann einfach mehr Nachkommastellen speichern als 32bit. Vergleiche dazu auch `.Machine$double.digits` auf einem 32bit gegen ein 64bit-Betriebssystem\n\n[^logic]: Das ist einer von diesesn Logikwitzen basierend auf dem Umstand, dass das logische *oder* (`a | b`) auch *wahr* ist, wenn sowohl `a` als auch `b` *wahr* ist.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}